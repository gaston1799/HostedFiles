// ==UserScript==
// @name        .PROJECT NOZO
// @author       Gaston_
// @description  Discord:gaston1799 I FIXED ZA'S MOD DOESNT CRASH SO OFTEN no bots sadly left the functions for it in the code
// @version      final
// @match        *://*.moomoo.io/*
// @match        *://dev.moomoo.io/*
// @icon         https://moomoo.io/img/animals/cow_1.png
// @grant   GM_getValue
// @grant   GM_setValue
// @grant   GM_deleteValue
// @grant GM_xmlhttpRequest
// @run-at document-start
// @grant unsafeWindow
// @grant   GM_addValueChangeListener
// @grant   GM_removeValueChangeListener
// @namespace https://greasyfork.org/users/1404332
// @downloadURL https://update.greasyfork.org/scripts/519513/%21%20za%27s%20mod%20-%20unpatched.user.js
// @updateURL https://update.greasyfork.org/scripts/519513/%21%20za%27s%20mod%20-%20unpatched.meta.js
// ==/UserScript==
//twitch chat thing
/*
let t       = music_frame.src;
let channel = t.split('?')[1].split('&')[0].split('=')[1];
let parent  = window.location.hostname;        // e.g. "example.com"
let container = id('guideCard') || document.body;

// try to grab the existing iframe
let chatIframe = id('tchat');

if (!chatIframe) {
  // doesn’t exist yet → create it and append
  chatIframe = CE('iframe', 'tchat');          // or: document.createElement('iframe'); chatIframe.id = 'tchat';
  container.appendChild(chatIframe);
}

// now set/update its attributes
chatIframe.src = `https://www.twitch.tv/embed/${channel}/chat?parent=${parent}`;
chatIframe.height = 700;
chatIframe.width  = '100%';
chatIframe.setAttribute('sandbox',
  'allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-modals'
);

*/
// 1) stash the originals
pathfinding_=function(){
    var toInt = function(n) { return ~~n; };
    var DiagonalMovement_= {
        Always: 1,
        Never: 2,
        IfAtMostOneObstacle: 3,
        OnlyWhenNoObstacles: 4
    };

    const Heuristic_=function(exports={}){
        /**
 * @namespace PF.Heuristic
 * @description A collection of heuristic functions.
 */
        return {

            /**
   * Manhattan distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} dx + dy
   */
            manhattan: function(dx, dy) {
                return dx + dy;
            },

            /**
   * Euclidean distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy)
   */
            euclidean: function(dx, dy) {
                return Math.sqrt(dx * dx + dy * dy);
            },

            /**
   * Octile distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy) for grids
   */
            octile: function(dx, dy) {
                var F = Math.SQRT2 - 1;
                return (dx < dy) ? F * dx + dy : F * dy + dx;
            },

            /**
   * Chebyshev distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} max(dx, dy)
   */
            chebyshev: function(dx, dy) {
                return Math.max(dx, dy);
            }

        };
    }()
    const Heap_=(function(exports={}) {

        // -- Utility --
        // originally: export const toInt = (n: number): number => ~~n;

        // -- Heap class --
        // originally: export class Heap<T> implements Iterable<T> { … }
        class Heap {
            constructor(compare) {
                // originally: public compare: Comparator<T> = Heap.minComparator
                this.compare = compare || Heap.minComparator;
                this.HeapArray = [];
                this._limit = 0;

                // aliases
                this.offer     = this.add;
                this.element   = this.peek;
                this.poll      = this.pop;
                this.removeAll = this.clear;
            }

            // static getChildrenIndexOf(idx: number): number[] { … }
            static getChildrenIndexOf(idx) {
                return [idx * 2 + 1, idx * 2 + 2];
            }

            // static getParentIndexOf(idx: number): number { … }
            static getParentIndexOf(idx) {
                if (idx <= 0) return -1;
                const whichChildren = idx % 2 ? 1 : 2;
                return Math.floor((idx - whichChildren) / 2);
            }

            // static getSiblingIndexOf(idx: number): number { … }
            static getSiblingIndexOf(idx) {
                if (idx <= 0) return -1;
                const whichChildren = idx % 2 ? 1 : -1;
                return idx + whichChildren;
            }

            // static minComparator<N>(a: N, b: N): number { … }
            static minComparator(a, b) {
                if (a > b) return 1;
                else if (a < b) return -1;
                else return 0;
            }

            // static maxComparator<N>(a: N, b: N): number { … }
            static maxComparator(a, b) {
                if (b > a) return 1;
                else if (b < a) return -1;
                else return 0;
            }

            // static minComparatorNumber(a: number, b: number): number { return a - b; }
            static minComparatorNumber(a, b) {
                return a - b;
            }

            // static maxComparatorNumber(a: number, b: number): number { return b - a; }
            static maxComparatorNumber(a, b) {
                return b - a;
            }

            // static defaultIsEqual<N>(a: N, b: N): boolean { return a === b; }
            static defaultIsEqual(a, b) {
                return a === b;
            }
            // print Heap
            static print(heap) {
                function deep(i) {
                    const pi = Heap.getParentIndexOf(i);
                    return Math.floor(Math.log2(pi + 1));
                }

                function repeat(str, times) {
                    let out = '';
                    while (times-- > 0) {
                        out += str;
                    }
                    return out;
                }

                let node = 0;
                const lines = [];
                const maxLines = deep(heap.length - 1) + 2;
                let maxLength = 0;

                while (node < heap.length) {
                    let level = deep(node) + 1;
                    if (node === 0) level = 0;
                    const text = String(heap.get(node));
                    maxLength = Math.max(maxLength, text.length);

                    lines[level] = lines[level] || [];
                    lines[level].push(text);
                    node++;
                }

                return lines
                    .map((line, i) => {
                    const spaces = Math.pow(2, maxLines - i) - 1;
                    const pad = Math.floor(spaces / 2) * maxLength;

                    const row = repeat(' ', pad) +
                          line
                    .map(el => {
                        const half = (maxLength - el.length) / 2;
                        return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));
                    })
                    .join(repeat(' ', spaces * maxLength));

                    return row;
                })
                    .join('\n');
            }

            // Convert an array into a heap instance
            static heapify(arr, compare) {
                const heap = new Heap(compare);
                heap.heapArray = arr;
                heap.init();
                return heap;
            }

            // Pop the root element from a raw array‑heap
            static heappop(heapArr, compare) {
                const heap = new Heap(compare);
                heap.heapArray = heapArr;
                return heap.pop();
            }

            // Push a single item into a raw array‑heap
            static heappush(heapArr, item, compare) {
                const heap = new Heap(compare);
                heap.heapArray = heapArr;
                heap.push(item);
            }
            // Push then pop in one go (faster)
            static heappushpop(heapArr, item, compare) {
                const heap = new Heap(compare);
                heap.heapArray = heapArr;
                return heap.pushpop(item);
            }

            // Replace the root element
            static heapreplace(heapArr, item, compare) {
                const heap = new Heap(compare);
                heap.heapArray = heapArr;
                return heap.replace(item);
            }

            // Return the top n elements from an array‑heap
            static heaptop(heapArr, n, compare) {
                n = n === undefined ? 1 : n;
                const heap = new Heap(compare);
                heap.heapArray = heapArr;
                return heap.top(n);
            }

            // Return the bottom n elements from an array‑heap
            static heapbottom(heapArr, n, compare) {
                n = n === undefined ? 1 : n;
                const heap = new Heap(compare);
                heap.heapArray = heapArr;
                return heap.bottom(n);
            }

            // Return the n largest from any iterable
            static nlargest(n, iterable, compare) {
                const heap = new Heap(compare);
                heap.heapArray = Array.from(iterable);
                heap.init();
                return heap.top(n);
            }

            // Return the n smallest from any iterable
            static nsmallest(n, iterable, compare) {
                const heap = new Heap(compare);
                heap.heapArray = Array.from(iterable);
                heap.init();
                return heap.bottom(n);
            }

            // Adds an element to the heap. Alias: offer
            add(element) {
                this._sortNodeUp(this.HeapArray.push(element) - 1);
                this._applyLimit();
                return true;
            }

            // Adds an array of elements to the heap
            addAll(elements) {
                let i = this.length;
                this.HeapArray.push(...elements);
                for (const l = this.length; i < l; ++i) {
                    this._sortNodeUp(i);
                }
                this._applyLimit();
                return true;
            }

            // Return the bottom (lowest value) N elements of the heap
            bottom(n = 1) {
                if (this.HeapArray.length === 0 || n <= 0) {
                    return [];
                } else if (this.HeapArray.length === 1) {
                    return [ this.HeapArray[0] ];
                } else if (n >= this.HeapArray.length) {
                    return [ ...this.HeapArray ];
                } else {
                    return this._bottomN_push(~~n);
                }
            }

            // Check if the heap is sorted; returns a bad element or undefined
            check() {
                return this.HeapArray.find((el, j) =>
                                           !!this.getChildrenOf(j).find(ch => this.compare(el, ch) > 0)
                                          );
            }

            // Remove all elements from this heap
            clear() {
                this.HeapArray = [];
            }

            // Clone this heap
            clone() {
                const cloned = new Heap(this.comparator());
                cloned.heapArray = this.toArray();
                cloned._limit    = this._limit;
                return cloned;
            }

            // Returns the comparison function
            comparator() {
                return this.compare;
            }

            // Returns true if heap contains `o` (using defaultIsEqual if no fn passed)
            contains(o, callbackFn = Heap.defaultIsEqual) {
                return this.indexOf(o, callbackFn) !== -1;
            }
            // …and so on for ALL other static methods (print, heapify, heappop, etc.)…

            // Instance methods also drop type annotations:
            // add(element: T): boolean { … }  →  add(element) { … }
            add(element) {
                this._sortNodeUp(this.HeapArray.push(element) - 1);
                this._applyLimit();
                return true;
            }

            // addAll(elements: T[]): boolean { … } → addAll(elements) { … }
            addAll(elements) {
                let i = this.length;
                this.HeapArray.push(...elements);
                for (const l = this.length; i < l; ++i) {
                    this._sortNodeUp(i);
                }
                this._applyLimit();
                return true;
            }

            // bottom(n = 1): T[] { … } → bottom(n) { n = n || 1; … }
            bottom(n) {
                n = n === undefined ? 1 : n;
                /* original body un‑changed */
            }

            // Initialize a heap, sorting nodes
            init(array) {
                if (array) {
                    this.HeapArray = Array.isArray(array) ? array.slice() : [];
                }
                for (let i = Math.floor(this.HeapArray.length); i >= 0; --i) {
                    this._sortNodeDown(i);
                }
                this._applyLimit();
            }

            // Test if the heap has no elements
            isEmpty() {
                return this.length === 0;
            }
            empty() {
                return this.length === 0;
            }

            // Get index of first occurrence (or -1)
            indexOf(element, callbackFn) {
                callbackFn = callbackFn || Heap.defaultIsEqual;
                if (this.HeapArray.length === 0) return -1;

                const queue = [];
                let currentIndex = 0;

                while (currentIndex < this.HeapArray.length) {
                    const current = this.HeapArray[currentIndex];
                    if (callbackFn(current, element)) {
                        return currentIndex;
                    } else if (this.compare(current, element) <= 0) {
                        queue.push(...Heap.getChildrenIndexOf(currentIndex));
                    }
                    currentIndex = queue.shift() ?? this.HeapArray.length;
                }
                return -1;
            }

            // Get indexes of every occurrence
            indexOfEvery(element, callbackFn) {
                callbackFn = callbackFn || Heap.defaultIsEqual;
                if (this.HeapArray.length === 0) return [];

                const queue = [];
                const found = [];
                let currentIndex = 0;

                while (currentIndex < this.HeapArray.length) {
                    const current = this.HeapArray[currentIndex];
                    if (callbackFn(current, element)) {
                        found.push(currentIndex);
                        queue.push(...Heap.getChildrenIndexOf(currentIndex));
                    } else if (this.compare(current, element) <= 0) {
                        queue.push(...Heap.getChildrenIndexOf(currentIndex));
                    }
                    currentIndex = queue.shift() ?? this.HeapArray.length;
                }
                return found;
            }

            // Get the leaf nodes (no children)
            leafs() {
                if (this.HeapArray.length === 0) return [];
                const pi = Heap.getParentIndexOf(this.HeapArray.length - 1);
                return this.HeapArray.slice(pi + 1);
            }

            // Length alias
            get length() {
                return this.HeapArray.length;
            }

            // Limit getter/setter
            get limit() {
                return this._limit;
            }
            set limit(_l) {
                if (_l < 0 || isNaN(_l)) {
                    this._limit = 0;
                } else {
                    this._limit = ~~_l;
                }
                this._applyLimit();
            }

            // Set limit method
            setLimit(_l) {
                this.limit = _l;
                return (_l < 0 || isNaN(_l)) ? NaN : this._limit;
            }

            // Peek at the top element
            peek() {
                return this.HeapArray[0];
            }
            // Extract the top node (root). Alias: poll
            pop() {
                const last = this.HeapArray.pop();
                if (this.length > 0 && last !== undefined) {
                    return this.replace(last);
                }
                return last;
            }

            // Push element(s) to the heap. Alias: add/addAll
            push(...elements) {
                if (elements.length < 1) {
                    return false;
                } else if (elements.length === 1) {
                    return this.add(elements[0]);
                } else {
                    return this.addAll(elements);
                }
            }

            // Push then pop in one go, faster
            pushpop(element) {
                if (this.compare(this.HeapArray[0], element) < 0) {
                    [element, this.HeapArray[0]] = [this.HeapArray[0], element];
                    this._sortNodeDown(0);
                }
                return element;
            }

            // Remove first occurrence of o (or pop if o is undefined)
            remove(o, callbackFn) {
                callbackFn = callbackFn || Heap.defaultIsEqual;
                if (!this.HeapArray.length) return false;
                if (o === undefined) {
                    this.pop();
                    return true;
                }
                const queue = [0];
                while (queue.length) {
                    const idx = queue.shift();
                    if (callbackFn(this.HeapArray[idx], o)) {
                        if (idx === 0) {
                            this.pop();
                        } else if (idx === this.HeapArray.length - 1) {
                            this.HeapArray.pop();
                        } else {
                            this.HeapArray.splice(idx, 1, this.HeapArray.pop());
                            this._sortNodeUp(idx);
                            this._sortNodeDown(idx);
                        }
                        return true;
                    } else if (this.compare(this.HeapArray[idx], o) <= 0) {
                        queue.push(...Heap.getChildrenIndexOf(idx).filter(c => c < this.HeapArray.length));
                    }
                }
                return false;
            }

            // Replace root with element, return old root
            replace(element) {
                const peek = this.HeapArray[0];
                this.HeapArray[0] = element;
                this._sortNodeDown(0);
                return peek;
            }

            // Size alias
            size() {
                return this.length;
            }

            // Return top n elements
            top(n = 1) {
                if (this.HeapArray.length === 0 || n <= 0) {
                    return [];
                } else if (this.HeapArray.length === 1 || n === 1) {
                    return [ this.HeapArray[0] ];
                } else if (n >= this.HeapArray.length) {
                    return [ ...this.HeapArray ];
                }
                return this._topN_push(~~n);
            }

            // Get internal array copy
            toArray() {
                return [ ...this.HeapArray ];
            }

            // Stringify
            toString() {
                return this.HeapArray.toString();
            }

            // Direct index access
            get(i) {
                return this.HeapArray[i];
            }

            // Get children values
            getChildrenOf(idx) {
                return Heap.getChildrenIndexOf(idx)
                    .map(i => this.HeapArray[i])
                    .filter(e => e !== undefined);
            }

            // Get parent value
            getParentOf(idx) {
                const pi = Heap.getParentIndexOf(idx);
                return this.HeapArray[pi];
            }

            // Make it iterable: pops until empty
            *[Symbol.iterator]() {
                while (this.length) {
                    yield this.pop();
                }
            }

            // Java‑style iterator()
            iterator() {
                return this.toArray();
            }

            // Enforce limit by popping extras
            _applyLimit() {
                if (this._limit > 0 && this._limit < this.HeapArray.length) {
                    let rm = this.HeapArray.length - this._limit;
                    while (rm-- > 0) {
                        this.HeapArray.pop();
                    }
                }
            }
            // Return the bottom N elements without corner cases
            _bottomN_push(n) {
                n = ~~n;
                const bottomHeap = new Heap(this.compare);
                bottomHeap.limit = n;
                bottomHeap.heapArray = this.HeapArray.slice(-n);
                bottomHeap.init();
                const startAt = this.HeapArray.length - 1 - n;
                const parentStartAt = Heap.getParentIndexOf(startAt);
                const indices = [];
                for (let i = startAt; i > parentStartAt; --i) {
                    indices.push(i);
                }
                const arr = this.HeapArray;
                while (indices.length) {
                    const i = indices.shift();
                    if (this.compare(arr[i], bottomHeap.peek()) > 0) {
                        bottomHeap.replace(arr[i]);
                        if (i % 2) {
                            indices.push(Heap.getParentIndexOf(i));
                        }
                    }
                }
                return bottomHeap.toArray();
            }

            // Inverted comparator for topN/fill
            _invertedCompare(a, b) {
                return -1 * this.compare(a, b);
            }

            // Swap two nodes
            _moveNode(j, k) {
                [this.HeapArray[j], this.HeapArray[k]] = [this.HeapArray[k], this.HeapArray[j]];
            }

            // Push node down until heap order is restored
            _sortNodeDown(i) {
                const length = this.HeapArray.length;
                while (true) {
                    const left  = 2 * i + 1;
                    const right = left + 1;
                    let best = i;
                    if (left < length && this.compare(this.HeapArray[left], this.HeapArray[best]) < 0) {
                        best = left;
                    }
                    if (right < length && this.compare(this.HeapArray[right], this.HeapArray[best]) < 0) {
                        best = right;
                    }
                    if (best === i) break;
                    this._moveNode(i, best);
                    i = best;
                }
            }

            // Bubble node up until heap order is restored
            _sortNodeUp(i) {
                while (i > 0) {
                    const pi = Heap.getParentIndexOf(i);
                    if (this.compare(this.HeapArray[i], this.HeapArray[pi]) < 0) {
                        this._moveNode(i, pi);
                        i = pi;
                    } else break;
                }
            }

            // Return top N by pushing into inverted heap
            _topN_push(n) {
                n = ~~n;
                const topHeap = new Heap(this._invertedCompare);
                topHeap.limit = n;
                const indices = [0];
                const arr = this.HeapArray;
                while (indices.length) {
                    const i = indices.shift();
                    if (i < arr.length) {
                        if (topHeap.length < n) {
                            topHeap.push(arr[i]);
                            indices.push(...Heap.getChildrenIndexOf(i));
                        } else if (this.compare(arr[i], topHeap.peek()) < 0) {
                            topHeap.replace(arr[i]);
                            indices.push(...Heap.getChildrenIndexOf(i));
                        }
                    }
                }
                return topHeap.toArray();
            }

            // Return top N by filling and pushing
            _topN_fill(n) {
                n = ~~n;
                const heapArray = this.HeapArray;
                const topHeap = new Heap(this._invertedCompare);
                topHeap.limit = n;
                topHeap.heapArray = heapArray.slice(0, n);
                topHeap.init();
                const branch = Heap.getParentIndexOf(n - 1) + 1;
                let indices = [];
                for (let i = branch; i < n; ++i) {
                    indices.push(...Heap.getChildrenIndexOf(i).filter(l => l < heapArray.length));
                }
                if ((n - 1) % 2) indices.push(n);
                while (indices.length) {
                    const i = indices.shift();
                    if (i < heapArray.length && this.compare(heapArray[i], topHeap.peek()) < 0) {
                        topHeap.replace(heapArray[i]);
                        indices.push(...Heap.getChildrenIndexOf(i));
                    }
                }
                return topHeap.toArray();
            }

            // Return top N by repeatedly popping clone
            _topN_heap(n) {
                n = ~~n;
                const topHeap = this.clone();
                const result = [];
                for (let i = 0; i < n; ++i) {
                    result.push(topHeap.pop());
                }
                return result;
            }

            // Return index of top element in list
            _topIdxOf(list) {
                if (!list.length) return -1;
                let idx = 0, top = list[0];
                for (let i = 1; i < list.length; ++i) {
                    const comp = this.compare(list[i], top);
                    if (comp < 0) {
                        idx = i;
                        top = list[i];
                    }
                }
                return idx;
            }

            // Return the top element from an array of values
            _topOf(...list) {
                const heap = new Heap(this.compare);
                heap.init(list);
                return heap.peek();
            }
        }

        // expose to global
        return Heap
    })()
    const Node_=function(exports={}){
        /**
 * A node in grid.
 * This class holds some basic information about a node and custom
 * attributes may be added, depending on the algorithms' needs.
 * @constructor
 * @param {number} x - The x coordinate of the node on the grid.
 * @param {number} y - The y coordinate of the node on the grid.
 * @param {boolean} [walkable] - Whether this node is walkable.
 */
        function Node(x, y, walkable) {
            /**
     * The x coordinate of the node on the grid.
     * @type number
     */
            this.x = x;
            /**
     * The y coordinate of the node on the grid.
     * @type number
     */
            this.y = y;
            /**
     * Whether this node can be walked through.
     * @type boolean
     */
            this.walkable = (walkable === undefined ? true : walkable);
        }

        return Node;
    }()
    const Grid_=function(exports={}){
        var Node = Node_;
        var DiagonalMovement = DiagonalMovement_;

        /**
 * The Grid class, which serves as the encapsulation of the layout of the nodes.
 * @constructor
 * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix
 * @param {number} height Number of rows of the grid.
 * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix
 *     representing the walkable status of the nodes(0 or false for walkable).
 *     If the matrix is not supplied, all the nodes will be walkable.  */
        function Grid(width_or_matrix, height, matrix) {
            var width;

            if (typeof width_or_matrix !== 'object') {
                width = width_or_matrix;
            } else {
                height = width_or_matrix.length;
                width = width_or_matrix[0].length;
                matrix = width_or_matrix;
            }

            /**
     * The number of columns of the grid.
     * @type number
     */
            this.width = width;
            /**
     * The number of rows of the grid.
     * @type number
     */
            this.height = height;

            /**
     * A 2D array of nodes.
     */
            this.nodes = this._buildNodes(width, height, matrix);
        }

        /**
 * Build and return the nodes.
 * @private
 * @param {number} width
 * @param {number} height
 * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing
 *     the walkable status of the nodes.
 * @see Grid
 */
        Grid.prototype._buildNodes = function(width, height, matrix) {
            var i, j,
                nodes = new Array(height);

            for (i = 0; i < height; ++i) {
                nodes[i] = new Array(width);
                for (j = 0; j < width; ++j) {
                    nodes[i][j] = new Node(j, i);
                }
            }


            if (matrix === undefined) {
                return nodes;
            }

            if (matrix.length !== height || matrix[0].length !== width) {
                throw new Error('Matrix size does not fit');
            }

            for (i = 0; i < height; ++i) {
                for (j = 0; j < width; ++j) {
                    if (matrix[i][j]) {
                        // 0, false, null will be walkable
                        // while others will be un-walkable
                        nodes[i][j].walkable = false;
                    }
                }
            }

            return nodes;
        };


        Grid.prototype.getNodeAt = function(x, y) {
            return this.nodes[y][x];
        };


        /**
 * Determine whether the node at the given position is walkable.
 * (Also returns false if the position is outside the grid.)
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @return {boolean} - The walkability of the node.
 */
        Grid.prototype.isWalkableAt = function(x, y) {
            return this.isInside(x, y) && this.nodes[y][x].walkable;
        };


        /**
 * Determine whether the position is inside the grid.
 * XXX: `grid.isInside(x, y)` is wierd to read.
 * It should be `(x, y) is inside grid`, but I failed to find a better
 * name for this method.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
        Grid.prototype.isInside = function(x, y) {
            return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
        };


        /**
 * Set whether the node on the given position is walkable.
 * NOTE: throws exception if the coordinate is not inside the grid.
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @param {boolean} walkable - Whether the position is walkable.
 */
        Grid.prototype.setWalkableAt = function(x, y, walkable) {
            this.nodes[y][x].walkable = walkable;
        };


        /**
 * Get the neighbors of the given node.
 *
 *     offsets      diagonalOffsets:
 *  +---+---+---+    +---+---+---+
 *  |   | 0 |   |    | 0 |   | 1 |
 *  +---+---+---+    +---+---+---+
 *  | 3 |   | 1 |    |   |   |   |
 *  +---+---+---+    +---+---+---+
 *  |   | 2 |   |    | 3 |   | 2 |
 *  +---+---+---+    +---+---+---+
 *
 *  When allowDiagonal is true, if offsets[i] is valid, then
 *  diagonalOffsets[i] and
 *  diagonalOffsets[(i + 1) % 4] is valid.
 * @param {Node} node
 * @param {DiagonalMovement} diagonalMovement
 */
        Grid.prototype.getNeighbors = function(node, diagonalMovement) {
            var x = node.x,
                y = node.y,
                neighbors = [],
                s0 = false, d0 = false,
                s1 = false, d1 = false,
                s2 = false, d2 = false,
                s3 = false, d3 = false,
                nodes = this.nodes;

            // ↑
            if (this.isWalkableAt(x, y - 1)) {
                neighbors.push(nodes[y - 1][x]);
                s0 = true;
            }
            // →
            if (this.isWalkableAt(x + 1, y)) {
                neighbors.push(nodes[y][x + 1]);
                s1 = true;
            }
            // ↓
            if (this.isWalkableAt(x, y + 1)) {
                neighbors.push(nodes[y + 1][x]);
                s2 = true;
            }
            // ←
            if (this.isWalkableAt(x - 1, y)) {
                neighbors.push(nodes[y][x - 1]);
                s3 = true;
            }

            if (diagonalMovement === DiagonalMovement.Never) {
                return neighbors;
            }

            if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
                d0 = s3 && s0;
                d1 = s0 && s1;
                d2 = s1 && s2;
                d3 = s2 && s3;
            } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {
                d0 = s3 || s0;
                d1 = s0 || s1;
                d2 = s1 || s2;
                d3 = s2 || s3;
            } else if (diagonalMovement === DiagonalMovement.Always) {
                d0 = true;
                d1 = true;
                d2 = true;
                d3 = true;
            } else {
                throw new Error('Incorrect value of diagonalMovement');
            }

            // ↖
            if (d0 && this.isWalkableAt(x - 1, y - 1)) {
                neighbors.push(nodes[y - 1][x - 1]);
            }
            // ↗
            if (d1 && this.isWalkableAt(x + 1, y - 1)) {
                neighbors.push(nodes[y - 1][x + 1]);
            }
            // ↘
            if (d2 && this.isWalkableAt(x + 1, y + 1)) {
                neighbors.push(nodes[y + 1][x + 1]);
            }
            // ↙
            if (d3 && this.isWalkableAt(x - 1, y + 1)) {
                neighbors.push(nodes[y + 1][x - 1]);
            }

            return neighbors;
        };


        /**
 * Get a clone of this grid.
 * @return {Grid} Cloned grid.
 */
        Grid.prototype.clone = function() {
            var i, j,

                width = this.width,
                height = this.height,
                thisNodes = this.nodes,

                newGrid = new Grid(width, height),
                newNodes = new Array(height);

            for (i = 0; i < height; ++i) {
                newNodes[i] = new Array(width);
                for (j = 0; j < width; ++j) {
                    newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
                }
            }

            newGrid.nodes = newNodes;

            return newGrid;
        };

        exports = Grid;
        return exports
    }()
    const Util_=function(exports={}){
        /**
 * Backtrace according to the parent records and return the path.
 * (including both start and end nodes)
 * @param {Node} node End node
 * @return {Array<Array<number>>} the path
 */
        function backtrace(node) {
            var path = [[node.x, node.y]];
            while (node.parent) {
                node = node.parent;
                path.push([node.x, node.y]);
            }
            return path.reverse();
        }

        /**
 * Backtrace from start and end node, and return the path.
 * (including both start and end nodes)
 * @param {Node}
 * @param {Node}
 */
        function biBacktrace(nodeA, nodeB) {
            var pathA = backtrace(nodeA),
                pathB = backtrace(nodeB);
            return pathA.concat(pathB.reverse());
        }

        /**
 * Compute the length of the path.
 * @param {Array<Array<number>>} path The path
 * @return {number} The length of the path
 */
        function pathLength(path) {
            var i, sum = 0, a, b, dx, dy;
            for (i = 1; i < path.length; ++i) {
                a = path[i - 1];
                b = path[i];
                dx = a[0] - b[0];
                dy = a[1] - b[1];
                sum += Math.sqrt(dx * dx + dy * dy);
            }
            return sum;
        }

        /**
 * Given the start and end coordinates, return all the coordinates lying
 * on the line formed by these coordinates, based on Bresenham's algorithm.
 * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
 * @param {number} x0 Start x coordinate
 * @param {number} y0 Start y coordinate
 * @param {number} x1 End x coordinate
 * @param {number} y1 End y coordinate
 * @return {Array<Array<number>>} The coordinates on the line
 */
        function interpolate(x0, y0, x1, y1) {
            var abs = Math.abs,
                line = [],
                sx, sy, dx, dy, err, e2;

            dx = abs(x1 - x0);
            dy = abs(y1 - y0);

            sx = (x0 < x1) ? 1 : -1;
            sy = (y0 < y1) ? 1 : -1;

            err = dx - dy;

            while (true) {
                line.push([x0, y0]);

                if (x0 === x1 && y0 === y1) {
                    break;
                }

                e2 = 2 * err;
                if (e2 > -dy) {
                    err = err - dy;
                    x0 = x0 + sx;
                }
                if (e2 < dx) {
                    err = err + dx;
                    y0 = y0 + sy;
                }
            }

            return line;
        }

        /**
 * Given a compressed path, return a new path that has all the segments
 * in it interpolated.
 * @param {Array<Array<number>>} path The path
 * @return {Array<Array<number>>} expanded path
 */
        function expandPath(path) {
            var expanded = [],
                len = path.length,
                coord0, coord1,
                interpolated,
                interpolatedLen,
                i, j;

            if (len < 2) {
                return expanded;
            }

            for (i = 0; i < len - 1; ++i) {
                coord0 = path[i];
                coord1 = path[i + 1];

                interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
                interpolatedLen = interpolated.length;
                for (j = 0; j < interpolatedLen - 1; ++j) {
                    expanded.push(interpolated[j]);
                }
            }
            expanded.push(path[len - 1]);

            return expanded;
        }

        /**
 * Smoothen the give path.
 * The original path will not be modified; a new path will be returned.
 * @param {PF.Grid} grid
 * @param {Array<Array<number>>} path The path
 */
        function smoothenPath(grid, path) {
            var len = path.length,
                x0 = path[0][0],        // path start x
                y0 = path[0][1],        // path start y
                x1 = path[len - 1][0],  // path end x
                y1 = path[len - 1][1],  // path end y
                sx, sy,                 // current start coordinate
                ex, ey,                 // current end coordinate
                newPath,
                i, j, coord, line, testCoord, blocked;

            sx = x0;
            sy = y0;
            newPath = [[sx, sy]];

            for (i = 2; i < len; ++i) {
                coord = path[i];
                ex = coord[0];
                ey = coord[1];
                line = interpolate(sx, sy, ex, ey);

                blocked = false;
                for (j = 1; j < line.length; ++j) {
                    testCoord = line[j];

                    if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                        blocked = true;
                        break;
                    }
                }
                if (blocked) {
                    lastValidCoord = path[i - 1];
                    newPath.push(lastValidCoord);
                    sx = lastValidCoord[0];
                    sy = lastValidCoord[1];
                }
            }
            newPath.push([x1, y1]);

            return newPath;
        }

        /**
 * Compress a path, remove redundant nodes without altering the shape
 * The original path is not modified
 * @param {Array<Array<number>>} path The path
 * @return {Array<Array<number>>} The compressed path
 */
        function compressPath(path) {

            // nothing to compress
            if(path.length < 3) {
                return path;
            }

            var compressed = [],
                sx = path[0][0], // start x
                sy = path[0][1], // start y
                px = path[1][0], // second point x
                py = path[1][1], // second point y
                dx = px - sx, // direction between the two points
                dy = py - sy, // direction between the two points
                lx, ly,
                ldx, ldy,
                sq, i;

            // normalize the direction
            sq = Math.sqrt(dx*dx + dy*dy);
            dx /= sq;
            dy /= sq;

            // start the new path
            compressed.push([sx,sy]);

            for(i = 2; i < path.length; i++) {

                // store the last point
                lx = px;
                ly = py;

                // store the last direction
                ldx = dx;
                ldy = dy;

                // next point
                px = path[i][0];
                py = path[i][1];

                // next direction
                dx = px - lx;
                dy = py - ly;

                // normalize
                sq = Math.sqrt(dx*dx + dy*dy);
                dx /= sq;
                dy /= sq;

                // if the direction has changed, store the point
                if ( dx !== ldx || dy !== ldy ) {
                    compressed.push([lx,ly]);
                }
            }

            // store the last point
            compressed.push([px,py]);

            return compressed;
        }
        exports.smoothenPath = smoothenPath;
        exports.expandPath = expandPath;
        exports.interpolate = interpolate;
        exports.pathLength = pathLength;
        exports.backtrace = backtrace;
        exports.biBacktrace = biBacktrace;
        exports.compressPath = compressPath;
        return exports
    }()
    const AStarFinder_=function(exports={}){
        var Heap       = Heap_
        var Util       = Util_
        var Heuristic  = Heuristic_
        var DiagonalMovement = DiagonalMovement_;

        /**
 * A* path-finder. Based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 */
        function AStarFinder(opt) {
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.Heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;
            this.DiagonalMovement = opt.diagonalMovement;

            if (!this.DiagonalMovement) {
                if (!this.allowDiagonal) {
                    this.DiagonalMovement = DiagonalMovement.Never;
                } else {
                    if (this.dontCrossCorners) {
                        this.DiagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    } else {
                        this.DiagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }

            // When diagonal movement is allowed the manhattan heuristic is not
            //admissible. It should be octile instead
            if (this.DiagonalMovement === DiagonalMovement.Never) {
                this.Heuristic = opt.heuristic || Heuristic.manhattan;
            } else {
                this.Heuristic = opt.heuristic || Heuristic.octile;
            }
        }

        /**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
        AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
            var openList = new Heap(function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }),
                startNode = grid.getNodeAt(startX, startY),
                endNode = grid.getNodeAt(endX, endY),
                heuristic = this.Heuristic,
                diagonalMovement = this.DiagonalMovement,
                weight = this.weight,
                abs = Math.abs, SQRT2 = Math.SQRT2,
                node, neighbors, neighbor, i, l, x, y, ng;

            // set the `g` and `f` value of the start node to be 0
            startNode.g = 0;
            startNode.f = 0;

            // push the start node into the open list
            openList.push(startNode);
            startNode.opened = true;

            // while the open list is not empty
            while (!openList.empty()) {
                // pop the position of node which has the minimum `f` value.
                node = openList.pop();
                node.closed = true;

                // if reached the end position, construct the path and return it
                if (node === endNode) {
                    return Util.backtrace(endNode);
                }

                // get neigbours of the current node
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];

                    if (neighbor.closed) {
                        continue;
                    }

                    x = neighbor.x;
                    y = neighbor.y;

                    // get the distance between current node and the neighbor
                    // and calculate the next g score
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

                    // check if the neighbor has not been inspected yet, or
                    // can be reached with smaller cost from the current node
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;

                        if (!neighbor.opened) {
                            openList.push(neighbor);
                            neighbor.opened = true;
                        } else {
                            // the neighbor can be reached with smaller cost.
                            // Since its f value has been updated, we have to
                            // update its position in the open list
                            openList.updateItem(neighbor);
                        }
                    }
                } // end for each neighbor
            } // end while not open list empty

            // fail to find the path
            return [];
        };

        return AStarFinder;
    }()
    const BestFirstFinder_ = function(exports={}){
        var AStarFinder = AStarFinder_;

        /**
 * Best-First-Search path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
        function BestFirstFinder(opt) {
            AStarFinder.call(this, opt);

            var orig = this.Heuristic;
            this.Heuristic = function(dx, dy) {
                return orig(dx, dy) * 1000000;
            };
        }

        BestFirstFinder.prototype = new AStarFinder();
        BestFirstFinder.prototype.constructor = BestFirstFinder;

        exports = BestFirstFinder;
        return exports
    }()
    const BreadthFirstFinder_=function(exports={}){
        var Util = Util_;
        var DiagonalMovement = DiagonalMovement_;

        /**
 * Breadth-First-Search path finder.
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
        function BreadthFirstFinder(opt) {
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.DiagonalMovement = opt.diagonalMovement;

            if (!this.DiagonalMovement) {
                if (!this.allowDiagonal) {
                    this.DiagonalMovement = DiagonalMovement.Never;
                } else {
                    if (this.dontCrossCorners) {
                        this.DiagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    } else {
                        this.DiagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
        }

        /**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
        BreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
            var openList = [],
                diagonalMovement = DiagonalMovement_,
                startNode = grid.getNodeAt(startX, startY),
                endNode = grid.getNodeAt(endX, endY),
                neighbors, neighbor, node, i, l;

            // push the start pos into the queue
            openList.push(startNode);
            startNode.opened = true;

            // while the queue is not empty
            while (openList.length) {
                // take the front node from the queue
                node = openList.shift();
                node.closed = true;

                // reached the end position
                if (node === endNode) {
                    return Util.backtrace(endNode);
                }

                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];

                    // skip this neighbor if it has been inspected before
                    if (neighbor.closed || neighbor.opened) {
                        continue;
                    }

                    openList.push(neighbor);
                    neighbor.opened = true;
                    neighbor.parent = node;
                }
            }

            // fail to find the path
            return [];
        };

        return BreadthFirstFinder;
    }()
    const DijkstraFinder_=function(exports={}){
        var AStarFinder = AStarFinder_;

        /**
 * Dijkstra path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
        function DijkstraFinder(opt) {
            AStarFinder.call(this, opt);
            this.Heuristic = function(dx, dy) {
                return 0;
            };
        }

        DijkstraFinder.prototype = new AStarFinder();
        DijkstraFinder.prototype.constructor = DijkstraFinder;

        return DijkstraFinder;
    }()
    const BiAStarFinder_=function(exports={}){
        var Heap = Heap_;
        var Util = Util_;
        var Heuristic = Heuristic_;
        var DiagonalMovement = DiagonalMovement_;


        /**
 * A* path-finder.
 * based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 */
        function BiAStarFinder(opt) {
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.DiagonalMovement = opt.diagonalMovement;
            this.Heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;

            if (!this.DiagonalMovement) {
                if (!this.allowDiagonal) {
                    this.DiagonalMovement = DiagonalMovement.Never;
                } else {
                    if (this.dontCrossCorners) {
                        this.DiagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    } else {
                        this.DiagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }

            //When diagonal movement is allowed the manhattan heuristic is not admissible
            //It should be octile instead
            if (this.DiagonalMovement === DiagonalMovement.Never) {
                this.Heuristic = opt.heuristic || Heuristic.manhattan;
            } else {
                this.Heuristic = opt.heuristic || Heuristic.octile;
            }
        }

        /**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
        BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
            var cmp = function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            },
                startOpenList = new Heap(cmp),
                endOpenList = new Heap(cmp),
                startNode = grid.getNodeAt(startX, startY),
                endNode = grid.getNodeAt(endX, endY),
                heuristic = this.Heuristic,
                diagonalMovement = this.DiagonalMovement,
                weight = this.weight,
                abs = Math.abs, SQRT2 = Math.SQRT2,
                node, neighbors, neighbor, i, l, x, y, ng,
                BY_START = 1, BY_END = 2;

            // set the `g` and `f` value of the start node to be 0
            // and push it into the start open list
            startNode.g = 0;
            startNode.f = 0;
            startOpenList.push(startNode);
            startNode.opened = BY_START;

            // set the `g` and `f` value of the end node to be 0
            // and push it into the open open list
            endNode.g = 0;
            endNode.f = 0;
            endOpenList.push(endNode);
            endNode.opened = BY_END;

            // while both the open lists are not empty
            while (!startOpenList.empty() && !endOpenList.empty()) {

                // pop the position of start node which has the minimum `f` value.
                node = startOpenList.pop();
                node.closed = true;

                // get neigbours of the current node
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];

                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened === BY_END) {
                        return Util.biBacktrace(node, neighbor);
                    }

                    x = neighbor.x;
                    y = neighbor.y;

                    // get the distance between current node and the neighbor
                    // and calculate the next g score
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

                    // check if the neighbor has not been inspected yet, or
                    // can be reached with smaller cost from the current node
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h ||
                            weight * heuristic(abs(x - endX), abs(y - endY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;

                        if (!neighbor.opened) {
                            startOpenList.push(neighbor);
                            neighbor.opened = BY_START;
                        } else {
                            // the neighbor can be reached with smaller cost.
                            // Since its f value has been updated, we have to
                            // update its position in the open list
                            startOpenList.updateItem(neighbor);
                        }
                    }
                } // end for each neighbor


                // pop the position of end node which has the minimum `f` value.
                node = endOpenList.pop();
                node.closed = true;

                // get neigbours of the current node
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];

                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened === BY_START) {
                        return Util.biBacktrace(neighbor, node);
                    }

                    x = neighbor.x;
                    y = neighbor.y;

                    // get the distance between current node and the neighbor
                    // and calculate the next g score
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

                    // check if the neighbor has not been inspected yet, or
                    // can be reached with smaller cost from the current node
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h ||
                            weight * heuristic(abs(x - startX), abs(y - startY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;

                        if (!neighbor.opened) {
                            endOpenList.push(neighbor);
                            neighbor.opened = BY_END;
                        } else {
                            // the neighbor can be reached with smaller cost.
                            // Since its f value has been updated, we have to
                            // update its position in the open list
                            endOpenList.updateItem(neighbor);
                        }
                    }
                } // end for each neighbor
            } // end while not open list empty

            // fail to find the path
            return [];
        };

        return BiAStarFinder;
    }()
    const BiBreadthFirstFinder_=function(exports={}){
        var Util = Util_;
        var DiagonalMovement = DiagonalMovement_;
        /**
 * Bi-directional Breadth-First-Search path finder.
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
        function BiBreadthFirstFinder(opt) {
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.DiagonalMovement = opt.diagonalMovement;

            if (!this.DiagonalMovement) {
                if (!this.allowDiagonal) {
                    this.DiagonalMovement = DiagonalMovement.Never;
                } else {
                    if (this.dontCrossCorners) {
                        this.DiagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    } else {
                        this.DiagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
        }


        /**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
        BiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
            var startNode = grid.getNodeAt(startX, startY),
                endNode = grid.getNodeAt(endX, endY),
                startOpenList = [], endOpenList = [],
                neighbors, neighbor, node,
                diagonalMovement = this.DiagonalMovement,
                BY_START = 0, BY_END = 1,
                i, l;

            // push the start and end nodes into the queues
            startOpenList.push(startNode);
            startNode.opened = true;
            startNode.by = BY_START;

            endOpenList.push(endNode);
            endNode.opened = true;
            endNode.by = BY_END;

            // while both the queues are not empty
            while (startOpenList.length && endOpenList.length) {

                // expand start open list

                node = startOpenList.shift();
                node.closed = true;

                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];

                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened) {
                        // if this node has been inspected by the reversed search,
                        // then a path is found.
                        if (neighbor.by === BY_END) {
                            return Util.biBacktrace(node, neighbor);
                        }
                        continue;
                    }
                    startOpenList.push(neighbor);
                    neighbor.parent = node;
                    neighbor.opened = true;
                    neighbor.by = BY_START;
                }

                // expand end open list

                node = endOpenList.shift();
                node.closed = true;

                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];

                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened) {
                        if (neighbor.by === BY_START) {
                            return Util.biBacktrace(neighbor, node);
                        }
                        continue;
                    }
                    endOpenList.push(neighbor);
                    neighbor.parent = node;
                    neighbor.opened = true;
                    neighbor.by = BY_END;
                }
            }

            // fail to find the path
            return [];
        };

        return BiBreadthFirstFinder;
    }()
    const BiDijkstraFinder_=function(exports={}){
        var BiAStarFinder = BiAStarFinder_;
        /**
 * Bi-directional Dijkstra path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
        function BiDijkstraFinder(opt) {
            BiAStarFinder.call(this, opt);
            this.Heuristic = function(dx, dy) {
                return 0;
            };
        }

        BiDijkstraFinder.prototype = new BiAStarFinder();
        BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;

        return BiDijkstraFinder;
    }()
    const IDAStarFinder_=function(exports={}){
        var Util = Util_;
        var Heuristic = Heuristic_;
        var Node = Node_;
        var DiagonalMovement = DiagonalMovement_;
        /**
 * Iterative Deeping A Star (IDA*) path-finder.
 *
 * Recursion based on:
 *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html
 *
 * Path retracing based on:
 *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh
 *  "A Parallel Implementation of Iterative-Deeping-A*", January 1987.
 *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf
 *
 * @author Gerard Meier (www.gerardmeier.com)
 *
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 * @param {boolean} opt.trackRecursion Whether to track recursion for
 *     statistical purposes.
 * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.
 */
        function IDAStarFinder(opt) {
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.DiagonalMovement = opt.diagonalMovement;
            this.Heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;
            this.trackRecursion = opt.trackRecursion || false;
            this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

            if (!this.DiagonalMovement) {
                if (!this.allowDiagonal) {
                    this.DiagonalMovement = DiagonalMovement.Never;
                } else {
                    if (this.dontCrossCorners) {
                        this.DiagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    } else {
                        this.DiagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }

            // When diagonal movement is allowed the manhattan heuristic is not
            // admissible, it should be octile instead
            if (this.DiagonalMovement === DiagonalMovement.Never) {
                this.Heuristic = opt.heuristic || Heuristic.manhattan;
            } else {
                this.Heuristic = opt.heuristic || Heuristic.octile;
            }
        }

        /**
 * Find and return the the path. When an empty array is returned, either
 * no path is possible, or the maximum execution time is reached.
 *
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
        IDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
            // Used for statistics:
            var nodesVisited = 0;

            // Execution time limitation:
            var startTime = new Date().getTime();

            // Heuristic helper:
            var h = function(a, b) {
                return this.Heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
            }.bind(this);

            // Step cost from a to b:
            var cost = function(a, b) {
                return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
            };

            /**
     * IDA* search implementation.
     *
     * @param {Node} The node currently expanding from.
     * @param {number} Cost to reach the given node.
     * @param {number} Maximum search depth (cut-off value).
     * @param {Array<Array<number>>} The found route.
     * @param {number} Recursion depth.
     *
     * @return {Object} either a number with the new optimal cut-off depth,
     * or a valid node instance, in which case a path was found.
     */
            var search = function(node, g, cutoff, route, depth) {
                nodesVisited++;

                // Enforce timelimit:
                if (this.timeLimit > 0 &&
                    new Date().getTime() - startTime > this.timeLimit * 1000) {
                    // Enforced as "path-not-found".
                    return Infinity;
                }

                var f = g + h(node, end) * this.weight;

                // We've searched too deep for this iteration.
                if (f > cutoff) {
                    return f;
                }

                if (node == end) {
                    route[depth] = [node.x, node.y];
                    return node;
                }

                var min, t, k, neighbour;

                var neighbours = grid.getNeighbors(node, DiagonalMovement_);

                // Sort the neighbours, gives nicer paths. But, this deviates
                // from the original algorithm - so I left it out.
                //neighbours.sort(function(a, b){
                //    return h(a, end) - h(b, end);
                //});


                /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment
                for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
                    /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment
                    if (this.trackRecursion) {
                        // Retain a copy for visualisation. Due to recursion, this
                        // node may be part of other paths too.
                        neighbour.retainCount = neighbour.retainCount + 1 || 1;

                        if(neighbour.tested !== true) {
                            neighbour.tested = true;
                        }
                    }

                    t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);

                    if (t instanceof Node) {
                        route[depth] = [node.x, node.y];

                        // For a typical A* linked list, this would work:
                        // neighbour.parent = node;
                        return t;
                    }

                    // Decrement count, then determine whether it's actually closed.
                    if (this.trackRecursion && (--neighbour.retainCount) === 0) {
                        neighbour.tested = false;
                    }

                    if (t < min) {
                        min = t;
                    }
                }

                return min;

            }.bind(this);

            // Node instance lookups:
            var start = grid.getNodeAt(startX, startY);
            var end   = grid.getNodeAt(endX, endY);

            // Initial search depth, given the typical heuristic contraints,
            // there should be no cheaper route possible.
            var cutOff = h(start, end);

            var j, route, t;

            // With an overflow protection.
            for (j = 0; true; ++j) {

                route = [];

                // Search till cut-off depth:
                t = search(start, 0, cutOff, route, 0);

                // Route not possible, or not found in time limit.
                if (t === Infinity) {
                    return [];
                }

                // If t is a node, it's also the end node. Route is now
                // populated with a valid path to the end node.
                if (t instanceof Node) {
                    return route;
                }

                // Try again, this time with a deeper cut-off. The t score
                // is the closest we got to the end node.
                cutOff = t;
            }

            // This _should_ never to be reached.
            return [];
        };

        return IDAStarFinder;
    }()
    const JumpPointFinderBase_=function(exports={}){
        /**
 * @author imor / https://github.com/imor
 */
        var Heap       = Heap_
        var Util       = Util_
        var Heuristic  = Heuristic_
        var DiagonalMovement = DiagonalMovement_

        /**
 * Base class for the Jump Point Search algorithm
 * @param {object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
        function JumpPointFinderBase(opt) {
            opt = opt || {};
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.trackJumpRecursion = opt.trackJumpRecursion || false;
        }

        /**
 * Find and return the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
        JumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {
            var openList = this.openList = new Heap(function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }),
                startNode = this.startNode = grid.getNodeAt(startX, startY),
                endNode = this.endNode = grid.getNodeAt(endX, endY), node;

            this.grid = grid;


            // set the `g` and `f` value of the start node to be 0
            startNode.g = 0;
            startNode.f = 0;

            // push the start node into the open list
            openList.push(startNode);
            startNode.opened = true;

            // while the open list is not empty
            while (!openList.empty()) {
                // pop the position of node which has the minimum `f` value.
                node = openList.pop();
                node.closed = true;

                if (node === endNode) {
                    return Util.expandPath(Util.backtrace(endNode));
                }

                this._identifySuccessors(node);
            }

            // fail to find the path
            return [];
        };

        /**
 * Identify successors for the given node. Runs a jump point search in the
 * direction of each available neighbor, adding any points found to the open
 * list.
 * @protected
 */
        JumpPointFinderBase.prototype._identifySuccessors = function(node) {
            var grid = this.grid,
                heuristic = this.heuristic,
                openList = this.openList,
                endX = this.endNode.x,
                endY = this.endNode.y,
                neighbors, neighbor,
                jumpPoint, i, l,
                x = node.x, y = node.y,
                jx, jy, dx, dy, d, ng, jumpNode,
                abs = Math.abs, max = Math.max;

            neighbors = this._findNeighbors(node);
            for(i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];
                jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
                if (jumpPoint) {

                    jx = jumpPoint[0];
                    jy = jumpPoint[1];
                    jumpNode = grid.getNodeAt(jx, jy);

                    if (jumpNode.closed) {
                        continue;
                    }

                    // include distance, as parent may not be immediately adjacent:
                    d = Heuristic.octile(abs(jx - x), abs(jy - y));
                    ng = node.g + d; // next `g` value

                    if (!jumpNode.opened || ng < jumpNode.g) {
                        jumpNode.g = ng;
                        jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                        jumpNode.f = jumpNode.g + jumpNode.h;
                        jumpNode.parent = node;

                        if (!jumpNode.opened) {
                            openList.push(jumpNode);
                            jumpNode.opened = true;
                        } else {
                            openList.updateItem(jumpNode);
                        }
                    }
                }
            }
        };
        return JumpPointFinderBase
    }()
    const JPFNeverMoveDiagonally_=function(exports={}){
        /**
 * @author imor / https://github.com/imor
 */
        var JumpPointFinderBase = JumpPointFinderBase_;
        var DiagonalMovement = DiagonalMovement_;
        /**
 * Path finder using the Jump Point Search algorithm allowing only horizontal
 * or vertical movements.
 */
        function JPFNeverMoveDiagonally(opt) {
            JumpPointFinderBase.call(this, opt);
        }

        JPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();
        JPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;

        /**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
        JPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {
            var grid = this.grid,
                dx = x - px, dy = y - py;

            if (!grid.isWalkableAt(x, y)) {
                return null;
            }

            if(this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }

            if (grid.getNodeAt(x, y) === this.endNode) {
                return [x, y];
            }

            if (dx !== 0) {
                if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
                    (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                    return [x, y];
                }
            }
            else if (dy !== 0) {
                if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
                    (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                    return [x, y];
                }
                //When moving vertically, must check for horizontal jump points
                if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                    return [x, y];
                }
            }
            else {
                throw new Error("Only horizontal and vertical movements are allowed");
            }

            return this._jump(x + dx, y + dy, x, y);
        };

        /**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
        JPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {
            var parent = node.parent,
                x = node.x, y = node.y,
                grid = this.grid,
                px, py, nx, ny, dx, dy,
                neighbors = [], neighborNodes, neighborNode, i, l;

            // directed pruning: can ignore most neighbors, unless forced.
            if (parent) {
                px = parent.x;
                py = parent.y;
                // get the normalized direction of travel
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);

                if (dx !== 0) {
                    if (grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x, y - 1]);
                    }
                    if (grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x, y + 1]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                }
                else if (dy !== 0) {
                    if (grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y]);
                    }
                    if (grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                }
            }
            // return all neighbors
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }

            return neighbors;
        };

        return JPFNeverMoveDiagonally;
    }()
    const JPFAlwaysMoveDiagonally_=function(exports={}){
        /**
 * @author imor / https://github.com/imor
 */
        var JumpPointFinderBase = JumpPointFinderBase_;
        var DiagonalMovement = DiagonalMovement_;
        /**
 * Path finder using the Jump Point Search algorithm which always moves
 * diagonally irrespective of the number of obstacles.
 */
        function JPFAlwaysMoveDiagonally(opt) {
            JumpPointFinderBase.call(this, opt);
        }

        JPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();
        JPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;

        /**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
        JPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {
            var grid = this.grid,
                dx = x - px, dy = y - py;

            if (!grid.isWalkableAt(x, y)) {
                return null;
            }

            if(this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }

            if (grid.getNodeAt(x, y) === this.endNode) {
                return [x, y];
            }

            // check for forced neighbors
            // along the diagonal
            if (dx !== 0 && dy !== 0) {
                if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
                    (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                    return [x, y];
                }
                // when moving diagonally, must check for vertical/horizontal jump points
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            // horizontally/vertically
            else {
                if( dx !== 0 ) { // moving along x
                    if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
                       (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                        return [x, y];
                    }
                }
                else {
                    if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
                       (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                        return [x, y];
                    }
                }
            }

            return this._jump(x + dx, y + dy, x, y);
        };

        /**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
        JPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {
            var parent = node.parent,
                x = node.x, y = node.y,
                grid = this.grid,
                px, py, nx, ny, dx, dy,
                neighbors = [], neighborNodes, neighborNode, i, l;

            // directed pruning: can ignore most neighbors, unless forced.
            if (parent) {
                px = parent.x;
                py = parent.y;
                // get the normalized direction of travel
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);

                // search diagonally
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x + dx, y + dy)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - dx, y)) {
                        neighbors.push([x - dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x, y - dy)) {
                        neighbors.push([x + dx, y - dy]);
                    }
                }
                // search horizontally/vertically
                else {
                    if(dx === 0) {
                        if (grid.isWalkableAt(x, y + dy)) {
                            neighbors.push([x, y + dy]);
                        }
                        if (!grid.isWalkableAt(x + 1, y)) {
                            neighbors.push([x + 1, y + dy]);
                        }
                        if (!grid.isWalkableAt(x - 1, y)) {
                            neighbors.push([x - 1, y + dy]);
                        }
                    }
                    else {
                        if (grid.isWalkableAt(x + dx, y)) {
                            neighbors.push([x + dx, y]);
                        }
                        if (!grid.isWalkableAt(x, y + 1)) {
                            neighbors.push([x + dx, y + 1]);
                        }
                        if (!grid.isWalkableAt(x, y - 1)) {
                            neighbors.push([x + dx, y - 1]);
                        }
                    }
                }
            }
            // return all neighbors
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }

            return neighbors;
        };

        return JPFAlwaysMoveDiagonally;
    }()
    const JPFMoveDiagonallyIfNoObstacles_=function(exports={}){
        /**
 * @author imor / https://github.com/imor
 */
        var JumpPointFinderBase = JumpPointFinderBase_;
        var DiagonalMovement = DiagonalMovement_;
        /**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there are no obstacles.
 */
        function JPFMoveDiagonallyIfNoObstacles(opt) {
            JumpPointFinderBase.call(this, opt);
        }

        JPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();
        JPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;

        /**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
        JPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {
            var grid = this.grid,
                dx = x - px, dy = y - py;

            if (!grid.isWalkableAt(x, y)) {
                return null;
            }

            if(this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }

            if (grid.getNodeAt(x, y) === this.endNode) {
                return [x, y];
            }

            // check for forced neighbors
            // along the diagonal
            if (dx !== 0 && dy !== 0) {
                // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
                // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                // return [x, y];
                // }
                // when moving diagonally, must check for vertical/horizontal jump points
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            // horizontally/vertically
            else {
                if (dx !== 0) {
                    if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
                        (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                        return [x, y];
                    }
                }
                else if (dy !== 0) {
                    if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
                        (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                        return [x, y];
                    }
                    // When moving vertically, must check for horizontal jump points
                    // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                    // return [x, y];
                    // }
                }
            }

            // moving diagonally, must make sure one of the vertical/horizontal
            // neighbors is open to allow the path
            if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
                return this._jump(x + dx, y + dy, x, y);
            } else {
                return null;
            }
        };

        /**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
        JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {
            var parent = node.parent,
                x = node.x, y = node.y,
                grid = this.grid,
                px, py, nx, ny, dx, dy,
                neighbors = [], neighborNodes, neighborNode, i, l;

            // directed pruning: can ignore most neighbors, unless forced.
            if (parent) {
                px = parent.x;
                py = parent.y;
                // get the normalized direction of travel
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);

                // search diagonally
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                }
                // search horizontally/vertically
                else {
                    var isNextWalkable;
                    if (dx !== 0) {
                        isNextWalkable = grid.isWalkableAt(x + dx, y);
                        var isTopWalkable = grid.isWalkableAt(x, y + 1);
                        var isBottomWalkable = grid.isWalkableAt(x, y - 1);

                        if (isNextWalkable) {
                            neighbors.push([x + dx, y]);
                            if (isTopWalkable) {
                                neighbors.push([x + dx, y + 1]);
                            }
                            if (isBottomWalkable) {
                                neighbors.push([x + dx, y - 1]);
                            }
                        }
                        if (isTopWalkable) {
                            neighbors.push([x, y + 1]);
                        }
                        if (isBottomWalkable) {
                            neighbors.push([x, y - 1]);
                        }
                    }
                    else if (dy !== 0) {
                        isNextWalkable = grid.isWalkableAt(x, y + dy);
                        var isRightWalkable = grid.isWalkableAt(x + 1, y);
                        var isLeftWalkable = grid.isWalkableAt(x - 1, y);

                        if (isNextWalkable) {
                            neighbors.push([x, y + dy]);
                            if (isRightWalkable) {
                                neighbors.push([x + 1, y + dy]);
                            }
                            if (isLeftWalkable) {
                                neighbors.push([x - 1, y + dy]);
                            }
                        }
                        if (isRightWalkable) {
                            neighbors.push([x + 1, y]);
                        }
                        if (isLeftWalkable) {
                            neighbors.push([x - 1, y]);
                        }
                    }
                }
            }
            // return all neighbors
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }

            return neighbors;
        };

        return JPFMoveDiagonallyIfNoObstacles;
    }()
    const JPFMoveDiagonallyIfAtMostOneObstacle_=function(exports={}){
        /**
 * @author imor / https://github.com/imor
 */
        var JumpPointFinderBase = JumpPointFinderBase_;
        var DiagonalMovement = DiagonalMovement_;
        /**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there is at most one obstacle.
 */
        function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
            JumpPointFinderBase.call(this, opt);
        }

        JPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();
        JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;

        /**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
        JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {
            var grid = this.grid,
                dx = x - px, dy = y - py;

            if (!grid.isWalkableAt(x, y)) {
                return null;
            }

            if(this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }

            if (grid.getNodeAt(x, y) === this.endNode) {
                return [x, y];
            }

            // check for forced neighbors
            // along the diagonal
            if (dx !== 0 && dy !== 0) {
                if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
                    (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                    return [x, y];
                }
                // when moving diagonally, must check for vertical/horizontal jump points
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            // horizontally/vertically
            else {
                if( dx !== 0 ) { // moving along x
                    if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
                       (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                        return [x, y];
                    }
                }
                else {
                    if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
                       (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                        return [x, y];
                    }
                }
            }

            // moving diagonally, must make sure one of the vertical/horizontal
            // neighbors is open to allow the path
            if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
                return this._jump(x + dx, y + dy, x, y);
            } else {
                return null;
            }
        };

        /**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
        JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {
            var parent = node.parent,
                x = node.x, y = node.y,
                grid = this.grid,
                px, py, nx, ny, dx, dy,
                neighbors = [], neighborNodes, neighborNode, i, l;

            // directed pruning: can ignore most neighbors, unless forced.
            if (parent) {
                px = parent.x;
                py = parent.y;
                // get the normalized direction of travel
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);

                // search diagonally
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x - dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y - dy]);
                    }
                }
                // search horizontally/vertically
                else {
                    if(dx === 0) {
                        if (grid.isWalkableAt(x, y + dy)) {
                            neighbors.push([x, y + dy]);
                            if (!grid.isWalkableAt(x + 1, y)) {
                                neighbors.push([x + 1, y + dy]);
                            }
                            if (!grid.isWalkableAt(x - 1, y)) {
                                neighbors.push([x - 1, y + dy]);
                            }
                        }
                    }
                    else {
                        if (grid.isWalkableAt(x + dx, y)) {
                            neighbors.push([x + dx, y]);
                            if (!grid.isWalkableAt(x, y + 1)) {
                                neighbors.push([x + dx, y + 1]);
                            }
                            if (!grid.isWalkableAt(x, y - 1)) {
                                neighbors.push([x + dx, y - 1]);
                            }
                        }
                    }
                }
            }
            // return all neighbors
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }

            return neighbors;
        };

        return JPFMoveDiagonallyIfAtMostOneObstacle;
    }()
    const JumpPointFinder_=function(exports={}){
        /**
 * @author aniero / https://github.com/aniero
 */
        var DiagonalMovement = DiagonalMovement_;
        var JPFNeverMoveDiagonally = JPFNeverMoveDiagonally_;
        var JPFAlwaysMoveDiagonally = JPFAlwaysMoveDiagonally_;
        var JPFMoveDiagonallyIfNoObstacles = JPFMoveDiagonallyIfNoObstacles_;
        var JPFMoveDiagonallyIfAtMostOneObstacle = JPFMoveDiagonallyIfAtMostOneObstacle_;
        /**
 * Path finder using the Jump Point Search algorithm
 * @param {Object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal
 *      movement will be allowed.
 */
        function JumpPointFinder(opt) {
            opt = opt || {};
            if (opt.diagonalMovement === DiagonalMovement.Never) {
                return new JPFNeverMoveDiagonally(opt);
            } else if (opt.diagonalMovement === DiagonalMovement.Always) {
                return new JPFAlwaysMoveDiagonally(opt);
            } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
                return new JPFMoveDiagonallyIfNoObstacles(opt);
            } else {
                return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
            }
        }

        return JumpPointFinder;
    }()
    const pathfinding_={
        Util:Util_,
        Grid:Grid_,
        Node:Node_,
        Heap:Heap_,
        Heuristic:Heuristic_,
        DiagonalMovement:DiagonalMovement_,
        JPFMoveDiagonallyIfAtMostOneObstacle:JPFMoveDiagonallyIfAtMostOneObstacle_,
        JPFMoveDiagonallyIfNoObstacles:JPFMoveDiagonallyIfNoObstacles_,
        JPFAlwaysMoveDiagonally:JPFAlwaysMoveDiagonally_,
        JPFNeverMoveDiagonally:JPFNeverMoveDiagonally_,
        JumpPointFinder:JumpPointFinder_,
        IDAStarFinder:IDAStarFinder_,
        BiDijkstraFinder:BiDijkstraFinder_,
        BiBreadthFirstFinder:BiBreadthFirstFinder_,
        BiAStarFinder:BiAStarFinder_,
        DijkstraFinder:DijkstraFinder_,
        BreadthFirstFinder:BreadthFirstFinder_,
        BestFirstFinder:BestFirstFinder_,
        AStarFinder:AStarFinder_,
        JumpPointFinderBase:JumpPointFinderBase_
    };
    return pathfinding_
}()

;(function() {
    const ImgProto = HTMLImageElement.prototype;
    const { set: origSrcSetter } = Object.getOwnPropertyDescriptor(ImgProto, 'src');

    Object.defineProperty(ImgProto, 'src', {
        set(url) {
            // if it’s already a blob or dataURL, just set it directly
            if (url.startsWith('blob:') || url.startsWith('data:')) {
                return origSrcSetter.call(this, url);
            }
            // otherwise fetch with GM then blob-ify
            GM_xmlhttpRequest({
                method: 'GET',
                url,
                responseType: 'blob',
                onload: res => {
                    const blobUrl = URL.createObjectURL(res.response);
                    origSrcSetter.call(this, blobUrl);
                },
                onerror: _ => {
                    // fallback to direct src if the request fails
                    origSrcSetter.call(this, url);
                }
            });
        }
    });
})();

let l=setInterval(()=>(document.getElementById('menuContainer')&&(ℳ(),clearInterval(l),menuContainer.style.display='none')),100)
function ℳ(){
    grindPole=true
    const _origGM_setValue    = GM_setValue;
    const _origGM_getValue    = GM_getValue;
    const _origGM_deleteValue = GM_deleteValue;
    NodeJS_set=GM_setValue;
    // 2) override GM_setValue
    function proxySetValue(key, value) {
        // call original so Tampermonkey storage still works
        _origGM_setValue(key, value);

        // also POST to your local Express server
        fetch('http://localhost:3000/set', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key, value }),
        }).catch(() => {
            // ignore if server’s down
        });
    }
    GM_setValue = proxySetValue;

    // 3) override GM_getValue
    NodeJS_set=GM_setValue;

    function proxyGetValue(key, defaultValue) {
        const val = _origGM_getValue(key, defaultValue);

        // let your local server know someone did a get
        fetch('http://localhost:3000/get', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key }),
        })
            .then(res => res.json())
            .then(data => {
            console.log('server get response:', data.value);
        })
            .catch(() => {});

        return val;
    }
    GM_getValue = proxyGetValue;

    // 4) override GM_deleteValue
    function proxyDeleteValue(key) {
        _origGM_deleteValue(key);

        fetch('http://localhost:3000/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key }),
        }).catch(() => {});
    }
    GM_deleteValue = proxyDeleteValue;


    _rot=0
    _back=15
    let useServer=false
    assistThem=false
    // 1️⃣ Define requestToken
    async function getToken_(id) {
        return new Promise(resolve => {
            function handler(e) {
                console.log(e.data.type,e.data&&e.data.type === 'TOKEN' && e.data.id == id)
                if (e.data&&e.data.type === 'TOKEN' && e.data.id == id) {
                    window.removeEventListener('message', handler);
                    resolve(e.data.token);
                }
            }
            window.addEventListener('message', handler);
            // open popup (must be from user event to avoid blocker)
            window.open(location.href, `authWindow-${id}`, 'width=400,height=500');
        });
    }
    getToken__=getToken_
    let scriptTags = document.getElementsByTagName("script");
    for (let i = 0; i < scriptTags.length; i++) {
        if (scriptTags[i].src.includes("index-eb87bff7.js")) {
            scriptTags[i].remove();
            console.log('Got',scriptTags[i])
            break;
        }
    }
    diddoge=0
    trapanimals=true

    ;(function(){
        class CustomLogging {
            constructor(title) {
                this.title = {
                    body: title || "---",
                    color: "darkgrey",
                    size: "1rem"
                }
                this.body = {
                    color: "#008f68",
                    size: "1rem"
                };
            }

            setTitleBody(title) {
                this.title.body = title;
                return this;
            }

            setTitleStyle({ color, size }) {
                if (color !== undefined) this.title.color = color;
                if (size !== undefined) this.title.size = size;
                return this;
            }

            setBodyStyle({ color, size }) {
                if (color !== undefined) this.body.color = color;
                if (size !== undefined) this.body.size = size;
                return this;
            }

            log(body = "") {
                console.log(
                    `%c${this.title.body} | %c${body}`,
                    `color: ${this.title.color}; font-weight: bold; font-size: ${this.title.size};`,
                    `color: ${this.body.color}; font-weight: bold; font-size: ${this.body.size}; text-shadow: 0 0 5px rgba(0,0,0,0.2);`
                );
            }
        }
        Object.assign(this || arguments[0], { CustomLog: CustomLogging })
    })(top);
    const olog=console.log
    const logger = new CustomLog("Script Logger");
    const consoleLogOriginal = console.log; // Preserve the original console.log
    console.log1 = function(...args) {
        // Check if any of the arguments is an object (excluding null)
        const containsObject = args.some(arg => typeof arg === 'object' && arg !== null);

        // Retrieve the caller function's name
        let callerFunctionName = 'Anonymous';

        try {
            // Throw an error to get the stack trace
            throw new Error();
        } catch (e) {
            olog
            if (e.stack) {
                // Parse the stack trace to get the caller function
                const stackLines = e.stack.split('\n');

                // The stack trace format varies between environments
                // For modern browsers, the third line is the caller
                // Adjust the index if needed based on your environment
                if (stackLines.length >= 3) {
                    const callerLine = stackLines[2];

                    // Extract the function name from the caller line
                    // This regex works for Chrome and Firefox
                    const functionNameMatch = callerLine.match(/at\s+(.*?)\s*\(/);

                    if (functionNameMatch && functionNameMatch[1]) {
                        callerFunctionName = functionNameMatch[1];
                    } else {
                        callerFunctionName = 'Anonymous';
                    }
                }
            }
        }

        if (!containsObject) {
            // If no objects, format the arguments for better presentation
            const formattedMessage = args.map(arg => String(arg)).join(' ');
            // Include the caller function name
            logger.log(`[${callerFunctionName}]`,formattedMessage);
        } else {
            // If there are objects, log them as they are, including the caller function name
            consoleLogOriginal(`og:[${callerFunctionName}]`, ...args);
        }
    };
    /*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⡛⠉⢯⣒⢤⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡖⢡⡐⡄⢀⡀⠈⢙⢮⡳⡄⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠣⠀⠂⠀⠈⠀⠀⠈⣈⠷⢉⠃⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠋⡐⡀⠀⠀⠀⠀⠀⣐⠼⢁⡞⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠣⢁⠐⠈⠆⣀⡈⠀⠲⢃⢠⠎⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⡅⠂⠄⠂⠈⠐⢠⠓⢢⠱⣨⠃⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⠤⣤⢤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠗⠀⠀⠀⠀⠂⠈⠀⠈⠄⣼⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⡟⣬⠛⣭⢫⡍⣶⢳⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⠂⠀⠀⠀⠀⢢⠀⠀⠀⠀⣾⠃⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡓⠤⠁⠎⠱⡈⡜⢥⢻⣹⢻⠷⡶⣶⡶⢶⣶⣦⣤⡀⣴⠟⠀⠀⠀⠀⠀⠀⠀⠐⠠⢩⠏⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣼⡧⠙⢢⠁⡈⠀⠀⠈⠀⠁⠋⠄⢊⠑⠄⠘⡀⢎⡝⣿⡟⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⣾⡿⢤⡁⢂⠡⠀⠀⠀⠀⠀⠀⡈⠁⢁⠊⠴⠓⠁⡜⣾⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⣴⣿⢟⡽⣂⠖⡄⢂⢀⣴⠼⡞⡿⣛⡝⠛⠛⠾⣦⣤⣾⣽⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠂⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢠⣾⣏⠳⢎⣖⠹⣎⡜⣧⡿⠡⢎⠱⠑⠨⠈⠁⠀⠀⠈⠉⣻⡏⠐⡀⠀⠀⠀⠀⠀⠀⠀⠀⢐⣺⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢸⡗⡮⣙⠦⡸⡙⣼⡿⢋⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡟⠠⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢸⣇⡳⡵⣊⠕⣩⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⣲⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢸⣿⣟⣡⢦⣽⡟⠐⠁⠀⢀⠠⠀⠀⠀⠀⠀⠀⠀⠀⢠⡇⠘⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⢸⠃⣀⣀⡀⠀⠀⠀⠀⠀⢀⠄⠀⠀⠀
⠀⠀⠀⢸⡿⠏⡉⣤⣿⠡⢈⠤⢁⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⣞⢡⠀⢀⠀⠀⠀⠀⠀⠀⠀⣴⢋⣿⠾⠃⠒⠘⠳⣶⣄⠀⢀⠃⠀⠀⠀⠀
⠀⠀⢠⣞⣵⠶⣿⣿⢁⡞⠤⠒⠠⠁⠂⠀⠀⠀⠀⠀⠀⠀⢰⡏⢆⠂⠄⠀⠀⠀⠀⠀⠀⠩⢄⣿⠋⠁⠀⠀⠁⠁⠡⡘⣿⠂⠀⠀⠀⠀⠀
⠀⣰⣿⡟⢡⣾⢿⣌⠳⡘⠤⠉⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⡑⠌⡐⠈⠄⠀⠂⢁⠐⢌⢂⣿⢃⠉⠀⠀⠠⢈⠠⡑⢆⢽⠀⠀⠀⠀⠀⠀
⢀⣿⡟⢡⣿⡟⢮⢌⢣⠐⠄⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⢏⠱⠈⠄⠡⠀⠌⡐⢀⠋⢤⣫⠇⠂⠀⠀⠀⠱⡁⠤⠱⣈⡟⠀⠀⠀⠀⠀⠀
⢸⣿⣇⣳⡯⡝⢮⡘⢄⠃⠌⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⠏⡌⠢⠁⠌⠠⢁⠂⠔⡈⠜⣲⠏⠀⠀⠀⠀⢠⠁⢀⢀⠂⣵⡷⠤⢤⡤⣀⠀⠀
⢸⣿⣟⡶⡹⣍⠦⡑⡈⠄⠀⠀⠀⠀⠀⠀⠀⠀⠤⣹⠣⡘⠠⠁⠌⠀⡁⢂⠌⡠⢉⣼⠇⠀⠀⠀⠀⠀⠢⢈⠀⡠⠘⣴⠏⠈⠀⠈⠺⢵⡆
⢸⣿⣿⢶⡹⢆⠳⠄⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠠⠁⠄⡁⠌⠀⠐⠄⠊⠤⡁⢧⡾⠁⠀⠀⠀⠀⠀⠄⠄⠐⠠⢻⡏⠀⠀⡀⠄⡑⢠⡇
⠸⣿⣿⣏⡳⢍⡚⢀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⢀⠂⣁⠂⠀⠀⠀⠌⡐⢉⠐⡌⢺⡇⠀⠀⠀⠀⠀⠀⠂⠀⠊⢰⡟⠀⠀⠀⠀⢂⠐⢯⡜
⠀⢻⣿⣯⣗⡪⢐⠂⠄⡀⠀⠀⢀⠀⠄⡀⠠⠐⠠⡈⠄⠌⡐⠀⠐⠠⠈⠄⢂⠜⣹⠄⠀⠐⠀⠀⣀⠁⢆⠐⢠⡿⠀⠀⠀⠀⡀⠌⡈⠵⡇
⠀⢸⣿⣿⣿⣷⡠⢌⡐⢀⠁⠄⠂⠌⡀⠀⠀⠄⠡⢐⠨⠐⠀⡐⠈⠄⠡⢈⠆⡹⢜⡀⠂⠀⠀⡐⠠⠈⢇⠀⣾⠠⠀⠀⠀⠀⠠⢀⠓⡸⡇
⠀⠈⣿⣿⣿⣿⣿⣶⣌⣦⡘⡬⣑⢢⠐⡀⠂⠌⡠⠁⠂⠁⠄⠄⠁⠌⡐⢂⠬⡑⢆⠀⠠⢀⠂⠡⢀⠊⠌⣸⠧⠐⠀⠀⠠⢀⠁⢢⠘⣼⠁
⠀⠀⢿⣿⣿⣿⣿⣿⣿⡼⣧⢧⣣⠜⣄⠣⡘⠤⡠⠀⠀⠘⡀⠀⠄⣀⢃⡘⢤⠛⠄⠘⠠⢄⠃⠤⠀⠄⡀⣿⠀⠀⠀⠠⠀⠀⡘⠄⣻⢻⠀
⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣯⣿⣳⢿⣤⡓⡜⡐⠀⠀⡄⢃⠄⠠⡀⢄⠢⢜⢢⡉⡐⢈⠐⡈⡘⠤⢉⡐⢡⠏⡐⠠⠁⠂⡀⠡⢐⢨⢴⠏⠀
⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣷⣯⣟⣿⣽⣳⣍⢶⣱⣌⠂⠌⢁⠰⣈⠲⣍⠢⡐⠁⠀⠀⠐⠀⢀⠂⢄⠣⡘⠠⢁⠂⡐⠠⢁⢢⢎⡿⠀⠀
⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣾⣿⣶⣮⣶⣼⢳⣎⡱⢌⠢⡁⠄⣁⠀⠂⢌⠂⢆⠁⠂⠄⡂⠥⢑⡈⢲⡾⠃⠀⠀
⠀⠀⠀⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣾⣵⣯⣶⣝⡲⢌⡘⢡⠂⢍⠠⠌⡐⠠⠘⡄⢣⢼⡿⠁⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠉⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣿⣽⣶⣭⢦⣉⠦⡘⢄⠢⣑⢣⡜⣱⠞⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣯⣷⣻⢯⣟⣿⣿⣷⣟⣾⣵⣮⣵⣺⣦⠿⠃⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠿⠿⠿⠿⠿⠿⠿⠿⠛⠋⠙⠛⠛⠛⠻⠿⠿⠿⣿⣿⣿⣿⡿⠟⠛⠉⠀⠀⠀⠀
*/

    let adAlt="alt:"
    let token
    const altchaEl = document.getElementById("altcha");
    function ze(e, t, i, n, s) {
        this.debugLog = !1,
            this.baseUrl = e,
            this.lobbySize = i,
            this.devPort = t,
            this.lobbySpread = n,
            this.rawIPs = !!s,
            this.server = void 0,
            this.gameIndex = void 0,
            this.callback = void 0,
            this.errorCallback = void 0
    }
    ze.prototype.regionInfo = {
        0: {
            name: "Local",
            latitude: 0,
            longitude: 0
        },
        "us-east": {
            name: "Miami",
            latitude: 40.1393329,
            longitude: -75.8521818
        },
        miami: {
            name: "Miami",
            latitude: 40.1393329,
            longitude: -75.8521818
        },
        "us-west": {
            name: "Silicon Valley",
            latitude: 47.6149942,
            longitude: -122.4759879
        },
        siliconvalley: {
            name: "Silicon Valley",
            latitude: 47.6149942,
            longitude: -122.4759879
        },
        gb: {
            name: "London",
            latitude: 51.5283063,
            longitude: -.382486
        },
        london: {
            name: "London",
            latitude: 51.5283063,
            longitude: -.382486
        },
        "eu-west": {
            name: "Frankfurt",
            latitude: 50.1211273,
            longitude: 8.496137
        },
        frankfurt: {
            name: "Frankfurt",
            latitude: 50.1211273,
            longitude: 8.496137
        },
        au: {
            name: "Sydney",
            latitude: -33.8479715,
            longitude: 150.651084
        },
        sydney: {
            name: "Sydney",
            latitude: -33.8479715,
            longitude: 150.651084
        },
        saopaulo: {
            name: "São Paulo",
            latitude: 23.5558,
            longitude: 46.6396
        },
        sg: {
            name: "Singapore",
            latitude: 1.3147268,
            longitude: 103.7065876
        },
        singapore: {
            name: "Singapore",
            latitude: 1.3147268,
            longitude: 103.7065876
        }
    };
    ze.prototype.start = function(e, t, i, n) {
        if (this.callback = t,
            this.errorCallback = i,
            n)
            return t();
        const s = this.parseServerQuery(e);
        s && s.length > 0 ? (this.log("Found server in query."),
                             this.password = s[3],
                             this.connect(s[0], s[1], s[2])) : this.errorCallback("Unable to find server")
    }
    ;
    ze.prototype.parseServerQuery = function(e) {
        const t = new URLSearchParams(location.search,!0)
        , i = e || t.get("server");
        if (typeof i != "string")
            return [];
        const [n,s] = i.split(":");
        return [n, s, t.get("password")]
    }
    ;
    ze.prototype.findServer = function(e, t) {
        var i = this.servers[e];
        for (let n = 0; n < i.length; n++) {
            const s = i[n];
            if (s.name === t)
                return s
        }
        console.warn("Could not find server in region " + e + " with serverName " + t + ".")
    }
    ;
    ze.prototype.seekServer = function(e, t, i) {
        i == null && (i = "random"),
            t == null && (t = !1);
        const n = ["random"]
        , s = this.lobbySize
        , r = this.lobbySpread
        , o = this.servers[e].flatMap(function(u) {
            let p = 0;
            return u.games.map(function(w) {
                const x = p++;
                return {
                    region: u.region,
                    index: u.index * u.games.length + x,
                    gameIndex: x,
                    gameCount: u.games.length,
                    playerCount: w.playerCount,
                    playerCapacity: w.playerCapacity,
                    isPrivate: w.isPrivate
                }
            })
        }).filter(function(u) {
            return !u.isPrivate
        }).filter(function(u) {
            return t ? u.playerCount == 0 && u.gameIndex >= u.gameCount / 2 : !0
        }).filter(function(u) {
            return i == "random" ? !0 : n[u.index % n.length].key == i
        }).sort(function(u, p) {
            return p.playerCount - u.playerCount
        }).filter(function(u) {
            return u.playerCount < s
        });
        if (t && o.reverse(),
            o.length == 0) {
            this.errorCallback("No open servers.");
            return
        }
        const l = Math.min(r, o.length);
        var f = Math.floor(Math.random() * l);
        f = Math.min(f, o.length - 1);
        const c = o[f]
        , a = c.region;
        var f = Math.floor(c.index / c.gameCount);
        const d = c.index % c.gameCount;
        return this.log("Found server."),
            [a, f, d]
    }
    ;
    ze.prototype.connect = function(e, t, i) {
        if (this.connected)
            return;
        const n = this.findServer(e, t);
        if (n == null) {
            this.errorCallback("Failed to find server for region " + e + " and serverName " + t);
            return
        }
        if (this.log("Connecting to server", n, "with game index", i),
            n.playerCount >= n.playerCapacity) {
            this.errorCallback("Server is already full.");
            return
        }
        window.history.replaceState(document.title, document.title, this.generateHref(e, t, this.password)),
            this.server = n,
            this.gameIndex = i,
            this.log("Calling callback with address", this.serverAddress(n), "on port", this.serverPort(n)),
            this.callback(this.serverAddress(n), this.serverPort(n), i),
            _i && clearInterval(_i)
    }
    ;
    ze.prototype.switchServer = function(e, t) {
        this.switchingServers = !0,
            window.location = this.generateHref(e, t, null)
    }
    ;
    ze.prototype.generateHref = function(e, t, i) {
        let n = window.location.href.split("?")[0];
        return n += "?server=" + e + ":" + t,
            i && (n += "&password=" + encodeURIComponent(i)),
            n
    }
    ;
    ze.prototype.serverAddress = function(e) {
        return e.region == 0 ? "localhost" : e.key + "." + e.region + "." + this.baseUrl
    }
    ;
    ze.prototype.serverPort = function(e) {
        return e.port
    }
    ;
    let _i;
    var sleep = ms => new Promise(a => setTimeout(a, ms));
    function Eu(e) {
        e = e.filter(s => s.playerCount !== s.playerCapacity);
        const t = Math.min(...e.map(s => s.ping || 1 / 0))
        , i = e.filter(s => s.ping === t);
        return !i.length > 0 ? null : i.reduce( (s, r) => s.playerCount > r.playerCount ? s : r)
    }
    ze.prototype.processServers = function(e) {
        return _i && clearInterval(_i),
            new Promise(t => {
            const i = {}
            , n = c => {
                const a = i[c]
                , f = a[0];
                let d = this.serverAddress(f);
                const u = this.serverPort(f);
                u && (d += `:${u}`);
                const p = `https://${d}/ping`
                , w = new Date().getTime();
                return Promise.race([fetch(p).then( () => {
                    const x = new Date().getTime() - w;
                    a.forEach(b => {
                        b.pings = b.pings ?? [],
                            b.pings.push(x),
                            b.pings.length > 10 && b.pings.shift(),
                            b.ping = Math.floor(b.pings.reduce( ($, v) => $ + v, 0) / b.pings.length)
                    }
                             )
                }
                                                  ).catch( () => {}
                                                         ), new Promise(x => setTimeout( () => x(), 100))])
            }
            , s = async () => {
                await Promise.all(Object.keys(i).map(n)),
                    window.blockRedraw || kt.redraw()
            }
            ;
            e.forEach(c => {
                i[c.region] = i[c.region] || [],
                    i[c.region].push(c)
            }
                     );
            for (const c in i)
                i[c] = i[c].sort(function(a, f) {
                    return f.playerCount - a.playerCount
                });
            this.servers = i;
            let r;
            const [o,l] = this.parseServerQuery();
            e.forEach(c => {
                o === c.region && l === c.name && (c.selected = !0,
                                                   r = c)
            }
                     ),
                s().then(s).then( () => {
                if (r)
                    return;
                let c = Eu(e);
                c || (c = e[0]),
                    c && (c.selected = !0,
                          window.history.replaceState(document.title, document.title, this.generateHref(c.region, c.name, this.password))),
                    window.blockRedraw || kt.redraw()
            }
                                ).then(s).catch(c => {}
                                               ).finally(t),
                _i = setInterval(s, 5e3)
        }
                       )
    }
    ;
    ze.prototype.ipToHex = function(e) {
        return e.split(".").map(i => ("00" + parseInt(i).toString(16)).substr(-2)).join("").toLowerCase()
    }
    ;
    ze.prototype.hashIP = function(e) {
        return tu(this.ipToHex(e))
    }
    ;
    ze.prototype.log = function() {
        if (this.debugLog)
            return console.log.apply(void 0, arguments);
        if (console.verbose)
            return console.verbose.apply(void 0, arguments)
    }
    ;
    ze.prototype.stripRegion = function(e) {
        return e.startsWith("vultr:") ? e = e.slice(6) : e.startsWith("do:") && (e = e.slice(3)),
            e
    }
    ;
    const Hf = location.hostname !== "localhost" && location.hostname !== "127.0.0.1" && !location.hostname.startsWith("192.168.")
    , Ta = location.hostname === "sandbox-dev.moomoo.io" || location.hostname === "sandbox.moomoo.io"
    , Lf = location.hostname === "dev.moomoo.io" || location.hostname === "dev2.moomoo.io"
    let dn,pn
    const xn = location.hostname === "localhost" || location.hostname === "127.0.0.1"
    , Ff = !1
    , nr = xn || Ff;
    Ta                                // sandbox?
        ? (dn = "https://api-sandbox.moomoo.io", pn = "moomoo.io")
    : Lf                            // dev?
        ? (dn = "https://api-dev.moomoo.io",    pn = "moomoo.io")
    : (dn = "https://api.moomoo.io",        pn = "moomoo.io");
    const Vf = !nr,xt = new ze(pn,443,40,Vf)
    let In;
    var params = new URLSearchParams(location.search);
    var serverParam = null//params.get("server");      // e.g. "miami:NM"
    var [region, name] = [0,0]//serverParam.split(":");
    async function getToken(){
        while(!token){await sleep(0)}
        return {token,In}
    }
    altchaEl.addEventListener("statechange", async (e) => {
        console.log("Altcha state changed to:", e.detail.state);
        if (e.detail.state === "verified") {

            let l=setInterval(()=>{
                params = new URLSearchParams(location.search);
                serverParam = params.get("server");
                params = new URLSearchParams(location.search);
                [region, name] = serverParam.split(":")
                console.log("Got payload:", e.detail.payload,'Server:',In);
                token=e.detail.payload
                if(window.name.includes('authWindow')){
                    //alert('Sending')
                    let id=window.name.replace('authWindow-','')
                    window.opener.postMessage({
                        type: 'TOKEN',
                        id /* same id you used when calling getToken */,
                        token
                    }, '*');
                    window.close();

                }
                In=new URL(location.href).searchParams.get('server')
                clearInterval(l)
            },100)
            }
    })
        ,altcha_checkbox.checked?null:altcha_checkbox.click()
    function isBadText(name){
        let noname = "unknown";
        name = name.replace(/[^\w:\(\)\/? -]+/gmi, " ");  // USE SPACE SO WE CAN CHECK PROFANITY
        name = name.replace(/[^\x00-\x7F]/g, " ");
        name = name.trim();
        let langFilter = {
            "list": [
                "ahole",
                "anus",
                "ash0le",
                "ash0les",
                "asholes",
                "ass",
                "Ass Monkey",
                "Assface",
                "assh0le",
                "assh0lez",
                "asshole",
                "assholes",
                "assholz",
                "asswipe",
                "azzhole",
                "bassterds",
                "bastard",
                "bastards",
                "bastardz",
                "basterds",
                "basterdz",
                "Biatch",
                "bitch",
                "bitches",
                "Blow Job",
                "boffing",
                "butthole",
                "buttwipe",
                "c0ck",
                "c0cks",
                "c0k",
                "Carpet Muncher",
                "cawk",
                "cawks",
                "Clit",
                "cnts",
                "cntz",
                "cock",
                "cockhead",
                "cock-head",
                "cocks",
                "CockSucker",
                "cock-sucker",
                "crap",
                "cum",
                "cunt",
                "cunts",
                "cuntz",
                "dick",
                "dild0",
                "dild0s",
                "dildo",
                "dildos",
                "dilld0",
                "dilld0s",
                "dominatricks",
                "dominatrics",
                "dominatrix",
                "dyke",
                "enema",
                "f u c k",
                "f u c k e r",
                "fag",
                "fag1t",
                "faget",
                "fagg1t",
                "faggit",
                "faggot",
                "fagg0t",
                "fagit",
                "fags",
                "fagz",
                "faig",
                "faigs",
                "fart",
                "flipping the bird",
                "fuck",
                "fucker",
                "fuckin",
                "fucking",
                "fucks",
                "Fudge Packer",
                "fuk",
                "Fukah",
                "Fuken",
                "fuker",
                "Fukin",
                "Fukk",
                "Fukkah",
                "Fukken",
                "Fukker",
                "Fukkin",
                "g00k",
                "God-damned",
                "h00r",
                "h0ar",
                "h0re",
                "hells",
                "hoar",
                "hoor",
                "hoore",
                "jackoff",
                "jap",
                "japs",
                "jerk-off",
                "jisim",
                "jiss",
                "jizm",
                "jizz",
                "knob",
                "knobs",
                "knobz",
                "kunt",
                "kunts",
                "kuntz",
                "Lezzian",
                "Lipshits",
                "Lipshitz",
                "masochist",
                "masokist",
                "massterbait",
                "masstrbait",
                "masstrbate",
                "masterbaiter",
                "masterbate",
                "masterbates",
                "Motha Fucker",
                "Motha Fuker",
                "Motha Fukkah",
                "Motha Fukker",
                "Mother Fucker",
                "Mother Fukah",
                "Mother Fuker",
                "Mother Fukkah",
                "Mother Fukker",
                "mother-fucker",
                "Mutha Fucker",
                "Mutha Fukah",
                "Mutha Fuker",
                "Mutha Fukkah",
                "Mutha Fukker",
                "n1gr",
                "nastt",
                "nigger;",
                "nigur;",
                "niiger;",
                "niigr;",
                "orafis",
                "orgasim;",
                "orgasm",
                "orgasum",
                "oriface",
                "orifice",
                "orifiss",
                "packi",
                "packie",
                "packy",
                "paki",
                "pakie",
                "paky",
                "pecker",
                "peeenus",
                "peeenusss",
                "peenus",
                "peinus",
                "pen1s",
                "penas",
                "penis",
                "penis-breath",
                "penus",
                "penuus",
                "Phuc",
                "Phuck",
                "Phuk",
                "Phuker",
                "Phukker",
                "polac",
                "polack",
                "polak",
                "Poonani",
                "pr1c",
                "pr1ck",
                "pr1k",
                "pusse",
                "pussee",
                "pussy",
                "puuke",
                "puuker",
                "queer",
                "queers",
                "queerz",
                "qweers",
                "qweerz",
                "qweir",
                "recktum",
                "rectum",
                "retard",
                "sadist",
                "scank",
                "schlong",
                "screwing",
                "semen",
                "sex",
                "sexy",
                "Sh!t",
                "sh1t",
                "sh1ter",
                "sh1ts",
                "sh1tter",
                "sh1tz",
                "shit",
                "shits",
                "shitter",
                "Shitty",
                "Shity",
                "shitz",
                "Shyt",
                "Shyte",
                "Shytty",
                "Shyty",
                "skanck",
                "skank",
                "skankee",
                "skankey",
                "skanks",
                "Skanky",
                "slag",
                "slut",
                "sluts",
                "Slutty",
                "slutz",
                "son-of-a-bitch",
                "tit",
                "turd",
                "va1jina",
                "vag1na",
                "vagiina",
                "vagina",
                "vaj1na",
                "vajina",
                "vullva",
                "vulva",
                "w0p",
                "wh00r",
                "wh0re",
                "whore",
                "xrated",
                "xxx",
                "b!+ch",
                "bitch",
                "blowjob",
                "clit",
                "arschloch",
                "fuck",
                "shit",
                "ass",
                "asshole",
                "b!tch",
                "b17ch",
                "b1tch",
                "bastard",
                "bi+ch",
                "boiolas",
                "buceta",
                "c0ck",
                "cawk",
                "chink",
                "cipa",
                "clits",
                "cock",
                "cum",
                "cunt",
                "dildo",
                "dirsa",
                "ejakulate",
                "fatass",
                "fcuk",
                "fuk",
                "fux0r",
                "hoer",
                "hore",
                "jism",
                "kawk",
                "l3itch",
                "l3i+ch",
                "lesbian",
                "masturbate",
                "masterbat*",
                "masterbat3",
                "motherfucker",
                "s.o.b.",
                "mofo",
                "nazi",
                "nigga",
                "nigger",
                "nutsack",
                "phuck",
                "pimpis",
                "pusse",
                "pussy",
                "scrotum",
                "sh!t",
                "shemale",
                "shi+",
                "sh!+",
                "slut",
                "smut",
                "teets",
                "tits",
                "boobs",
                "b00bs",
                "teez",
                "testical",
                "testicle",
                "titt",
                "w00se",
                "jackoff",
                "wank",
                "whoar",
                "whore",
                "*damn",
                "*dyke",
                "*fuck*",
                "*shit*",
                "@$$",
                "amcik",
                "andskota",
                "arse*",
                "assrammer",
                "ayir",
                "bi7ch",
                "bitch*",
                "bollock*",
                "breasts",
                "butt-pirate",
                "cabron",
                "cazzo",
                "chraa",
                "chuj",
                "Cock*",
                "cunt*",
                "d4mn",
                "daygo",
                "dego",
                "dick*",
                "dike*",
                "dupa",
                "dziwka",
                "ejackulate",
                "Ekrem*",
                "Ekto",
                "enculer",
                "faen",
                "fag*",
                "fanculo",
                "fanny",
                "feces",
                "feg",
                "Felcher",
                "ficken",
                "fitt*",
                "Flikker",
                "foreskin",
                "Fotze",
                "Fu(*",
                "fuk*",
                "futkretzn",
                "gook",
                "guiena",
                "h0r",
                "h4x0r",
                "hell",
                "helvete",
                "hoer*",
                "honkey",
                "Huevon",
                "hui",
                "injun",
                "jizz",
                "kanker*",
                "kike",
                "klootzak",
                "kraut",
                "knulle",
                "kuk",
                "kuksuger",
                "Kurac",
                "kurwa",
                "kusi*",
                "kyrpa*",
                "lesbo",
                "mamhoon",
                "masturbat*",
                "merd*",
                "mibun",
                "monkleigh",
                "mouliewop",
                "muie",
                "mulkku",
                "muschi",
                "nazis",
                "nepesaurio",
                "nigger*",
                "orospu",
                "paska*",
                "perse",
                "picka",
                "pierdol*",
                "pillu*",
                "pimmel",
                "piss*",
                "pizda",
                "poontsee",
                "poop",
                "porn",
                "p0rn",
                "pr0n",
                "preteen",
                "pula",
                "pule",
                "puta",
                "puto",
                "qahbeh",
                "queef*",
                "rautenberg",
                "schaffer",
                "scheiss*",
                "schlampe",
                "schmuck",
                "screw",
                "sh!t*",
                "sharmuta",
                "sharmute",
                "shipal",
                "shiz",
                "skribz",
                "skurwysyn",
                "sphencter",
                "spic",
                "spierdalaj",
                "splooge",
                "suka",
                "b00b*",
                "testicle*",
                "titt*",
                "twat",
                "vittu",
                "wank*",
                "wetback*",
                "wichser",
                "wop*",
                "yed",
                "zabourah",
                "4r5e",
                "5h1t",
                "5hit",
                "a55",
                "anal",
                "anus",
                "ar5e",
                "arrse",
                "arse",
                "ass",
                "ass-fucker",
                "asses",
                "assfucker",
                "assfukka",
                "asshole",
                "assholes",
                "asswhole",
                "a_s_s",
                "b!tch",
                "b00bs",
                "b17ch",
                "b1tch",
                "ballbag",
                "balls",
                "ballsack",
                "bastard",
                "beastial",
                "beastiality",
                "bellend",
                "bestial",
                "bestiality",
                "bi+ch",
                "biatch",
                "bitch",
                "bitcher",
                "bitchers",
                "bitches",
                "bitchin",
                "bitching",
                "bloody",
                "blow job",
                "blowjob",
                "blowjobs",
                "boiolas",
                "bollock",
                "bollok",
                "boner",
                "boob",
                "boobs",
                "booobs",
                "boooobs",
                "booooobs",
                "booooooobs",
                "breasts",
                "buceta",
                "bugger",
                "bum",
                "bunny fucker",
                "butt",
                "butthole",
                "buttmuch",
                "buttplug",
                "c0ck",
                "c0cksucker",
                "carpet muncher",
                "cawk",
                "chink",
                "cipa",
                "cl1t",
                "clit",
                "clitoris",
                "clits",
                "cnut",
                "cock",
                "cock-sucker",
                "cockface",
                "cockhead",
                "cockmunch",
                "cockmuncher",
                "cocks",
                "cocksuck",
                "cocksucked",
                "cocksucker",
                "cocksucking",
                "cocksucks",
                "cocksuka",
                "cocksukka",
                "cok",
                "cokmuncher",
                "coksucka",
                "coon",
                "cox",
                "crap",
                "cum",
                "cummer",
                "cumming",
                "cums",
                "cumshot",
                "cunilingus",
                "cunillingus",
                "cunnilingus",
                "cunt",
                "cuntlick",
                "cuntlicker",
                "cuntlicking",
                "cunts",
                "cyalis",
                "cyberfuc",
                "cyberfuck",
                "cyberfucked",
                "cyberfucker",
                "cyberfuckers",
                "cyberfucking",
                "d1ck",
                "damn",
                "dick",
                "dickhead",
                "dildo",
                "dildos",
                "dink",
                "dinks",
                "dirsa",
                "dlck",
                "dog-fucker",
                "doggin",
                "dogging",
                "donkeyribber",
                "doosh",
                "duche",
                "dyke",
                "ejaculate",
                "ejaculated",
                "ejaculates",
                "ejaculating",
                "ejaculatings",
                "ejaculation",
                "ejakulate",
                "f u c k",
                "f u c k e r",
                "f4nny",
                "fag",
                "fagging",
                "faggitt",
                "faggot",
                "faggs",
                "fagot",
                "fagots",
                "fags",
                "fanny",
                "fannyflaps",
                "fannyfucker",
                "fanyy",
                "fatass",
                "fcuk",
                "fcuker",
                "fcuking",
                "feck",
                "fecker",
                "felching",
                "fellate",
                "fellatio",
                "fingerfuck",
                "fingerfucked",
                "fingerfucker",
                "fingerfuckers",
                "fingerfucking",
                "fingerfucks",
                "fistfuck",
                "fistfucked",
                "fistfucker",
                "fistfuckers",
                "fistfucking",
                "fistfuckings",
                "fistfucks",
                "flange",
                "fook",
                "fooker",
                "fuck",
                "fucka",
                "fucked",
                "fucker",
                "fuckers",
                "fuckhead",
                "fuckheads",
                "fuckin",
                "fucking",
                "fuckings",
                "fuckingshitmotherfucker",
                "fuckme",
                "fucks",
                "fuckwhit",
                "fuckwit",
                "fudge packer",
                "fudgepacker",
                "fuk",
                "fuker",
                "fukker",
                "fukkin",
                "fuks",
                "fukwhit",
                "fukwit",
                "fux",
                "fux0r",
                "f_u_c_k",
                "gangbang",
                "gangbanged",
                "gangbangs",
                "gaylord",
                "gaysex",
                "goatse",
                "God",
                "god-dam",
                "god-damned",
                "goddamn",
                "goddamned",
                "hardcoresex",
                "hell",
                "heshe",
                "hoar",
                "hoare",
                "hoer",
                "homo",
                "hore",
                "horniest",
                "horny",
                "hotsex",
                "jack-off",
                "jackoff",
                "jap",
                "jerk-off",
                "jism",
                "jiz",
                "jizm",
                "jizz",
                "kawk",
                "knob",
                "knobead",
                "knobed",
                "knobend",
                "knobhead",
                "knobjocky",
                "knobjokey",
                "kock",
                "kondum",
                "kondums",
                "kum",
                "kummer",
                "kumming",
                "kums",
                "kunilingus",
                "l3i+ch",
                "l3itch",
                "labia",
                "lust",
                "lusting",
                "m0f0",
                "m0fo",
                "m45terbate",
                "ma5terb8",
                "ma5terbate",
                "masochist",
                "master-bate",
                "masterb8",
                "masterbat*",
                "masterbat3",
                "masterbate",
                "masterbation",
                "masterbations",
                "masturbate",
                "mo-fo",
                "mof0",
                "mofo",
                "mothafuck",
                "mothafucka",
                "mothafuckas",
                "mothafuckaz",
                "mothafucked",
                "mothafucker",
                "mothafuckers",
                "mothafuckin",
                "mothafucking",
                "mothafuckings",
                "mothafucks",
                "mother fucker",
                "motherfuck",
                "motherfucked",
                "motherfucker",
                "motherfuckers",
                "motherfuckin",
                "motherfucking",
                "motherfuckings",
                "motherfuckka",
                "motherfucks",
                "muff",
                "mutha",
                "muthafecker",
                "muthafuckker",
                "muther",
                "mutherfucker",
                "n1gga",
                "n1gger",
                "nazi",
                "nigg3r",
                "nigg4h",
                "nigga",
                "niggah",
                "niggas",
                "niggaz",
                "nigger",
                "niggers",
                "nob",
                "nob jokey",
                "nobhead",
                "nobjocky",
                "nobjokey",
                "numbnuts",
                "nutsack",
                "orgasim",
                "orgasims",
                "orgasm",
                "orgasms",
                "p0rn",
                "pawn",
                "pecker",
                "penis",
                "penisfucker",
                "phonesex",
                "phuck",
                "phuk",
                "phuked",
                "phuking",
                "phukked",
                "phukking",
                "phuks",
                "phuq",
                "pigfucker",
                "pimpis",
                "piss",
                "pissed",
                "pisser",
                "pissers",
                "pisses",
                "pissflaps",
                "pissin",
                "pissing",
                "pissoff",
                "poop",
                "porn",
                "porno",
                "pornography",
                "pornos",
                "prick",
                "pricks",
                "pron",
                "pube",
                "pusse",
                "pussi",
                "pussies",
                "pussy",
                "pussys",
                "rectum",
                "retard",
                "rimjaw",
                "rimming",
                "s hit",
                "s.o.b.",
                "sadist",
                "schlong",
                "screwing",
                "scroat",
                "scrote",
                "scrotum",
                "semen",
                "sex",
                "sh!+",
                "sh!t",
                "sh1t",
                "shag",
                "shagger",
                "shaggin",
                "shagging",
                "shemale",
                "shi+",
                "shit",
                "shitdick",
                "shite",
                "shited",
                "shitey",
                "shitfuck",
                "shitfull",
                "shithead",
                "shiting",
                "shitings",
                "shits",
                "shitted",
                "shitter",
                "shitters",
                "shitting",
                "shittings",
                "shitty",
                "skank",
                "slut",
                "sluts",
                "smegma",
                "smut",
                "snatch",
                "son-of-a-bitch",
                "spac",
                "spunk",
                "s_h_i_t",
                "t1tt1e5",
                "t1tties",
                "teets",
                "teez",
                "testical",
                "testicle",
                "tit",
                "titfuck",
                "tits",
                "titt",
                "tittie5",
                "tittiefucker",
                "titties",
                "tittyfuck",
                "tittywank",
                "titwank",
                "tosser",
                "turd",
                "tw4t",
                "twat",
                "twathead",
                "twatty",
                "twunt",
                "twunter",
                "v14gra",
                "v1gra",
                "vagina",
                "viagra",
                "vulva",
                "w00se",
                "wang",
                "wank",
                "wanker",
                "wanky",
                "whoar",
                "whore",
                "willies",
                "willy",
                "xrated",
                "xxx",
                "jew",
                "black",
                "baby",
                "child",
                "white",
                "porn",
                "pedo",
                "trump",
                "clinton",
                "hitler",
                "nazi",
                "gay",
                "pride",
                "sex",
                "pleasure",
                "touch",
                "poo",
                "kids",
                "rape",
                "white power",
                "nigga",
                "nig nog",
                "doggy",
                "rapist",
                "boner",
                "nigger",
                "nigg",
                "finger",
                "nogger",
                "nagger",
                "nig",
                "fag",
                "gai",
                "pole",
                "stripper",
                "penis",
                "vagina",
                "pussy",
                "nazi",
                "hitler",
                "stalin",
                "burn",
                "chamber",
                "cock",
                "peen",
                "dick",
                "spick",
                "nieger",
                "die",
                "satan",
                "n|ig",
                "nlg",
                "cunt",
                "c0ck",
                "fag",
                "lick",
                "condom",
                "anal",
                "shit",
                "phile",
                "little",
                "kids",
                "free KR",
                "tiny",
                "sidney",
                "ass",
                "kill",
                ".io",
                "(dot)",
                "[dot]",
                "mini",
                "whiore",
                "whore",
                "faggot",
                "github",
                "1337",
                "666",
                "satan",
                "senpa",
                "discord",
                "d1scord",
                "mistik",
                ".io",
                "senpa.io",
                "sidney",
                "sid",
                "senpaio",
                "vries",
                "asa"
            ],
            "exclude": [],
            "placeHolder": "*",
            "regex": {},
            "replaceRegex": {}
        };
        let isProfane = false;
        let convertedName = name.toLowerCase().replace(/\s/g, "").replace(/1/g, "i").replace(/0/g, "o").replace(/5/g, "s");
        for (let word of langFilter.list) {
            if (convertedName.indexOf(word) != -1) {
                isProfane = true;
                break;
            }
        }
        if (name.length > 0 && !isProfane) {
        }
        return isProfane
    }
    showTeams=true;
    filterclan=true
    window.frameTest=function(swingBull){
        let o=(function(player=_things.player,targetPos=_things.enemy.enemy){
            const sx = player.x, sy = player.y;
            const dx = targetPos.x - sx, dy = targetPos.y - sy;
            const dist = Math.hypot(dx, dy);
            const wep   = weapons.find(w => w.id === player.secondaryIndex);
            const projR = _things.items.projectiles[wep.projectile];
            const projT = _things.items.projectiles[1];

            const ticksR = dist / projR.speed;
            const ticksT = dist / projT.speed;
            const faster = ticksR < ticksT ? 'range' : 'turret';
            let timout=Math.abs(ticksR-ticksT)
            return {ticksR,ticksT,faster,timout}
        })()
        _things.autoAim = 1;
        //shoot turret first
        if (o.faster === 'range') {

            // 1️⃣ Fire turret first
            _things.buyEquip(53, 0);

            setTimeout(()=>{
                // 2️⃣ Switch to ranged weapon (index 1) and shoot
                _things.selectWeapon(_things.player.weapons[1]);
                _things.sendAutoGather();


                // small delay to ensure equip goes through
                setTimeout(()=>{
                    if(swingBull){
                        // 3️⃣ Now equip hat-7 (primary) and swing
                        _things.buyEquip(7, 0);
                        _things.selectWeapon(_things.player.weapons[0])
                    }
                    setTimeout(()=>{_things.sendAutoGather();},200)
                }, 100);  // tweak this ms if needed

                // 4️⃣ reset autoAim after all attacks
                setTimeout(()=>{
                    _things.autoAim = 0;
                }, 300);
            }, o.timout);
        }
        // shoot ranged first
        else {
            // keep auto-aim on for synced hits

            // 1️⃣ Fire ranged weapon immediately
            _things.selectWeapon(_things.player.weapons[1]);
            _things.sendAutoGather();

            // 2️⃣ After the timing offset, fire turret to sync with range shot
            setTimeout(()=>{
                _things.buyEquip(53, 0);   // equip turret

                // 3️⃣ Hat-7 swing if flagged
                if (swingBull) {
                    _things.buyEquip(7, 0);                        // equip hat-7
                    _things.selectWeapon(_things.player.weapons[0]); // switch to hat
                    setTimeout(()=>{
                        _things.sendAutoGather();                  // swing hat
                    }, 200);  // tweak this delay if needed
                }

                // 4️⃣ reset autoAim after all shots
                setTimeout(()=>{
                    _things.autoAim = 0;
                }, 300);
            }, o.timout);
        }
    }
    autoQ=false;
    olgGMS=GM_setValue
    olgGMG=GM_getValue
    let peaple=[]
    GM_addValueChangeListener('acc',function(a,b,c,d){
        console.log('acc',c)
        if(c&&c.team==_things.player.team&&_things.player.isOwner){
            console.log('Accepting',c.sid)
            _things.packet&&(_things.packet('P',c.sid,1))
        }
    })
    millDone=null
    disableRender=false
    addPlayerTooObst=true
    IsautoRuby=false
    didSpawn=false
    minused=20
    OkC=false;
    nonBreak=false
    autoJoinMain=true
    let objCha={}
    document.title = "Sheepy's Moomoo :3";
    document.getElementById("mainMenu").style.backgroundSize = "cover";
    document.getElementById("mainMenu").style.backgroundPosition = "center";
    document.getElementById("mainMenu").style.width = "100%";
    document.getElementById("mainMenu").style.height = "100vh";
    document.getElementById("gameName").style.textShadow = "#FF2525 -2px -2px 10px, black 0px -5px 1px, white 0px -5px 10px";
    document.getElementById("loadingText").innerText="";
    document.getElementById("leaderboard").append("Sheepy-Mod");
    function isObjectBroken(object) {
        const healthThreshold = 20;
        return object.health < healthThreshold;
    }
    window=(top||self,this.window||unsafeWindow)
    window.unsafeWindow =unsafeWindow;
    eval(`unsafeWindow=window.unsafeWindow||window`)
    //unsafeWindow=this.unsafeWindow||window;
    const textChange = {
        disconnected() {
            // Temporarily disable the beforeunload event
            unsafeWindow.onbeforeunload = null;
            //location.reload();
        }
    };
    function observeTextChange(elementId, callback) {
        const targetElement = document.getElementById(elementId);

        if (!targetElement) {
            console.error(`Element with ID "${elementId}" not found.`);
            return;
        }

        const observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'characterData' || mutation.type === 'childList') {
                    callback(targetElement.textContent);
                }
            }
        });

        observer.observe(targetElement, {
            childList: true, // Watches for changes to child nodes
            characterData: true, // Watches for changes to text nodes
            subtree: true, // Observes all descendants
        });
    }

    // Example Usage
    observeTextChange('loadingText', (newText) => {
        console.log('Text changed to:', newText);
        textChange[newText]&&textChange[newText]()
    });
    //todo add ts
    /*function NewServer(){
        function getCR(){
            return {name:serverBrowser.selectedOptions[0].innerText.split(' ')[0],id:serverBrowser.selectedOptions[0].value,index:serverBrowser.selectedOptions[0].innerText.split(' ')[1]};
        }
        var servers=[];
        serverBrowser.children.forEah=[].forEach;[...serverBrowser.children].forEach(e=>{
            var a=e.innerText.split(' ').pop().split('/')[0].split("[")[1]*1,
                b=e.value,r=e.value.split(':')[0];
            if(r==getCR().id.split(':')[0]){servers.push({a,b,e})}
        })
        var bestserver=servers.sort((a,b)=>b.a-a.a).filter(num=>num.a<40)[0];
        var nsi=bestserver.b.split(":");nsi[1]=(nsi[1]*1)+1+'';nsi=nsi.join(':');
        bestserver.b=nsi;
        var ns=location.href.split('=');ns[1]=bestserver.b;ns=ns.join('=');
        location.href=ns;
    }
    unsafeWindow.NewServer=NewServer;
    function savel(){
        localStorage.items2=JSON.stringify(items2)
    }
    function loadl(){
        items2=JSON.parse(localStorage.items2);
    }
    const N=[
        [],
        [""],
        ['Button','Crash?!','br','Button','New Server','br','Button','Autoplay','br','Button','Stop brekaing','br','Button','Load layout','br','Button','Save layout','br'],
        [''],
        [document,window],
        {}
    ]
    var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){N[4][1]["crash"]()};B["innerText"]=N[2][1];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){N[4][1]["NewServer"]()};B["innerText"]=N[2][4];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){N[4][1]["Autoplay"]()};B["innerText"]=N[2][7];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){intrap=0};B["innerText"]=N[2][10];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){loadl()};B["innerText"]=N[2][13];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){savel()};B["innerText"]=N[2][16];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B)
*/
    /**
 * Checks if an enemy is within the shield angle relative to the player's direction.
 *
 * @param {Object} player - { x, y, facingAngle } - Player position and facing angle (in degrees).
 * @param {Object} enemy - { x, y } - Enemy position.
 * @param {number} shieldAngle - Total shield coverage angle (default is 168°).
 * @returns {boolean} - True if the enemy is within the shield angle, false otherwise.
 */
    function isInShieldDist(player, enemy, shieldAngle = 168) {
        const dx = enemy.x - player.x; // Difference in x
        const dy = enemy.y - player.y; // Difference in y

        // Calculate the angle between the player and the enemy in degrees
        let angleToEnemy = Math.atan2(dy, dx) * (180 / Math.PI); // Radians to degrees

        // Normalize angles to the range [0, 360]
        const playerFacing = ((player.facingAngle % 360) + 360) % 360;
        angleToEnemy = ((angleToEnemy % 360) + 360) % 360;

        // Calculate half the shield angle
        const shieldHalfAngle = shieldAngle / 2;

        // Determine the range of the shield
        const shieldStart = (playerFacing - shieldHalfAngle + 360) % 360;
        const shieldEnd = (playerFacing + shieldHalfAngle) % 360;

        // Check if the angle to the enemy is within the shield range
        if (shieldStart <= shieldEnd) {
            // The shield range does not wrap around 0°
            return angleToEnemy >= shieldStart && angleToEnemy <= shieldEnd;
        } else {
            // The shield range wraps around 0°
            return angleToEnemy >= shieldStart || angleToEnemy <= shieldEnd;
        }
    }



    let gameLoopState = {
        isMovingAuto: 0,
        targetPos: null,
        obss: [],
        canRun: true,
        step: 0,
        rubyAttempts: 0,
        maxRubyAttempts: 50,
        rubyIndex:0
    };

    let toMove=[]
    let nearspiker = false;
    let info = {};
    let autos={}
    let aimSpike = 0;
    unsafeWindow.can=1
    /**
 * Check if a point is inside the boss arena.
 * @param {Object} pos - The position to check {x, y}.
 * @param {Array} arena - The boss arena coordinates array.
 * @returns {boolean} True if inside, false otherwise.
 */
    function isInsideArena(pos, arena) {
        const radius = 300; // Adjust this based on arena approximation accuracy
        const center = { x: 7230, y: 13200 }; // Approximate center of the arena
        const distance = Math.sqrt(Math.pow(pos.x - center.x, 2) + Math.pow(pos.y - center.y, 2));
        return distance <= radius;
    }


    document.onreadystatechange=function(e){console.log(e)}
    class element {
        static get br() {
            return new element("br");
        }
        constructor(name, obj) {
            //findhref2(id('skin-message'))[0].constructor.name

            this.element = name.constructor.name.includes('HTML')&&(name)||(function () {
                for (let i in arguments[1]) {
                    arguments[0].setAttribute(i, arguments[1][i]);
                }
                return arguments[0];
            })(document.createElement(arguments[0]), arguments[1]);
        }
        style(obj) {
            for (let i in obj) {
                this.element.style[i] = obj[i];
            }
            return this;
        }
        append(target,...targets) {
            this.element.append(target.element || target);
            console.log("T:",{targets,fe:targets&&targets.forEach})
            for(let i=0;i<targets.length;i++){
                let a=targets[i];
                console.log('Appending:',{element:a,target:this})
                this.element.append(a.element || a);
            }
            return this;
        }
        appendTo(target) {
            (target.element || typeof target=='string'?document.querySelector(target):target).append(this.element);
            return this;
        }
        on(event, a) {
            this.element[`on${event}`] = a;
            return this;
        }
        set(prop, value) {
            this.element[prop] = value;
            return this;
        }
        remove() {
            this.element.remove();
            return this;
        }
        get() {
            return this.element[arguments[0]];
        }
        get children() {
            return new (class $ {
                constructor(arr) {
                    for (var i = 0; i < arr.length; i += 1) {
                        this[i] = arr[i];
                    }

                    // length is readonly
                    Object.defineProperty(this, "length", {
                        get: function () {
                            return arr.length;
                        }
                    });

                    // a HTMLCollection is immutable
                    Object.freeze(this);
                }
                item(i) {
                    return this[i] != null ? this[i] : null;
                }
                namedItem(name) {
                    for (var i = 0; i < this.length; i += 1) {
                        if (this[i].id === name || this[i].name === name) {
                            return this[i];
                        }
                    }
                    return null;
                }
                get toArray() {
                    return [...this];
                }
            })([...this.element.children]);
        }
    }
    let used={};
    let msg=`HI
ttv/therealwolfg
@therealwolfg on YT
your gay
i can do pit insta
this mod private
oof why u bully me
IM immortal
U cant kill me
Cauese im immortallity
I beat u
I know ur noob
im legend
Legend neverdie
Gaston1799_
your mom gay
hello im new here :3
hello sheeper
mod?
What mod ya got?
my mdo is better tho >:)
cmon man
stfu noob
imagine dying
bruh
dude cmon
yo!
cant die
Ez
ez
EZEZ
haha
So good byenoob
i can insta u
il do a q insta
see you later looser.
imagine dying to a bot.
Gaston1799`.split('\n');
    function random(arr){return arr[Math.floor(Math.random() * arr.length)];}
    _random=random
    function gmsg(){
        let a=msg[Math.floor(Math.random() * msg.length)];;if(!used[a]){used[a]=1;setTimeout(()=>{used[a]=0},5000);return a}else{return gmsg();}
    }
    autoChat=false
    setInterval(()=>{
        autoChat&&typeof chat!='undefined'&&(chat(gmsg()))
    },2300)
    GM_getValue=function(k){
        try{return eval(localStorage[k])}
        catch{return JSON.parse(localStorage[k])}
    }
    GM_setValue=function(k,v){
        return localStorage[k]=JSON.stringify(v)
    }
    function toRad(angle) {
        return angle * 0.01745329251;
    };
    _tr=toRad
    _my={}
    _set=function(e){
        _my=e
    }
    if(location.hostname == "sandbox.moomoo.io") {
        document.getElementById("foodDisplay").style.display = "none";
        document.getElementById("woodDisplay").style.display = "none";
        document.getElementById("stoneDisplay").style.display = "none";
    }
    let safewalking = false;
    let antispiketicked = false;
    let autoOneFrameToggled = false;
    const {
        sin,
        cos,
        sqrt,
        min
    } = Math;

    let RealPush = false;

    let useHack = true;
    let log = console.log;
    let testMode = unsafeWindow.location.hostname == "127.0.0.1";
    let imueheua = false;

    function getEl(id) {
        return document.getElementById(id);
    }

    var EasyStar = function(e) {
        var o = {};
        function r(t) {
            if (o[t]) return o[t].exports;
            var n = o[t] = {
                i: t,
                l: !1,
                exports: {}
            };
            return e[t].call(n.exports, n, n.exports, r), n.l = !0, n.exports
        }
        return r.m = e, r.c = o, r.d = function(t, n, e) {
            r.o(t, n) || Object.defineProperty(t, n, {
                enumerable: !0,
                get: e
            })
        }, r.r = function(t) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }, r.t = function(n, t) {
            if (1 & t && (n = r(n)), 8 & t) return n;
            if (4 & t && "object" == typeof n && n && n.__esModule) return n;
            var e = Object.create(null);
            if (r.r(e), Object.defineProperty(e, "default", {
                enumerable: !0,
                value: n
            }), 2 & t && "string" != typeof n)
                for (var o in n) r.d(e, o, function(t) {
                    return n[t]
                }.bind(null, o));
            return e
        }, r.n = function(t) {
            var n = t && t.__esModule ? function() {
                return t.default
            } : function() {
                return t
            };
            return r.d(n, "9", n), n
        }, r.o = function(t, n) {
            return Object.prototype.hasOwnProperty.call(t, n)
        }, r.p = "/bin/", r(r.s = 0)
    }(
        [
            function(t, n, e) {
                var P = {},
                    M = e(1),
                    _ = e(2),
                    A = e(3);
                t.exports = P;
                var E = 1;
                P.js = function() {
                    var c, i, f, s = 1.4,
                        p = !1,
                        u = {},
                        o = {},
                        r = {},
                        l = {},
                        a = !0,
                        h = {},
                        d = [],
                        y = Number.MAX_VALUE,
                        v = !1;
                    this.setAcceptableTiles = function(t) {
                        t instanceof Array ? f = t : !isNaN(parseFloat(t)) && isFinite(t) && (f = [t])
                    }, this.enableSync = function() {
                        p = !0
                    }, this.disableSync = function() {
                        p = !1
                    }, this.enableDiagonals = function() {
                        v = !0
                    }, this.disableDiagonals = function() {
                        v = !1
                    }, this.setGrid = function(t) {
                        c = t;
                        for (var n = 0; n < c.length; n++)
                            for (var e = 0; e < c[0].length; e++) o[c[n][e]] || (o[c[n][e]] = 1)
                    }, this.setTileCost = function(t, n) {
                        o[t] = n
                    }, this.setAdditionalPointCost = function(t, n, e) {
                        void 0 === r[n] && (r[n] = {}), r[n][t] = e
                    }, this.removeAdditionalPointCost = function(t, n) {
                        void 0 !== r[n] && delete r[n][t]
                    }, this.removeAllAdditionalPointCosts = function() {
                        r = {}
                    }, this.setDirectionalCondition = function(t, n, e) {
                        void 0 === l[n] && (l[n] = {}), l[n][t] = e
                    }, this.removeAllDirectionalConditions = function() {
                        l = {}
                    }, this.setIterationsPerCalculation = function(t) {
                        y = t
                    }, this.avoidAdditionalPoint = function(t, n) {
                        void 0 === u[n] && (u[n] = {}), u[n][t] = 1
                    }, this.stopAvoidingAdditionalPoint = function(t, n) {
                        void 0 !== u[n] && delete u[n][t]
                    }, this.enableCornerCutting = function() {
                        a = !0
                    }, this.disableCornerCutting = function() {
                        a = !1
                    }, this.stopAvoidingAllAdditionalPoints = function() {
                        u = {}
                    }, this.findPath = function(t, n, e, o, r) {
                        function i(t) {
                            p ? r(t) : setTimeout(function() {
                                r(t)
                            })
                        }
                        if (void 0 === f) throw new Error("You can't set a path without first calling setAcceptableTiles() on EasyStar.");
                        if (void 0 === c) throw new Error("You can't set a path without first calling setGrid() on EasyStar.");
                        if (t < 0 || n < 0 || e < 0 || o < 0 || t > c[0].length - 1 || n > c.length - 1 || e > c[0].length - 1 || o > c.length - 1) throw new Error("Your start or end point is outside the scope of your grid.");
                        if (t !== e || n !== o) {
                            for (var s = c[o][e], u = !1, l = 0; l < f.length; l++)
                                if (s === f[l]) {
                                    u = !0;
                                    break
                                } if (!1 !== u) {
                                    var a = new M;
                                    a.openList = new A(function(t, n) {
                                        return t.bestGuessDistance() - n.bestGuessDistance()
                                    }), a.isDoneCalculating = !1, a.nodeHash = {}, a.startX = t, a.startY = n, a.endX = e, a.endY = o, a.callback = i, a.openList.push(O(a, a.startX, a.startY, null, 1));
                                    o = E++;
                                    return h[o] = a, d.push(o), o
                                }
                            i(null)
                        } else i([])
                    }, this.cancelPath = function(t) {
                        return t in h && (delete h[t], !0)
                    }, this.calculate = function() {
                        if (0 !== d.length && void 0 !== c && void 0 !== f)
                            for (i = 0; i < y; i++) {
                                if (0 === d.length) return;
                                p && (i = 0);
                                var t = d[0],
                                    n = h[t];
                                if (void 0 !== n)
                                    if (0 !== n.openList.size()) {
                                        var e = n.openList.pop();
                                        if (n.endX !== e.x || n.endY !== e.y) (e.list = 0) < e.y && T(n, e, 0, -1, +b(e.x, e.y - 1)), e.x < c[0].length - 1 && T(n, e, 1, 0, +b(e.x + 1, e.y)), e.y < c.length - 1 && T(n, e, 0, 1, +b(e.x, e.y + 1)), 0 < e.x && T(n, e, -1, 0, +b(e.x - 1, e.y)), v && (0 < e.x && 0 < e.y && (a || g(c, f, e.x, e.y - 1, e) && g(c, f, e.x - 1, e.y, e)) && T(n, e, -1, -1, s * b(e.x - 1, e.y - 1)), e.x < c[0].length - 1 && e.y < c.length - 1 && (a || g(c, f, e.x, e.y + 1, e) && g(c, f, e.x + 1, e.y, e)) && T(n, e, 1, 1, s * b(e.x + 1, e.y + 1)), e.x < c[0].length - 1 && 0 < e.y && (a || g(c, f, e.x, e.y - 1, e) && g(c, f, e.x + 1, e.y, e)) && T(n, e, 1, -1, s * b(e.x + 1, e.y - 1)), 0 < e.x && e.y < c.length - 1 && (a || g(c, f, e.x, e.y + 1, e) && g(c, f, e.x - 1, e.y, e)) && T(n, e, -1, 1, s * b(e.x - 1, e.y + 1)));
                                        else {
                                            var o = [];
                                            o.push({
                                                x: e.x,
                                                y: e.y
                                            });
                                            for (var r = e.parent; null != r;) o.push({
                                                x: r.x,
                                                y: r.y
                                            }), r = r.parent;
                                            o.reverse(), n.callback(o), delete h[t], d.shift()
                                        }
                                    } else n.callback(null), delete h[t], d.shift();
                                else d.shift()
                            }
                    };
                    var T = function(t, n, e, o, r) {
                        e = n.x + e, o = n.y + o;
                        void 0 !== u[o] && void 0 !== u[o][e] || !g(c, f, e, o, n) || (void 0 === (o = O(t, e, o, n, r)).list ? (o.list = 1, t.openList.push(o)) : n.costSoFar + r < o.costSoFar && (o.costSoFar = n.costSoFar + r, o.parent = n, t.openList.updateItem(o)))
                    },
                        g = function(t, n, e, o, r) {
                            var i = l[o] && l[o][e];
                            if (i) {
                                var s = x(r.x - e, r.y - o);
                                if (! function() {
                                    for (var t = 0; t < i.length; t++)
                                        if (i[t] === s) return !0;
                                    return !1
                                }()) return !1
                            }
                            for (var u = 0; u < n.length; u++)
                                if (t[o][e] === n[u]) return !0;
                            return !1
                        },
                        x = function(t, n) {
                            if (0 === t && -1 === n) return P.TOP;
                            if (1 === t && -1 === n) return P.TOP_RIGHT;
                            if (1 === t && 0 === n) return P.RIGHT;
                            if (1 === t && 1 === n) return P.BOTTOM_RIGHT;
                            if (0 === t && 1 === n) return P.BOTTOM;
                            if (-1 === t && 1 === n) return P.BOTTOM_LEFT;
                            if (-1 === t && 0 === n) return P.LEFT;
                            if (-1 === t && -1 === n) return P.TOP_LEFT;
                            throw new Error("These differences are not valid: " + t + ", " + n)
                        },
                        b = function(t, n) {
                            return r[n] && r[n][t] || o[c[n][t]]
                        },
                        O = function(t, n, e, o, r) {
                            if (void 0 !== t.nodeHash[e]) {
                                if (void 0 !== t.nodeHash[e][n]) return t.nodeHash[e][n]
                            } else t.nodeHash[e] = {};
                            var i = m(n, e, t.endX, t.endY),
                                r = null !== o ? o.costSoFar + r : 0,
                                i = new _(o, n, e, r, i);
                            return t.nodeHash[e][n] = i
                        },
                        m = function(t, n, e, o) {
                            var r, i;
                            return v ? (r = Math.abs(t - e)) < (i = Math.abs(n - o)) ? s * r + i : s * i + r : (r = Math.abs(t - e)) + (i = Math.abs(n - o))
                        }
                    }, P.TOP = "TOP", P.TOP_RIGHT = "TOP_RIGHT", P.RIGHT = "RIGHT", P.BOTTOM_RIGHT = "BOTTOM_RIGHT", P.BOTTOM = "BOTTOM", P.BOTTOM_LEFT = "BOTTOM_LEFT", P.LEFT = "LEFT", P.TOP_LEFT = "TOP_LEFT"
            }, function(t, n) {
                t.exports = function() {
                    this.pointsToAvoid = {}, this.startX, this.callback, this.startY, this.endX, this.endY, this.nodeHash = {}, this.openList
                }
            }, function(t, n) {
                t.exports = function(t, n, e, o, r) {
                    this.parent = t, this.x = n, this.y = e, this.costSoFar = o, this.simpleDistanceToTarget = r, this.bestGuessDistance = function() {
                        return this.costSoFar + this.simpleDistanceToTarget
                    }
                }
            }, function(t, n, e) {
                t.exports = e(4)
            }, function(u, T, t) {
                var g, x;
                (function() {
                    var t, p, l, h, d, n, a, e, y, v, o, r, i, c, f;
                    function s(t) {
                        this.cmp = null != t ? t : p, this.nodes = []
                    }
                    l = Math.floor, v = Math.min, p = function(t, n) {
                        return t < n ? -1 : n < t ? 1 : 0
                    }, y = function(t, n, e, o, r) {
                        var i;
                        if (null == e && (e = 0), null == r && (r = p), e < 0) throw new Error("lo must be non-negative");
                        for (null == o && (o = t.length); e < o;) r(n, t[i = l((e + o) / 2)]) < 0 ? o = i : e = i + 1;
                        return [].splice.apply(t, [e, e - e].concat(n)), n
                    }, n = function(t, n, e) {
                        return null == e && (e = p), t.push(n), c(t, 0, t.length - 1, e)
                    }, d = function(t, n) {
                        var e, o;
                        return null == n && (n = p), e = t.pop(), t.length ? (o = t[0], t[0] = e, f(t, 0, n)) : o = e, o
                    }, e = function(t, n, e) {
                        var o;
                        return null == e && (e = p), o = t[0], t[0] = n, f(t, 0, e), o
                    }, a = function(t, n, e) {
                        var o;
                        return null == e && (e = p), t.length && e(t[0], n) < 0 && (n = (o = [t[0], n])[0], t[0] = o[1], f(t, 0, e)), n
                    }, h = function(e, t) {
                        var n, o, r, i, s, u;
                        for (null == t && (t = p), s = [], o = 0, r = (i = function() {
                            u = [];
                            for (var t = 0, n = l(e.length / 2); 0 <= n ? t < n : n < t; 0 <= n ? t++ : t--) u.push(t);
                            return u
                        }.apply(this).reverse()).length; o < r; o++) n = i[o], s.push(f(e, n, t));
                        return s
                    }, i = function(t, n, e) {
                        if (null == e && (e = p), -1 !== (n = t.indexOf(n))) return c(t, 0, n, e), f(t, n, e)
                    }, o = function(t, n, e) {
                        var o, r, i, s, u;
                        if (null == e && (e = p), !(r = t.slice(0, n)).length) return r;
                        for (h(r, e), i = 0, s = (u = t.slice(n)).length; i < s; i++) o = u[i], a(r, o, e);
                        return r.sort(e).reverse()
                    }, r = function(t, n, e) {
                        var o, r, i, s, u, l, a, c, f;
                        if (null == e && (e = p), 10 * n <= t.length) {
                            if (!(i = t.slice(0, n).sort(e)).length) return i;
                            for (r = i[i.length - 1], s = 0, l = (a = t.slice(n)).length; s < l; s++) e(o = a[s], r) < 0 && (y(i, o, 0, null, e), i.pop(), r = i[i.length - 1]);
                            return i
                        }
                        for (h(t, e), f = [], u = 0, c = v(n, t.length); 0 <= c ? u < c : c < u; 0 <= c ? ++u : --u) f.push(d(t, e));
                        return f
                    }, c = function(t, n, e, o) {
                        var r, i, s;
                        for (null == o && (o = p), r = t[e]; n < e && o(r, i = t[s = e - 1 >> 1]) < 0;) t[e] = i, e = s;
                        return t[e] = r
                    }, f = function(t, n, e) {
                        var o, r, i, s, u;
                        for (null == e && (e = p), r = t.length, i = t[u = n], o = 2 * n + 1; o < r;)(s = o + 1) < r && !(e(t[o], t[s]) < 0) && (o = s), t[n] = t[o], o = 2 * (n = o) + 1;
                        return t[n] = i, c(t, u, n, e)
                    }, s.push = n, s.pop = d, s.replace = e, s.pushpop = a, s.heapify = h, s.updateItem = i, s.nlargest = o, s.nsmallest = r, s.prototype.push = function(t) {
                        return n(this.nodes, t, this.cmp)
                    }, s.prototype.pop = function() {
                        return d(this.nodes, this.cmp)
                    }, s.prototype.peek = function() {
                        return this.nodes[0]
                    }, s.prototype.contains = function(t) {
                        return -1 !== this.nodes.indexOf(t)
                    }, s.prototype.replace = function(t) {
                        return e(this.nodes, t, this.cmp)
                    }, s.prototype.pushpop = function(t) {
                        return a(this.nodes, t, this.cmp)
                    }, s.prototype.heapify = function() {
                        return h(this.nodes, this.cmp)
                    }, s.prototype.updateItem = function(t) {
                        return i(this.nodes, t, this.cmp)
                    }, s.prototype.clear = function() {
                        return this.nodes = []
                    }, s.prototype.empty = function() {
                        return 0 === this.nodes.length
                    }, s.prototype.size = function() {
                        return this.nodes.length
                    }, s.prototype.clone = function() {
                        var t = new s;
                        return t.nodes = this.nodes.slice(0), t
                    }, s.prototype.toArray = function() {
                        return this.nodes.slice(0)
                    }, s.prototype.insert = s.prototype.push, s.prototype.top = s.prototype.peek, s.prototype.front = s.prototype.peek, s.prototype.has = s.prototype.contains, s.prototype.copy = s.prototype.clone, t = s, g = [], void 0 === (x = "function" == typeof (x = function() {
                        return t
                    }) ? x.apply(T, g) : x) || (u.exports = x)
                }).call(this)
            }]);
    let easystar = new EasyStar.js();
    let { maxScreenWidth, maxScreenHeight } = config;

    let { moveTo, lineTo } = CanvasRenderingContext2D.prototype;

    CanvasRenderingContext2D.prototype.moveTo = function(x, y) {
        if (this.globalAlpha !== 0.06) {
            return moveTo.call(this, x, y);
        }
    };
    CanvasRenderingContext2D.prototype.lineTo = function(x, y) {
        if (this.globalAlpha !== 0.06) {
            return lineTo.call(this, x, y);
        }
    };

    !function(run) {
        if (!run) return;
        let codes = {
            setup: () => {
                "use strict";
                let newFont = document.createElement("link");
                newFont.rel = "stylesheet";
                newFont.href = "https://fonts.googleapis.com/css?family=Ubuntu:700";
                newFont.type = "text/css";
                document.body.append(newFont);
                !function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var r;r="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,r.msgpack=t()}}(function(){return function t(r,e,n){function i(f,u){if(!e[f]){if(!r[f]){var a="function"==typeof require&&require;if(!u&&a)return a(f,!0);if(o)return o(f,!0);var s=new Error("Cannot find module '"+f+"'");throw s.code="MODULE_NOT_FOUND",s}var c=e[f]={exports:{}};r[f][0].call(c.exports,function(t){var e=r[f][1][t];return i(e?e:t)},c,c.exports,t,r,e,n)}return e[f].exports}for(var o="function"==typeof require&&require,f=0;f<n.length;f++)i(n[f]);return i}({1:[function(t,r,e){e.encode=t("./encode").encode,e.decode=t("./decode").decode,e.Encoder=t("./encoder").Encoder,e.Decoder=t("./decoder").Decoder,e.createCodec=t("./ext").createCodec,e.codec=t("./codec").codec},{"./codec":10,"./decode":12,"./decoder":13,"./encode":15,"./encoder":16,"./ext":20}],2:[function(t,r,e){(function(Buffer){function t(t){return t&&t.isBuffer&&t}r.exports=t("undefined"!=typeof Buffer&&Buffer)||t(this.Buffer)||t("undefined"!=typeof window&&window.Buffer)||this.Buffer}).call(this,t("buffer").Buffer)},{buffer:29}],3:[function(t,r,e){function n(t,r){for(var e=this,n=r||(r|=0),i=t.length,o=0,f=0;f<i;)o=t.charCodeAt(f++),o<128?e[n++]=o:o<2048?(e[n++]=192|o>>>6,e[n++]=128|63&o):o<55296||o>57343?(e[n++]=224|o>>>12,e[n++]=128|o>>>6&63,e[n++]=128|63&o):(o=(o-55296<<10|t.charCodeAt(f++)-56320)+65536,e[n++]=240|o>>>18,e[n++]=128|o>>>12&63,e[n++]=128|o>>>6&63,e[n++]=128|63&o);return n-r}function i(t,r,e){var n=this,i=0|r;e||(e=n.length);for(var o="",f=0;i<e;)f=n[i++],f<128?o+=String.fromCharCode(f):(192===(224&f)?f=(31&f)<<6|63&n[i++]:224===(240&f)?f=(15&f)<<12|(63&n[i++])<<6|63&n[i++]:240===(248&f)&&(f=(7&f)<<18|(63&n[i++])<<12|(63&n[i++])<<6|63&n[i++]),f>=65536?(f-=65536,o+=String.fromCharCode((f>>>10)+55296,(1023&f)+56320)):o+=String.fromCharCode(f));return o}function o(t,r,e,n){var i;e||(e=0),n||0===n||(n=this.length),r||(r=0);var o=n-e;if(t===this&&e<r&&r<n)for(i=o-1;i>=0;i--)t[i+r]=this[i+e];else for(i=0;i<o;i++)t[i+r]=this[i+e];return o}e.copy=o,e.toString=i,e.write=n},{}],4:[function(t,r,e){function n(t){return new Array(t)}function i(t){if(!o.isBuffer(t)&&o.isView(t))t=o.Uint8Array.from(t);else if(o.isArrayBuffer(t))t=new Uint8Array(t);else{if("string"==typeof t)return o.from.call(e,t);if("number"==typeof t)throw new TypeError('"value" argument must not be a number')}return Array.prototype.slice.call(t)}var o=t("./bufferish"),e=r.exports=n(0);e.alloc=n,e.concat=o.concat,e.from=i},{"./bufferish":8}],5:[function(t,r,e){function n(t){return new Buffer(t)}function i(t){if(!o.isBuffer(t)&&o.isView(t))t=o.Uint8Array.from(t);else if(o.isArrayBuffer(t))t=new Uint8Array(t);else{if("string"==typeof t)return o.from.call(e,t);if("number"==typeof t)throw new TypeError('"value" argument must not be a number')}return Buffer.from&&1!==Buffer.from.length?Buffer.from(t):new Buffer(t)}var o=t("./bufferish"),Buffer=o.global,e=r.exports=o.hasBuffer?n(0):[];e.alloc=o.hasBuffer&&Buffer.alloc||n,e.concat=o.concat,e.from=i},{"./bufferish":8}],6:[function(t,r,e){function n(t,r,e,n){var o=a.isBuffer(this),f=a.isBuffer(t);if(o&&f)return this.copy(t,r,e,n);if(c||o||f||!a.isView(this)||!a.isView(t))return u.copy.call(this,t,r,e,n);var s=e||null!=n?i.call(this,e,n):this;return t.set(s,r),s.length}function i(t,r){var e=this.slice||!c&&this.subarray;if(e)return e.call(this,t,r);var i=a.alloc.call(this,r-t);return n.call(this,i,0,t,r),i}function o(t,r,e){var n=!s&&a.isBuffer(this)?this.toString:u.toString;return n.apply(this,arguments)}function f(t){function r(){var r=this[t]||u[t];return r.apply(this,arguments)}return r}var u=t("./buffer-lite");e.copy=n,e.slice=i,e.toString=o,e.write=f("write");var a=t("./bufferish"),Buffer=a.global,s=a.hasBuffer&&"TYPED_ARRAY_SUPPORT"in Buffer,c=s&&!Buffer.TYPED_ARRAY_SUPPORT},{"./buffer-lite":3,"./bufferish":8}],7:[function(t,r,e){function n(t){return new Uint8Array(t)}function i(t){if(o.isView(t)){var r=t.byteOffset,n=t.byteLength;t=t.buffer,t.byteLength!==n&&(t.slice?t=t.slice(r,r+n):(t=new Uint8Array(t),t.byteLength!==n&&(t=Array.prototype.slice.call(t,r,r+n))))}else{if("string"==typeof t)return o.from.call(e,t);if("number"==typeof t)throw new TypeError('"value" argument must not be a number')}return new Uint8Array(t)}var o=t("./bufferish"),e=r.exports=o.hasArrayBuffer?n(0):[];e.alloc=n,e.concat=o.concat,e.from=i},{"./bufferish":8}],8:[function(t,r,e){function n(t){return"string"==typeof t?u.call(this,t):a(this).from(t)}function i(t){return a(this).alloc(t)}function o(t,r){function n(t){r+=t.length}function o(t){a+=w.copy.call(t,u,a)}r||(r=0,Array.prototype.forEach.call(t,n));var f=this!==e&&this||t[0],u=i.call(f,r),a=0;return Array.prototype.forEach.call(t,o),u}function f(t){return t instanceof ArrayBuffer||E(t)}function u(t){var r=3*t.length,e=i.call(this,r),n=w.write.call(e,t);return r!==n&&(e=w.slice.call(e,0,n)),e}function a(t){return d(t)?g:y(t)?b:p(t)?v:h?g:l?b:v}function s(){return!1}function c(t,r){return t="[object "+t+"]",function(e){return null!=e&&{}.toString.call(r?e[r]:e)===t}}var Buffer=e.global=t("./buffer-global"),h=e.hasBuffer=Buffer&&!!Buffer.isBuffer,l=e.hasArrayBuffer="undefined"!=typeof ArrayBuffer,p=e.isArray=t("isarray");e.isArrayBuffer=l?f:s;var d=e.isBuffer=h?Buffer.isBuffer:s,y=e.isView=l?ArrayBuffer.isView||c("ArrayBuffer","buffer"):s;e.alloc=i,e.concat=o,e.from=n;var v=e.Array=t("./bufferish-array"),g=e.Buffer=t("./bufferish-buffer"),b=e.Uint8Array=t("./bufferish-uint8array"),w=e.prototype=t("./bufferish-proto"),E=c("ArrayBuffer")},{"./buffer-global":2,"./bufferish-array":4,"./bufferish-buffer":5,"./bufferish-proto":6,"./bufferish-uint8array":7,isarray:34}],9:[function(t,r,e){function n(t){return this instanceof n?(this.options=t,void this.init()):new n(t)}function i(t){for(var r in t)n.prototype[r]=o(n.prototype[r],t[r])}function o(t,r){function e(){return t.apply(this,arguments),r.apply(this,arguments)}return t&&r?e:t||r}function f(t){function r(t,r){return r(t)}return t=t.slice(),function(e){return t.reduce(r,e)}}function u(t){return s(t)?f(t):t}function a(t){return new n(t)}var s=t("isarray");e.createCodec=a,e.install=i,e.filter=u;var c=t("./bufferish");n.prototype.init=function(){var t=this.options;return t&&t.uint8array&&(this.bufferish=c.Uint8Array),this},e.preset=a({preset:!0})},{"./bufferish":8,isarray:34}],10:[function(t,r,e){t("./read-core"),t("./write-core"),e.codec={preset:t("./codec-base").preset}},{"./codec-base":9,"./read-core":22,"./write-core":25}],11:[function(t,r,e){function n(t){if(!(this instanceof n))return new n(t);if(t&&(this.options=t,t.codec)){var r=this.codec=t.codec;r.bufferish&&(this.bufferish=r.bufferish)}}e.DecodeBuffer=n;var i=t("./read-core").preset,o=t("./flex-buffer").FlexDecoder;o.mixin(n.prototype),n.prototype.codec=i,n.prototype.fetch=function(){return this.codec.decode(this)}},{"./flex-buffer":21,"./read-core":22}],12:[function(t,r,e){function n(t,r){var e=new i(r);return e.write(t),e.read()}e.decode=n;var i=t("./decode-buffer").DecodeBuffer},{"./decode-buffer":11}],13:[function(t,r,e){function n(t){return this instanceof n?void o.call(this,t):new n(t)}e.Decoder=n;var i=t("event-lite"),o=t("./decode-buffer").DecodeBuffer;n.prototype=new o,i.mixin(n.prototype),n.prototype.decode=function(t){arguments.length&&this.write(t),this.flush()},n.prototype.push=function(t){this.emit("data",t)},n.prototype.end=function(t){this.decode(t),this.emit("end")}},{"./decode-buffer":11,"event-lite":31}],14:[function(t,r,e){function n(t){if(!(this instanceof n))return new n(t);if(t&&(this.options=t,t.codec)){var r=this.codec=t.codec;r.bufferish&&(this.bufferish=r.bufferish)}}e.EncodeBuffer=n;var i=t("./write-core").preset,o=t("./flex-buffer").FlexEncoder;o.mixin(n.prototype),n.prototype.codec=i,n.prototype.write=function(t){this.codec.encode(this,t)}},{"./flex-buffer":21,"./write-core":25}],15:[function(t,r,e){function n(t,r){var e=new i(r);return e.write(t),e.read()}e.encode=n;var i=t("./encode-buffer").EncodeBuffer},{"./encode-buffer":14}],16:[function(t,r,e){function n(t){return this instanceof n?void o.call(this,t):new n(t)}e.Encoder=n;var i=t("event-lite"),o=t("./encode-buffer").EncodeBuffer;n.prototype=new o,i.mixin(n.prototype),n.prototype.encode=function(t){this.write(t),this.emit("data",this.read())},n.prototype.end=function(t){arguments.length&&this.encode(t),this.flush(),this.emit("end")}},{"./encode-buffer":14,"event-lite":31}],17:[function(t,r,e){function n(t,r){return this instanceof n?(this.buffer=i.from(t),void(this.type=r)):new n(t,r)}e.ExtBuffer=n;var i=t("./bufferish")},{"./bufferish":8}],18:[function(t,r,e){function n(t){t.addExtPacker(14,Error,[u,i]),t.addExtPacker(1,EvalError,[u,i]),t.addExtPacker(2,RangeError,[u,i]),t.addExtPacker(3,ReferenceError,[u,i]),t.addExtPacker(4,SyntaxError,[u,i]),t.addExtPacker(5,TypeError,[u,i]),t.addExtPacker(6,URIError,[u,i]),t.addExtPacker(10,RegExp,[f,i]),t.addExtPacker(11,Boolean,[o,i]),t.addExtPacker(12,String,[o,i]),t.addExtPacker(13,Date,[Number,i]),t.addExtPacker(15,Number,[o,i]),"undefined"!=typeof Uint8Array&&(t.addExtPacker(17,Int8Array,c),t.addExtPacker(18,Uint8Array,c),t.addExtPacker(19,Int16Array,c),t.addExtPacker(20,Uint16Array,c),t.addExtPacker(21,Int32Array,c),t.addExtPacker(22,Uint32Array,c),t.addExtPacker(23,Float32Array,c),"undefined"!=typeof Float64Array&&t.addExtPacker(24,Float64Array,c),"undefined"!=typeof Uint8ClampedArray&&t.addExtPacker(25,Uint8ClampedArray,c),t.addExtPacker(26,ArrayBuffer,c),t.addExtPacker(29,DataView,c)),s.hasBuffer&&t.addExtPacker(27,Buffer,s.from)}function i(r){return a||(a=t("./encode").encode),a(r)}function o(t){return t.valueOf()}function f(t){t=RegExp.prototype.toString.call(t).split("/"),t.shift();var r=[t.pop()];return r.unshift(t.join("/")),r}function u(t){var r={};for(var e in h)r[e]=t[e];return r}e.setExtPackers=n;var a,s=t("./bufferish"),Buffer=s.global,c=s.Uint8Array.from,h={name:1,message:1,stack:1,columnNumber:1,fileName:1,lineNumber:1}},{"./bufferish":8,"./encode":15}],19:[function(t,r,e){function n(t){t.addExtUnpacker(14,[i,f(Error)]),t.addExtUnpacker(1,[i,f(EvalError)]),t.addExtUnpacker(2,[i,f(RangeError)]),t.addExtUnpacker(3,[i,f(ReferenceError)]),t.addExtUnpacker(4,[i,f(SyntaxError)]),t.addExtUnpacker(5,[i,f(TypeError)]),t.addExtUnpacker(6,[i,f(URIError)]),t.addExtUnpacker(10,[i,o]),t.addExtUnpacker(11,[i,u(Boolean)]),t.addExtUnpacker(12,[i,u(String)]),t.addExtUnpacker(13,[i,u(Date)]),t.addExtUnpacker(15,[i,u(Number)]),"undefined"!=typeof Uint8Array&&(t.addExtUnpacker(17,u(Int8Array)),t.addExtUnpacker(18,u(Uint8Array)),t.addExtUnpacker(19,[a,u(Int16Array)]),t.addExtUnpacker(20,[a,u(Uint16Array)]),t.addExtUnpacker(21,[a,u(Int32Array)]),t.addExtUnpacker(22,[a,u(Uint32Array)]),t.addExtUnpacker(23,[a,u(Float32Array)]),"undefined"!=typeof Float64Array&&t.addExtUnpacker(24,[a,u(Float64Array)]),"undefined"!=typeof Uint8ClampedArray&&t.addExtUnpacker(25,u(Uint8ClampedArray)),t.addExtUnpacker(26,a),t.addExtUnpacker(29,[a,u(DataView)])),c.hasBuffer&&t.addExtUnpacker(27,u(Buffer))}function i(r){return s||(s=t("./decode").decode),s(r)}function o(t){return RegExp.apply(null,t)}function f(t){return function(r){var e=new t;for(var n in h)e[n]=r[n];return e}}function u(t){return function(r){return new t(r)}}function a(t){return new Uint8Array(t).buffer}e.setExtUnpackers=n;var s,c=t("./bufferish"),Buffer=c.global,h={name:1,message:1,stack:1,columnNumber:1,fileName:1,lineNumber:1}},{"./bufferish":8,"./decode":12}],20:[function(t,r,e){t("./read-core"),t("./write-core"),e.createCodec=t("./codec-base").createCodec},{"./codec-base":9,"./read-core":22,"./write-core":25}],21:[function(t,r,e){function n(){if(!(this instanceof n))return new n}function i(){if(!(this instanceof i))return new i}function o(){function t(t){var r=this.offset?p.prototype.slice.call(this.buffer,this.offset):this.buffer;this.buffer=r?t?this.bufferish.concat([r,t]):r:t,this.offset=0}function r(){for(;this.offset<this.buffer.length;){var t,r=this.offset;try{t=this.fetch()}catch(t){if(t&&t.message!=v)throw t;this.offset=r;break}this.push(t)}}function e(t){var r=this.offset,e=r+t;if(e>this.buffer.length)throw new Error(v);return this.offset=e,r}return{bufferish:p,write:t,fetch:a,flush:r,push:c,pull:h,read:s,reserve:e,offset:0}}function f(){function t(){var t=this.start;if(t<this.offset){var r=this.start=this.offset;return p.prototype.slice.call(this.buffer,t,r)}}function r(){for(;this.start<this.offset;){var t=this.fetch();t&&this.push(t)}}function e(){var t=this.buffers||(this.buffers=[]),r=t.length>1?this.bufferish.concat(t):t[0];return t.length=0,r}function n(t){var r=0|t;if(this.buffer){var e=this.buffer.length,n=0|this.offset,i=n+r;if(i<e)return this.offset=i,n;this.flush(),t=Math.max(t,Math.min(2*e,this.maxBufferSize))}return t=Math.max(t,this.minBufferSize),this.buffer=this.bufferish.alloc(t),this.start=0,this.offset=r,0}function i(t){var r=t.length;if(r>this.minBufferSize)this.flush(),this.push(t);else{var e=this.reserve(r);p.prototype.copy.call(t,this.buffer,e)}}return{bufferish:p,write:u,fetch:t,flush:r,push:c,pull:e,read:s,reserve:n,send:i,maxBufferSize:y,minBufferSize:d,offset:0,start:0}}function u(){throw new Error("method not implemented: write()")}function a(){throw new Error("method not implemented: fetch()")}function s(){var t=this.buffers&&this.buffers.length;return t?(this.flush(),this.pull()):this.fetch()}function c(t){var r=this.buffers||(this.buffers=[]);r.push(t)}function h(){var t=this.buffers||(this.buffers=[]);return t.shift()}function l(t){function r(r){for(var e in t)r[e]=t[e];return r}return r}e.FlexDecoder=n,e.FlexEncoder=i;var p=t("./bufferish"),d=2048,y=65536,v="BUFFER_SHORTAGE";n.mixin=l(o()),n.mixin(n.prototype),i.mixin=l(f()),i.mixin(i.prototype)},{"./bufferish":8}],22:[function(t,r,e){function n(t){function r(t){var r=s(t),n=e[r];if(!n)throw new Error("Invalid type: "+(r?"0x"+r.toString(16):r));return n(t)}var e=c.getReadToken(t);return r}function i(){var t=this.options;return this.decode=n(t),t&&t.preset&&a.setExtUnpackers(this),this}function o(t,r){var e=this.extUnpackers||(this.extUnpackers=[]);e[t]=h.filter(r)}function f(t){function r(r){return new u(r,t)}var e=this.extUnpackers||(this.extUnpackers=[]);return e[t]||r}var u=t("./ext-buffer").ExtBuffer,a=t("./ext-unpacker"),s=t("./read-format").readUint8,c=t("./read-token"),h=t("./codec-base");h.install({addExtUnpacker:o,getExtUnpacker:f,init:i}),e.preset=i.call(h.preset)},{"./codec-base":9,"./ext-buffer":17,"./ext-unpacker":19,"./read-format":23,"./read-token":24}],23:[function(t,r,e){function n(t){var r=k.hasArrayBuffer&&t&&t.binarraybuffer,e=t&&t.int64,n=T&&t&&t.usemap,B={map:n?o:i,array:f,str:u,bin:r?s:a,ext:c,uint8:h,uint16:p,uint32:y,uint64:g(8,e?E:b),int8:l,int16:d,int32:v,int64:g(8,e?A:w),float32:g(4,m),float64:g(8,x)};return B}function i(t,r){var e,n={},i=new Array(r),o=new Array(r),f=t.codec.decode;for(e=0;e<r;e++)i[e]=f(t),o[e]=f(t);for(e=0;e<r;e++)n[i[e]]=o[e];return n}function o(t,r){var e,n=new Map,i=new Array(r),o=new Array(r),f=t.codec.decode;for(e=0;e<r;e++)i[e]=f(t),o[e]=f(t);for(e=0;e<r;e++)n.set(i[e],o[e]);return n}function f(t,r){for(var e=new Array(r),n=t.codec.decode,i=0;i<r;i++)e[i]=n(t);return e}function u(t,r){var e=t.reserve(r),n=e+r;return _.toString.call(t.buffer,"utf-8",e,n)}function a(t,r){var e=t.reserve(r),n=e+r,i=_.slice.call(t.buffer,e,n);return k.from(i)}function s(t,r){var e=t.reserve(r),n=e+r,i=_.slice.call(t.buffer,e,n);return k.Uint8Array.from(i).buffer}function c(t,r){var e=t.reserve(r+1),n=t.buffer[e++],i=e+r,o=t.codec.getExtUnpacker(n);if(!o)throw new Error("Invalid ext type: "+(n?"0x"+n.toString(16):n));var f=_.slice.call(t.buffer,e,i);return o(f)}function h(t){var r=t.reserve(1);return t.buffer[r]}function l(t){var r=t.reserve(1),e=t.buffer[r];return 128&e?e-256:e}function p(t){var r=t.reserve(2),e=t.buffer;return e[r++]<<8|e[r]}function d(t){var r=t.reserve(2),e=t.buffer,n=e[r++]<<8|e[r];return 32768&n?n-65536:n}function y(t){var r=t.reserve(4),e=t.buffer;return 16777216*e[r++]+(e[r++]<<16)+(e[r++]<<8)+e[r]}function v(t){var r=t.reserve(4),e=t.buffer;return e[r++]<<24|e[r++]<<16|e[r++]<<8|e[r]}function g(t,r){return function(e){var n=e.reserve(t);return r.call(e.buffer,n,S)}}function b(t){return new P(this,t).toNumber()}function w(t){return new R(this,t).toNumber()}function E(t){return new P(this,t)}function A(t){return new R(this,t)}function m(t){return B.read(this,t,!1,23,4)}function x(t){return B.read(this,t,!1,52,8)}var B=t("ieee754"),U=t("int64-buffer"),P=U.Uint64BE,R=U.Int64BE;e.getReadFormat=n,e.readUint8=h;var k=t("./bufferish"),_=t("./bufferish-proto"),T="undefined"!=typeof Map,S=!0},{"./bufferish":8,"./bufferish-proto":6,ieee754:32,"int64-buffer":33}],24:[function(t,r,e){function n(t){var r=s.getReadFormat(t);return t&&t.useraw?o(r):i(r)}function i(t){var r,e=new Array(256);for(r=0;r<=127;r++)e[r]=f(r);for(r=128;r<=143;r++)e[r]=a(r-128,t.map);for(r=144;r<=159;r++)e[r]=a(r-144,t.array);for(r=160;r<=191;r++)e[r]=a(r-160,t.str);for(e[192]=f(null),e[193]=null,e[194]=f(!1),e[195]=f(!0),e[196]=u(t.uint8,t.bin),e[197]=u(t.uint16,t.bin),e[198]=u(t.uint32,t.bin),e[199]=u(t.uint8,t.ext),e[200]=u(t.uint16,t.ext),e[201]=u(t.uint32,t.ext),e[202]=t.float32,e[203]=t.float64,e[204]=t.uint8,e[205]=t.uint16,e[206]=t.uint32,e[207]=t.uint64,e[208]=t.int8,e[209]=t.int16,e[210]=t.int32,e[211]=t.int64,e[212]=a(1,t.ext),e[213]=a(2,t.ext),e[214]=a(4,t.ext),e[215]=a(8,t.ext),e[216]=a(16,t.ext),e[217]=u(t.uint8,t.str),e[218]=u(t.uint16,t.str),e[219]=u(t.uint32,t.str),e[220]=u(t.uint16,t.array),e[221]=u(t.uint32,t.array),e[222]=u(t.uint16,t.map),e[223]=u(t.uint32,t.map),r=224;r<=255;r++)e[r]=f(r-256);return e}function o(t){var r,e=i(t).slice();for(e[217]=e[196],e[218]=e[197],e[219]=e[198],r=160;r<=191;r++)e[r]=a(r-160,t.bin);return e}function f(t){return function(){return t}}function u(t,r){return function(e){var n=t(e);return r(e,n)}}function a(t,r){return function(e){return r(e,t)}}var s=t("./read-format");e.getReadToken=n},{"./read-format":23}],25:[function(t,r,e){function n(t){function r(t,r){var n=e[typeof r];if(!n)throw new Error('Unsupported type "'+typeof r+'": '+r);n(t,r)}var e=s.getWriteType(t);return r}function i(){var t=this.options;return this.encode=n(t),t&&t.preset&&a.setExtPackers(this),this}function o(t,r,e){function n(r){return e&&(r=e(r)),new u(r,t)}e=c.filter(e);var i=r.name;if(i&&"Object"!==i){var o=this.extPackers||(this.extPackers={});o[i]=n}else{var f=this.extEncoderList||(this.extEncoderList=[]);f.unshift([r,n])}}function f(t){var r=this.extPackers||(this.extPackers={}),e=t.constructor,n=e&&e.name&&r[e.name];if(n)return n;for(var i=this.extEncoderList||(this.extEncoderList=[]),o=i.length,f=0;f<o;f++){var u=i[f];if(e===u[0])return u[1]}}var u=t("./ext-buffer").ExtBuffer,a=t("./ext-packer"),s=t("./write-type"),c=t("./codec-base");c.install({addExtPacker:o,getExtPacker:f,init:i}),e.preset=i.call(c.preset)},{"./codec-base":9,"./ext-buffer":17,"./ext-packer":18,"./write-type":27}],26:[function(t,r,e){function n(t){return t&&t.uint8array?i():m||E.hasBuffer&&t&&t.safe?f():o()}function i(){var t=o();return t[202]=c(202,4,p),t[203]=c(203,8,d),t}function o(){var t=w.slice();return t[196]=u(196),t[197]=a(197),t[198]=s(198),t[199]=u(199),t[200]=a(200),t[201]=s(201),t[202]=c(202,4,x.writeFloatBE||p,!0),t[203]=c(203,8,x.writeDoubleBE||d,!0),t[204]=u(204),t[205]=a(205),t[206]=s(206),t[207]=c(207,8,h),t[208]=u(208),t[209]=a(209),t[210]=s(210),t[211]=c(211,8,l),t[217]=u(217),t[218]=a(218),t[219]=s(219),t[220]=a(220),t[221]=s(221),t[222]=a(222),t[223]=s(223),t}function f(){var t=w.slice();return t[196]=c(196,1,Buffer.prototype.writeUInt8),t[197]=c(197,2,Buffer.prototype.writeUInt16BE),t[198]=c(198,4,Buffer.prototype.writeUInt32BE),t[199]=c(199,1,Buffer.prototype.writeUInt8),t[200]=c(200,2,Buffer.prototype.writeUInt16BE),t[201]=c(201,4,Buffer.prototype.writeUInt32BE),t[202]=c(202,4,Buffer.prototype.writeFloatBE),t[203]=c(203,8,Buffer.prototype.writeDoubleBE),t[204]=c(204,1,Buffer.prototype.writeUInt8),t[205]=c(205,2,Buffer.prototype.writeUInt16BE),t[206]=c(206,4,Buffer.prototype.writeUInt32BE),t[207]=c(207,8,h),t[208]=c(208,1,Buffer.prototype.writeInt8),t[209]=c(209,2,Buffer.prototype.writeInt16BE),t[210]=c(210,4,Buffer.prototype.writeInt32BE),t[211]=c(211,8,l),t[217]=c(217,1,Buffer.prototype.writeUInt8),t[218]=c(218,2,Buffer.prototype.writeUInt16BE),t[219]=c(219,4,Buffer.prototype.writeUInt32BE),t[220]=c(220,2,Buffer.prototype.writeUInt16BE),t[221]=c(221,4,Buffer.prototype.writeUInt32BE),t[222]=c(222,2,Buffer.prototype.writeUInt16BE),t[223]=c(223,4,Buffer.prototype.writeUInt32BE),t}function u(t){return function(r,e){var n=r.reserve(2),i=r.buffer;i[n++]=t,i[n]=e}}function a(t){return function(r,e){var n=r.reserve(3),i=r.buffer;i[n++]=t,i[n++]=e>>>8,i[n]=e}}function s(t){return function(r,e){var n=r.reserve(5),i=r.buffer;i[n++]=t,i[n++]=e>>>24,i[n++]=e>>>16,i[n++]=e>>>8,i[n]=e}}function c(t,r,e,n){return function(i,o){var f=i.reserve(r+1);i.buffer[f++]=t,e.call(i.buffer,o,f,n)}}function h(t,r){new g(this,r,t)}function l(t,r){new b(this,r,t)}function p(t,r){y.write(this,t,r,!1,23,4)}function d(t,r){y.write(this,t,r,!1,52,8)}var y=t("ieee754"),v=t("int64-buffer"),g=v.Uint64BE,b=v.Int64BE,w=t("./write-uint8").uint8,E=t("./bufferish"),Buffer=E.global,A=E.hasBuffer&&"TYPED_ARRAY_SUPPORT"in Buffer,m=A&&!Buffer.TYPED_ARRAY_SUPPORT,x=E.hasBuffer&&Buffer.prototype||{};e.getWriteToken=n},{"./bufferish":8,"./write-uint8":28,ieee754:32,"int64-buffer":33}],27:[function(t,r,e){function n(t){function r(t,r){var e=r?195:194;_[e](t,r)}function e(t,r){var e,n=0|r;return r!==n?(e=203,void _[e](t,r)):(e=-32<=n&&n<=127?255&n:0<=n?n<=255?204:n<=65535?205:206:-128<=n?208:-32768<=n?209:210,void _[e](t,n))}function n(t,r){var e=207;_[e](t,r.toArray())}function o(t,r){var e=211;_[e](t,r.toArray())}function v(t){return t<32?1:t<=255?2:t<=65535?3:5}function g(t){return t<32?1:t<=65535?3:5}function b(t){function r(r,e){var n=e.length,i=5+3*n;r.offset=r.reserve(i);var o=r.buffer,f=t(n),u=r.offset+f;n=s.write.call(o,e,u);var a=t(n);if(f!==a){var c=u+a-f,h=u+n;s.copy.call(o,o,c,u,h)}var l=1===a?160+n:a<=3?215+a:219;_[l](r,n),r.offset+=n}return r}function w(t,r){if(null===r)return A(t,r);if(I(r))return Y(t,r);if(i(r))return m(t,r);if(f.isUint64BE(r))return n(t,r);if(u.isInt64BE(r))return o(t,r);var e=t.codec.getExtPacker(r);return e&&(r=e(r)),r instanceof l?U(t,r):void D(t,r)}function E(t,r){return I(r)?k(t,r):void w(t,r)}function A(t,r){var e=192;_[e](t,r)}function m(t,r){var e=r.length,n=e<16?144+e:e<=65535?220:221;_[n](t,e);for(var i=t.codec.encode,o=0;o<e;o++)i(t,r[o])}function x(t,r){var e=r.length,n=e<255?196:e<=65535?197:198;_[n](t,e),t.send(r)}function B(t,r){x(t,new Uint8Array(r))}function U(t,r){var e=r.buffer,n=e.length,i=y[n]||(n<255?199:n<=65535?200:201);_[i](t,n),h[r.type](t),t.send(e)}function P(t,r){var e=Object.keys(r),n=e.length,i=n<16?128+n:n<=65535?222:223;_[i](t,n);var o=t.codec.encode;e.forEach(function(e){o(t,e),o(t,r[e])})}function R(t,r){if(!(r instanceof Map))return P(t,r);var e=r.size,n=e<16?128+e:e<=65535?222:223;_[n](t,e);var i=t.codec.encode;r.forEach(function(r,e,n){i(t,e),i(t,r)})}function k(t,r){var e=r.length,n=e<32?160+e:e<=65535?218:219;_[n](t,e),t.send(r)}var _=c.getWriteToken(t),T=t&&t.useraw,S=p&&t&&t.binarraybuffer,I=S?a.isArrayBuffer:a.isBuffer,Y=S?B:x,C=d&&t&&t.usemap,D=C?R:P,O={boolean:r,function:A,number:e,object:T?E:w,string:b(T?g:v),symbol:A,undefined:A};return O}var i=t("isarray"),o=t("int64-buffer"),f=o.Uint64BE,u=o.Int64BE,a=t("./bufferish"),s=t("./bufferish-proto"),c=t("./write-token"),h=t("./write-uint8").uint8,l=t("./ext-buffer").ExtBuffer,p="undefined"!=typeof Uint8Array,d="undefined"!=typeof Map,y=[];y[1]=212,y[2]=213,y[4]=214,y[8]=215,y[16]=216,e.getWriteType=n},{"./bufferish":8,"./bufferish-proto":6,"./ext-buffer":17,"./write-token":26,"./write-uint8":28,"int64-buffer":33,isarray:34}],28:[function(t,r,e){function n(t){return function(r){var e=r.reserve(1);r.buffer[e]=t}}for(var i=e.uint8=new Array(256),o=0;o<=255;o++)i[o]=n(o)},{}],29:[function(t,r,e){(function(r){"use strict";function n(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}function i(){return Buffer.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function o(t,r){if(i()<r)throw new RangeError("Invalid typed array length");return Buffer.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(r),t.__proto__=Buffer.prototype):(null===t&&(t=new Buffer(r)),t.length=r),t}function Buffer(t,r,e){if(!(Buffer.TYPED_ARRAY_SUPPORT||this instanceof Buffer))return new Buffer(t,r,e);if("number"==typeof t){if("string"==typeof r)throw new Error("If encoding is specified then the first argument must be a string");return s(this,t)}return f(this,t,r,e)}function f(t,r,e,n){if("number"==typeof r)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&r instanceof ArrayBuffer?l(t,r,e,n):"string"==typeof r?c(t,r,e):p(t,r)}function u(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function a(t,r,e,n){return u(r),r<=0?o(t,r):void 0!==e?"string"==typeof n?o(t,r).fill(e,n):o(t,r).fill(e):o(t,r)}function s(t,r){if(u(r),t=o(t,r<0?0:0|d(r)),!Buffer.TYPED_ARRAY_SUPPORT)for(var e=0;e<r;++e)t[e]=0;return t}function c(t,r,e){if("string"==typeof e&&""!==e||(e="utf8"),!Buffer.isEncoding(e))throw new TypeError('"encoding" must be a valid string encoding');var n=0|v(r,e);t=o(t,n);var i=t.write(r,e);return i!==n&&(t=t.slice(0,i)),t}function h(t,r){var e=r.length<0?0:0|d(r.length);t=o(t,e);for(var n=0;n<e;n+=1)t[n]=255&r[n];return t}function l(t,r,e,n){if(r.byteLength,e<0||r.byteLength<e)throw new RangeError("'offset' is out of bounds");if(r.byteLength<e+(n||0))throw new RangeError("'length' is out of bounds");return r=void 0===e&&void 0===n?new Uint8Array(r):void 0===n?new Uint8Array(r,e):new Uint8Array(r,e,n),Buffer.TYPED_ARRAY_SUPPORT?(t=r,t.__proto__=Buffer.prototype):t=h(t,r),t}function p(t,r){if(Buffer.isBuffer(r)){var e=0|d(r.length);return t=o(t,e),0===t.length?t:(r.copy(t,0,0,e),t)}if(r){if("undefined"!=typeof ArrayBuffer&&r.buffer instanceof ArrayBuffer||"length"in r)return"number"!=typeof r.length||H(r.length)?o(t,0):h(t,r);if("Buffer"===r.type&&Q(r.data))return h(t,r.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function d(t){if(t>=i())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i().toString(16)+" bytes");return 0|t}function y(t){return+t!=t&&(t=0),Buffer.alloc(+t)}function v(t,r){if(Buffer.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var e=t.length;if(0===e)return 0;for(var n=!1;;)switch(r){case"ascii":case"latin1":case"binary":return e;case"utf8":case"utf-8":case void 0:return q(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*e;case"hex":return e>>>1;case"base64":return X(t).length;default:if(n)return q(t).length;r=(""+r).toLowerCase(),n=!0}}function g(t,r,e){var n=!1;if((void 0===r||r<0)&&(r=0),r>this.length)return"";if((void 0===e||e>this.length)&&(e=this.length),e<=0)return"";if(e>>>=0,r>>>=0,e<=r)return"";for(t||(t="utf8");;)switch(t){case"hex":return I(this,r,e);case"utf8":case"utf-8":return k(this,r,e);case"ascii":return T(this,r,e);case"latin1":case"binary":return S(this,r,e);case"base64":return R(this,r,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Y(this,r,e);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function b(t,r,e){var n=t[r];t[r]=t[e],t[e]=n}function w(t,r,e,n,i){if(0===t.length)return-1;if("string"==typeof e?(n=e,e=0):e>2147483647?e=2147483647:e<-2147483648&&(e=-2147483648),e=+e,isNaN(e)&&(e=i?0:t.length-1),e<0&&(e=t.length+e),e>=t.length){if(i)return-1;e=t.length-1}else if(e<0){if(!i)return-1;e=0}if("string"==typeof r&&(r=Buffer.from(r,n)),Buffer.isBuffer(r))return 0===r.length?-1:E(t,r,e,n,i);if("number"==typeof r)return r=255&r,Buffer.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,r,e):Uint8Array.prototype.lastIndexOf.call(t,r,e):E(t,[r],e,n,i);throw new TypeError("val must be string, number or Buffer")}function E(t,r,e,n,i){function o(t,r){return 1===f?t[r]:t.readUInt16BE(r*f)}var f=1,u=t.length,a=r.length;if(void 0!==n&&(n=String(n).toLowerCase(),"ucs2"===n||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||r.length<2)return-1;f=2,u/=2,a/=2,e/=2}var s;if(i){var c=-1;for(s=e;s<u;s++)if(o(t,s)===o(r,c===-1?0:s-c)){if(c===-1&&(c=s),s-c+1===a)return c*f}else c!==-1&&(s-=s-c),c=-1}else for(e+a>u&&(e=u-a),s=e;s>=0;s--){for(var h=!0,l=0;l<a;l++)if(o(t,s+l)!==o(r,l)){h=!1;break}if(h)return s}return-1}function A(t,r,e,n){e=Number(e)||0;var i=t.length-e;n?(n=Number(n),n>i&&(n=i)):n=i;var o=r.length;if(o%2!==0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var f=0;f<n;++f){var u=parseInt(r.substr(2*f,2),16);if(isNaN(u))return f;t[e+f]=u}return f}function m(t,r,e,n){return G(q(r,t.length-e),t,e,n)}function x(t,r,e,n){return G(W(r),t,e,n)}function B(t,r,e,n){return x(t,r,e,n)}function U(t,r,e,n){return G(X(r),t,e,n)}function P(t,r,e,n){return G(J(r,t.length-e),t,e,n)}function R(t,r,e){return 0===r&&e===t.length?Z.fromByteArray(t):Z.fromByteArray(t.slice(r,e))}function k(t,r,e){e=Math.min(t.length,e);for(var n=[],i=r;i<e;){var o=t[i],f=null,u=o>239?4:o>223?3:o>191?2:1;if(i+u<=e){var a,s,c,h;switch(u){case 1:o<128&&(f=o);break;case 2:a=t[i+1],128===(192&a)&&(h=(31&o)<<6|63&a,h>127&&(f=h));break;case 3:a=t[i+1],s=t[i+2],128===(192&a)&&128===(192&s)&&(h=(15&o)<<12|(63&a)<<6|63&s,h>2047&&(h<55296||h>57343)&&(f=h));break;case 4:a=t[i+1],s=t[i+2],c=t[i+3],128===(192&a)&&128===(192&s)&&128===(192&c)&&(h=(15&o)<<18|(63&a)<<12|(63&s)<<6|63&c,h>65535&&h<1114112&&(f=h))}}null===f?(f=65533,u=1):f>65535&&(f-=65536,n.push(f>>>10&1023|55296),f=56320|1023&f),n.push(f),i+=u}return _(n)}function _(t){var r=t.length;if(r<=$)return String.fromCharCode.apply(String,t);for(var e="",n=0;n<r;)e+=String.fromCharCode.apply(String,t.slice(n,n+=$));return e}function T(t,r,e){var n="";e=Math.min(t.length,e);for(var i=r;i<e;++i)n+=String.fromCharCode(127&t[i]);return n}function S(t,r,e){var n="";e=Math.min(t.length,e);for(var i=r;i<e;++i)n+=String.fromCharCode(t[i]);return n}function I(t,r,e){var n=t.length;(!r||r<0)&&(r=0),(!e||e<0||e>n)&&(e=n);for(var i="",o=r;o<e;++o)i+=V(t[o]);return i}function Y(t,r,e){for(var n=t.slice(r,e),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function C(t,r,e){if(t%1!==0||t<0)throw new RangeError("offset is not uint");if(t+r>e)throw new RangeError("Trying to access beyond buffer length")}function D(t,r,e,n,i,o){if(!Buffer.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(r>i||r<o)throw new RangeError('"value" argument is out of bounds');if(e+n>t.length)throw new RangeError("Index out of range")}function O(t,r,e,n){r<0&&(r=65535+r+1);for(var i=0,o=Math.min(t.length-e,2);i<o;++i)t[e+i]=(r&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function L(t,r,e,n){r<0&&(r=4294967295+r+1);for(var i=0,o=Math.min(t.length-e,4);i<o;++i)t[e+i]=r>>>8*(n?i:3-i)&255}function M(t,r,e,n,i,o){if(e+n>t.length)throw new RangeError("Index out of range");if(e<0)throw new RangeError("Index out of range")}function N(t,r,e,n,i){return i||M(t,r,e,4,3.4028234663852886e38,-3.4028234663852886e38),K.write(t,r,e,n,23,4),e+4}function F(t,r,e,n,i){return i||M(t,r,e,8,1.7976931348623157e308,-1.7976931348623157e308),K.write(t,r,e,n,52,8),e+8}function j(t){if(t=z(t).replace(tt,""),t.length<2)return"";for(;t.length%4!==0;)t+="=";return t}function z(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}function V(t){return t<16?"0"+t.toString(16):t.toString(16)}function q(t,r){r=r||1/0;for(var e,n=t.length,i=null,o=[],f=0;f<n;++f){if(e=t.charCodeAt(f),e>55295&&e<57344){if(!i){if(e>56319){(r-=3)>-1&&o.push(239,191,189);continue}if(f+1===n){(r-=3)>-1&&o.push(239,191,189);continue}i=e;continue}if(e<56320){(r-=3)>-1&&o.push(239,191,189),i=e;continue}e=(i-55296<<10|e-56320)+65536}else i&&(r-=3)>-1&&o.push(239,191,189);if(i=null,e<128){if((r-=1)<0)break;o.push(e)}else if(e<2048){if((r-=2)<0)break;o.push(e>>6|192,63&e|128)}else if(e<65536){if((r-=3)<0)break;o.push(e>>12|224,e>>6&63|128,63&e|128)}else{if(!(e<1114112))throw new Error("Invalid code point");if((r-=4)<0)break;o.push(e>>18|240,e>>12&63|128,e>>6&63|128,63&e|128)}}return o}function W(t){for(var r=[],e=0;e<t.length;++e)r.push(255&t.charCodeAt(e));return r}function J(t,r){for(var e,n,i,o=[],f=0;f<t.length&&!((r-=2)<0);++f)e=t.charCodeAt(f),n=e>>8,i=e%256,o.push(i),o.push(n);return o}function X(t){return Z.toByteArray(j(t))}function G(t,r,e,n){for(var i=0;i<n&&!(i+e>=r.length||i>=t.length);++i)r[i+e]=t[i];return i}function H(t){return t!==t}var Z=t("base64-js"),K=t("ieee754"),Q=t("isarray");e.Buffer=Buffer,e.SlowBuffer=y,e.INSPECT_MAX_BYTES=50,Buffer.TYPED_ARRAY_SUPPORT=void 0!==r.TYPED_ARRAY_SUPPORT?r.TYPED_ARRAY_SUPPORT:n(),e.kMaxLength=i(),Buffer.poolSize=8192,Buffer._augment=function(t){return t.__proto__=Buffer.prototype,t},Buffer.from=function(t,r,e){return f(null,t,r,e)},Buffer.TYPED_ARRAY_SUPPORT&&(Buffer.prototype.__proto__=Uint8Array.prototype,Buffer.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&Buffer[Symbol.species]===Buffer&&Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:!0})),Buffer.alloc=function(t,r,e){return a(null,t,r,e)},Buffer.allocUnsafe=function(t){return s(null,t)},Buffer.allocUnsafeSlow=function(t){return s(null,t)},Buffer.isBuffer=function(t){return!(null==t||!t._isBuffer)},Buffer.compare=function(t,r){if(!Buffer.isBuffer(t)||!Buffer.isBuffer(r))throw new TypeError("Arguments must be Buffers");if(t===r)return 0;for(var e=t.length,n=r.length,i=0,o=Math.min(e,n);i<o;++i)if(t[i]!==r[i]){e=t[i],n=r[i];break}return e<n?-1:n<e?1:0},Buffer.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer.concat=function(t,r){if(!Q(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return Buffer.alloc(0);var e;if(void 0===r)for(r=0,e=0;e<t.length;++e)r+=t[e].length;var n=Buffer.allocUnsafe(r),i=0;for(e=0;e<t.length;++e){var o=t[e];if(!Buffer.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,i),i+=o.length}return n},Buffer.byteLength=v,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function(){var t=this.length;if(t%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var r=0;r<t;r+=2)b(this,r,r+1);return this},Buffer.prototype.swap32=function(){var t=this.length;if(t%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var r=0;r<t;r+=4)b(this,r,r+3),b(this,r+1,r+2);return this},Buffer.prototype.swap64=function(){var t=this.length;if(t%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var r=0;r<t;r+=8)b(this,r,r+7),b(this,r+1,r+6),b(this,r+2,r+5),b(this,r+3,r+4);return this},Buffer.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?k(this,0,t):g.apply(this,arguments)},Buffer.prototype.equals=function(t){if(!Buffer.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===Buffer.compare(this,t)},Buffer.prototype.inspect=function(){var t="",r=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(t+=" ... ")),"<Buffer "+t+">"},Buffer.prototype.compare=function(t,r,e,n,i){if(!Buffer.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===r&&(r=0),void 0===e&&(e=t?t.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),r<0||e>t.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&r>=e)return 0;if(n>=i)return-1;if(r>=e)return 1;if(r>>>=0,e>>>=0,n>>>=0,i>>>=0,this===t)return 0;for(var o=i-n,f=e-r,u=Math.min(o,f),a=this.slice(n,i),s=t.slice(r,e),c=0;c<u;++c)if(a[c]!==s[c]){o=a[c],f=s[c];break}return o<f?-1:f<o?1:0},Buffer.prototype.includes=function(t,r,e){return this.indexOf(t,r,e)!==-1},Buffer.prototype.indexOf=function(t,r,e){return w(this,t,r,e,!0)},Buffer.prototype.lastIndexOf=function(t,r,e){return w(this,t,r,e,!1)},Buffer.prototype.write=function(t,r,e,n){if(void 0===r)n="utf8",e=this.length,r=0;else if(void 0===e&&"string"==typeof r)n=r,e=this.length,r=0;else{if(!isFinite(r))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");r=0|r,isFinite(e)?(e=0|e,void 0===n&&(n="utf8")):(n=e,e=void 0)}var i=this.length-r;if((void 0===e||e>i)&&(e=i),t.length>0&&(e<0||r<0)||r>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return A(this,t,r,e);case"utf8":case"utf-8":return m(this,t,r,e);case"ascii":return x(this,t,r,e);case"latin1":case"binary":return B(this,t,r,e);case"base64":return U(this,t,r,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return P(this,t,r,e);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var $=4096;Buffer.prototype.slice=function(t,r){var e=this.length;t=~~t,r=void 0===r?e:~~r,t<0?(t+=e,t<0&&(t=0)):t>e&&(t=e),r<0?(r+=e,r<0&&(r=0)):r>e&&(r=e),r<t&&(r=t);var n;if(Buffer.TYPED_ARRAY_SUPPORT)n=this.subarray(t,r),n.__proto__=Buffer.prototype;else{var i=r-t;n=new Buffer(i,void 0);for(var o=0;o<i;++o)n[o]=this[o+t]}return n},Buffer.prototype.readUIntLE=function(t,r,e){t=0|t,r=0|r,e||C(t,r,this.length);for(var n=this[t],i=1,o=0;++o<r&&(i*=256);)n+=this[t+o]*i;return n},Buffer.prototype.readUIntBE=function(t,r,e){t=0|t,r=0|r,e||C(t,r,this.length);for(var n=this[t+--r],i=1;r>0&&(i*=256);)n+=this[t+--r]*i;return n},Buffer.prototype.readUInt8=function(t,r){return r||C(t,1,this.length),this[t]},Buffer.prototype.readUInt16LE=function(t,r){return r||C(t,2,this.length),this[t]|this[t+1]<<8},Buffer.prototype.readUInt16BE=function(t,r){return r||C(t,2,this.length),this[t]<<8|this[t+1]},Buffer.prototype.readUInt32LE=function(t,r){return r||C(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},Buffer.prototype.readUInt32BE=function(t,r){return r||C(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},Buffer.prototype.readIntLE=function(t,r,e){t=0|t,r=0|r,e||C(t,r,this.length);for(var n=this[t],i=1,o=0;++o<r&&(i*=256);)n+=this[t+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*r)),n},Buffer.prototype.readIntBE=function(t,r,e){t=0|t,r=0|r,e||C(t,r,this.length);for(var n=r,i=1,o=this[t+--n];n>0&&(i*=256);)o+=this[t+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*r)),o},Buffer.prototype.readInt8=function(t,r){return r||C(t,1,this.length),128&this[t]?(255-this[t]+1)*-1:this[t]},Buffer.prototype.readInt16LE=function(t,r){r||C(t,2,this.length);var e=this[t]|this[t+1]<<8;return 32768&e?4294901760|e:e},Buffer.prototype.readInt16BE=function(t,r){r||C(t,2,this.length);var e=this[t+1]|this[t]<<8;return 32768&e?4294901760|e:e},Buffer.prototype.readInt32LE=function(t,r){return r||C(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},Buffer.prototype.readInt32BE=function(t,r){return r||C(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},Buffer.prototype.readFloatLE=function(t,r){return r||C(t,4,this.length),K.read(this,t,!0,23,4)},Buffer.prototype.readFloatBE=function(t,r){return r||C(t,4,this.length),K.read(this,t,!1,23,4)},Buffer.prototype.readDoubleLE=function(t,r){return r||C(t,8,this.length),K.read(this,t,!0,52,8)},Buffer.prototype.readDoubleBE=function(t,r){return r||C(t,8,this.length),K.read(this,t,!1,52,8)},Buffer.prototype.writeUIntLE=function(t,r,e,n){if(t=+t,r=0|r,e=0|e,!n){var i=Math.pow(2,8*e)-1;D(this,t,r,e,i,0)}var o=1,f=0;for(this[r]=255&t;++f<e&&(o*=256);)this[r+f]=t/o&255;return r+e},Buffer.prototype.writeUIntBE=function(t,r,e,n){if(t=+t,r=0|r,e=0|e,!n){var i=Math.pow(2,8*e)-1;D(this,t,r,e,i,0)}var o=e-1,f=1;for(this[r+o]=255&t;--o>=0&&(f*=256);)this[r+o]=t/f&255;return r+e},Buffer.prototype.writeUInt8=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,1,255,0),Buffer.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[r]=255&t,r+1},Buffer.prototype.writeUInt16LE=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,2,65535,0),Buffer.TYPED_ARRAY_SUPPORT?(this[r]=255&t,this[r+1]=t>>>8):O(this,t,r,!0),r+2},Buffer.prototype.writeUInt16BE=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,2,65535,0),Buffer.TYPED_ARRAY_SUPPORT?(this[r]=t>>>8,this[r+1]=255&t):O(this,t,r,!1),r+2},Buffer.prototype.writeUInt32LE=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,4,4294967295,0),Buffer.TYPED_ARRAY_SUPPORT?(this[r+3]=t>>>24,this[r+2]=t>>>16,this[r+1]=t>>>8,this[r]=255&t):L(this,t,r,!0),r+4},Buffer.prototype.writeUInt32BE=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,4,4294967295,0),Buffer.TYPED_ARRAY_SUPPORT?(this[r]=t>>>24,this[r+1]=t>>>16,this[r+2]=t>>>8,this[r+3]=255&t):L(this,t,r,!1),r+4},Buffer.prototype.writeIntLE=function(t,r,e,n){if(t=+t,r=0|r,!n){var i=Math.pow(2,8*e-1);D(this,t,r,e,i-1,-i)}var o=0,f=1,u=0;for(this[r]=255&t;++o<e&&(f*=256);)t<0&&0===u&&0!==this[r+o-1]&&(u=1),this[r+o]=(t/f>>0)-u&255;return r+e},Buffer.prototype.writeIntBE=function(t,r,e,n){if(t=+t,r=0|r,!n){var i=Math.pow(2,8*e-1);D(this,t,r,e,i-1,-i)}var o=e-1,f=1,u=0;for(this[r+o]=255&t;--o>=0&&(f*=256);)t<0&&0===u&&0!==this[r+o+1]&&(u=1),this[r+o]=(t/f>>0)-u&255;return r+e},Buffer.prototype.writeInt8=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,1,127,-128),Buffer.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[r]=255&t,r+1},Buffer.prototype.writeInt16LE=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,2,32767,-32768),Buffer.TYPED_ARRAY_SUPPORT?(this[r]=255&t,this[r+1]=t>>>8):O(this,t,r,!0),r+2},Buffer.prototype.writeInt16BE=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,2,32767,-32768),Buffer.TYPED_ARRAY_SUPPORT?(this[r]=t>>>8,this[r+1]=255&t):O(this,t,r,!1),r+2},Buffer.prototype.writeInt32LE=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,4,2147483647,-2147483648),Buffer.TYPED_ARRAY_SUPPORT?(this[r]=255&t,this[r+1]=t>>>8,this[r+2]=t>>>16,this[r+3]=t>>>24):L(this,t,r,!0),r+4},Buffer.prototype.writeInt32BE=function(t,r,e){return t=+t,r=0|r,e||D(this,t,r,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),Buffer.TYPED_ARRAY_SUPPORT?(this[r]=t>>>24,this[r+1]=t>>>16,this[r+2]=t>>>8,this[r+3]=255&t):L(this,t,r,!1),r+4},Buffer.prototype.writeFloatLE=function(t,r,e){return N(this,t,r,!0,e)},Buffer.prototype.writeFloatBE=function(t,r,e){return N(this,t,r,!1,e)},Buffer.prototype.writeDoubleLE=function(t,r,e){return F(this,t,r,!0,e)},Buffer.prototype.writeDoubleBE=function(t,r,e){return F(this,t,r,!1,e)},Buffer.prototype.copy=function(t,r,e,n){if(e||(e=0),n||0===n||(n=this.length),r>=t.length&&(r=t.length),r||(r=0),n>0&&n<e&&(n=e),n===e)return 0;if(0===t.length||0===this.length)return 0;if(r<0)throw new RangeError("targetStart out of bounds");if(e<0||e>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-r<n-e&&(n=t.length-r+e);var i,o=n-e;if(this===t&&e<r&&r<n)for(i=o-1;i>=0;--i)t[i+r]=this[i+e];else if(o<1e3||!Buffer.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)t[i+r]=this[i+e];else Uint8Array.prototype.set.call(t,this.subarray(e,e+o),r);return o},Buffer.prototype.fill=function(t,r,e,n){if("string"==typeof t){if("string"==typeof r?(n=r,r=0,e=this.length):"string"==typeof e&&(n=e,e=this.length),1===t.length){var i=t.charCodeAt(0);i<256&&(t=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!Buffer.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof t&&(t=255&t);if(r<0||this.length<r||this.length<e)throw new RangeError("Out of range index");if(e<=r)return this;r>>>=0,e=void 0===e?this.length:e>>>0,t||(t=0);var o;if("number"==typeof t)for(o=r;o<e;++o)this[o]=t;else{var f=Buffer.isBuffer(t)?t:q(new Buffer(t,n).toString()),u=f.length;for(o=0;o<e-r;++o)this[o+r]=f[o%u]}return this};var tt=/[^+\/0-9A-Za-z-_]/g}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"base64-js":30,ieee754:32,isarray:34}],30:[function(t,r,e){"use strict";function n(t){var r=t.length;if(r%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===t[r-2]?2:"="===t[r-1]?1:0}function i(t){return 3*t.length/4-n(t)}function o(t){var r,e,i,o,f,u,a=t.length;f=n(t),u=new h(3*a/4-f),i=f>0?a-4:a;var s=0;for(r=0,e=0;r<i;r+=4,e+=3)o=c[t.charCodeAt(r)]<<18|c[t.charCodeAt(r+1)]<<12|c[t.charCodeAt(r+2)]<<6|c[t.charCodeAt(r+3)],u[s++]=o>>16&255,u[s++]=o>>8&255,u[s++]=255&o;return 2===f?(o=c[t.charCodeAt(r)]<<2|c[t.charCodeAt(r+1)]>>4,u[s++]=255&o):1===f&&(o=c[t.charCodeAt(r)]<<10|c[t.charCodeAt(r+1)]<<4|c[t.charCodeAt(r+2)]>>2,u[s++]=o>>8&255,u[s++]=255&o),u}function f(t){return s[t>>18&63]+s[t>>12&63]+s[t>>6&63]+s[63&t]}function u(t,r,e){for(var n,i=[],o=r;o<e;o+=3)n=(t[o]<<16)+(t[o+1]<<8)+t[o+2],i.push(f(n));return i.join("")}function a(t){for(var r,e=t.length,n=e%3,i="",o=[],f=16383,a=0,c=e-n;a<c;a+=f)o.push(u(t,a,a+f>c?c:a+f));return 1===n?(r=t[e-1],i+=s[r>>2],i+=s[r<<4&63],i+="=="):2===n&&(r=(t[e-2]<<8)+t[e-1],i+=s[r>>10],i+=s[r>>4&63],i+=s[r<<2&63],i+="="),o.push(i),o.join("")}e.byteLength=i,e.toByteArray=o,e.fromByteArray=a;for(var s=[],c=[],h="undefined"!=typeof Uint8Array?Uint8Array:Array,l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",p=0,d=l.length;p<d;++p)s[p]=l[p],c[l.charCodeAt(p)]=p;c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63},{}],31:[function(t,r,e){function n(){if(!(this instanceof n))return new n}!function(t){function e(t){for(var r in s)t[r]=s[r];return t}function n(t,r){return u(this,t).push(r),this}function i(t,r){function e(){o.call(n,t,e),r.apply(this,arguments)}var n=this;return e.originalListener=r,u(n,t).push(e),n}function o(t,r){function e(t){return t!==r&&t.originalListener!==r}var n,i=this;if(arguments.length){if(r){if(n=u(i,t,!0)){if(n=n.filter(e),!n.length)return o.call(i,t);i[a][t]=n}}else if(n=i[a],n&&(delete n[t],!Object.keys(n).length))return o.call(i)}else delete i[a];return i}function f(t,r){function e(t){t.call(o)}function n(t){t.call(o,r)}function i(t){t.apply(o,s)}var o=this,f=u(o,t,!0);if(!f)return!1;var a=arguments.length;if(1===a)f.forEach(e);else if(2===a)f.forEach(n);else{var s=Array.prototype.slice.call(arguments,1);f.forEach(i)}return!!f.length}function u(t,r,e){if(!e||t[a]){var n=t[a]||(t[a]={});return n[r]||(n[r]=[])}}"undefined"!=typeof r&&(r.exports=t);var a="listeners",s={on:n,once:i,off:o,emit:f};e(t.prototype),t.mixin=e}(n)},{}],32:[function(t,r,e){e.read=function(t,r,e,n,i){var o,f,u=8*i-n-1,a=(1<<u)-1,s=a>>1,c=-7,h=e?i-1:0,l=e?-1:1,p=t[r+h];for(h+=l,o=p&(1<<-c)-1,p>>=-c,c+=u;c>0;o=256*o+t[r+h],h+=l,c-=8);for(f=o&(1<<-c)-1,o>>=-c,c+=n;c>0;f=256*f+t[r+h],h+=l,c-=8);if(0===o)o=1-s;else{if(o===a)return f?NaN:(p?-1:1)*(1/0);f+=Math.pow(2,n),o-=s}return(p?-1:1)*f*Math.pow(2,o-n)},e.write=function(t,r,e,n,i,o){var f,u,a,s=8*o-i-1,c=(1<<s)-1,h=c>>1,l=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:o-1,d=n?1:-1,y=r<0||0===r&&1/r<0?1:0;for(r=Math.abs(r),isNaN(r)||r===1/0?(u=isNaN(r)?1:0,f=c):(f=Math.floor(Math.log(r)/Math.LN2),r*(a=Math.pow(2,-f))<1&&(f--,a*=2),r+=f+h>=1?l/a:l*Math.pow(2,1-h),r*a>=2&&(f++,a/=2),f+h>=c?(u=0,f=c):f+h>=1?(u=(r*a-1)*Math.pow(2,i),f+=h):(u=r*Math.pow(2,h-1)*Math.pow(2,i),f=0));i>=8;t[e+p]=255&u,p+=d,u/=256,i-=8);for(f=f<<i|u,s+=i;s>0;t[e+p]=255&f,p+=d,f/=256,s-=8);t[e+p-d]|=128*y}},{}],33:[function(t,r,e){(function(Buffer){var t,r,n,i;!function(e){function o(t,r,n){function i(t,r,e,n){return this instanceof i?v(this,t,r,e,n):new i(t,r,e,n)}function o(t){return!(!t||!t[F])}function v(t,r,e,n,i){if(E&&A&&(r instanceof A&&(r=new E(r)),n instanceof A&&(n=new E(n))),!(r||e||n||g))return void(t.buffer=h(m,0));if(!s(r,e)){var o=g||Array;i=e,n=r,e=0,r=new o(8)}t.buffer=r,t.offset=e|=0,b!==typeof n&&("string"==typeof n?x(r,e,n,i||10):s(n,i)?c(r,e,n,i):"number"==typeof i?(k(r,e+T,n),k(r,e+S,i)):n>0?O(r,e,n):n<0?L(r,e,n):c(r,e,m,0))}function x(t,r,e,n){var i=0,o=e.length,f=0,u=0;"-"===e[0]&&i++;for(var a=i;i<o;){var s=parseInt(e[i++],n);if(!(s>=0))break;u=u*n+s,f=f*n+Math.floor(u/B),u%=B}a&&(f=~f,u?u=B-u:f++),k(t,r+T,f),k(t,r+S,u)}function P(){var t=this.buffer,r=this.offset,e=_(t,r+T),i=_(t,r+S);return n||(e|=0),e?e*B+i:i}function R(t){var r=this.buffer,e=this.offset,i=_(r,e+T),o=_(r,e+S),f="",u=!n&&2147483648&i;for(u&&(i=~i,o=B-o),t=t||10;;){var a=i%t*B+o;if(i=Math.floor(i/t),o=Math.floor(a/t),f=(a%t).toString(t)+f,!i&&!o)break}return u&&(f="-"+f),f}function k(t,r,e){t[r+D]=255&e,e>>=8,t[r+C]=255&e,e>>=8,t[r+Y]=255&e,e>>=8,t[r+I]=255&e}function _(t,r){return t[r+I]*U+(t[r+Y]<<16)+(t[r+C]<<8)+t[r+D]}var T=r?0:4,S=r?4:0,I=r?0:3,Y=r?1:2,C=r?2:1,D=r?3:0,O=r?l:d,L=r?p:y,M=i.prototype,N="is"+t,F="_"+N;return M.buffer=void 0,M.offset=0,M[F]=!0,M.toNumber=P,M.toString=R,M.toJSON=P,M.toArray=f,w&&(M.toBuffer=u),E&&(M.toArrayBuffer=a),i[N]=o,e[t]=i,i}function f(t){var r=this.buffer,e=this.offset;return g=null,t!==!1&&0===e&&8===r.length&&x(r)?r:h(r,e)}function u(t){var r=this.buffer,e=this.offset;if(g=w,t!==!1&&0===e&&8===r.length&&Buffer.isBuffer(r))return r;var n=new w(8);return c(n,0,r,e),n}function a(t){var r=this.buffer,e=this.offset,n=r.buffer;if(g=E,t!==!1&&0===e&&n instanceof A&&8===n.byteLength)return n;var i=new E(8);return c(i,0,r,e),i.buffer}function s(t,r){var e=t&&t.length;return r|=0,e&&r+8<=e&&"string"!=typeof t[r]}function c(t,r,e,n){r|=0,n|=0;for(var i=0;i<8;i++)t[r++]=255&e[n++]}function h(t,r){return Array.prototype.slice.call(t,r,r+8)}function l(t,r,e){for(var n=r+8;n>r;)t[--n]=255&e,e/=256}function p(t,r,e){var n=r+8;for(e++;n>r;)t[--n]=255&-e^255,e/=256}function d(t,r,e){for(var n=r+8;r<n;)t[r++]=255&e,e/=256}function y(t,r,e){var n=r+8;for(e++;r<n;)t[r++]=255&-e^255,e/=256}function v(t){return!!t&&"[object Array]"==Object.prototype.toString.call(t)}var g,b="undefined",w=b!==typeof Buffer&&Buffer,E=b!==typeof Uint8Array&&Uint8Array,A=b!==typeof ArrayBuffer&&ArrayBuffer,m=[0,0,0,0,0,0,0,0],x=Array.isArray||v,B=4294967296,U=16777216;t=o("Uint64BE",!0,!0),r=o("Int64BE",!0,!1),n=o("Uint64LE",!1,!0),i=o("Int64LE",!1,!1)}("object"==typeof e&&"string"!=typeof e.nodeName?e:this||{})}).call(this,t("buffer").Buffer)},{buffer:29}],34:[function(t,r,e){var n={}.toString;r.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},{}]},{},[1])(1)});
                console.log({msgpack})
                unsafeWindow.msgpack=msgpack
                document.msgpack=msgpack
            },
            main: (entry,token,payload) => {
                //"use strict";
                _genWss=function(token){
                    let WS = new WebSocket(wssUrl);
                    WS.binaryType = "arraybuffer";
                    WS.addEventListener("message", function (msg) {
                        getMessage(msg);
                    });
                    WS.addEventListener("close", (event) => {
                        if (event.code == 4001) {
                            window.location.reload();
                        }
                    });
                    // Optionally do something on open:
                    WS.addEventListener("open", () => {
                        WS.opened=true
                        console.log("🎉 Connected to", wssUrl);
                    });
                    return WS
                }
                const baseDomain = pn;  // e.g. "moomoo.io"

                // exactly what ze.prototype.serverAddress would return:
                const host = region === "0"
                ? "localhost"
                : `${entry.key}.${region}.${baseDomain}`;  // e.g. "sgs-jzrcj-qfgfl.miami.moomoo.io"

                const wssUrl =
                      `wss://${host}/` +
                      `?token=${encodeURIComponent(adAlt + token)}`;
                console.log({wssUrl})
                unsafeWindow.oncontextmenu = function() {
                    return false;
                };
                let cfig=top.config
                let config = unsafeWindow.config;
                console.log({config,wconfig:config})
                autoRubyOnSpawn=name=='bot'

                // CLIENT:
                config.clientSendRate = 0; // Aim Packet Send Rate
                config.serverUpdateRate = 9;
                // UI:
                config.deathFadeout = 0;
                // CHECK IN SANDBOX:
                config.isSandbox = unsafeWindow.location.hostname == "sandbox.moomoo.io";
                // CUSTOMIZATION:
                config.skinColors = ["#bf8f54", "#cbb091", "#896c4b",
                                     "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3",
                                     "#8bc373", "#91b2db"
                                    ];
                config.weaponVariants = [
                    {
                        id: 0,
                        src: "",
                        xp: 0,
                        val: 1,
                    }, {
                        id: 1,
                        src: "_g",
                        xp: 3000,
                        val: 1.1,
                    }, {
                        id: 2,
                        src: "_d",
                        xp: 7000,
                        val: 1.18,
                    }, {
                        id: 3,
                        src: "_r",
                        poison: true,
                        xp: 12000,
                        val: 1.18,
                    }, {
                        id: 4,
                        src: "_e",
                        poison: true,
                        heal: true,
                        xp: 24000,
                        val: 1.18,
                    }];

                // VISUAL:
                config.anotherVisual = true;
                config.useWebGl = false;
                config.resetRender = false;

                function waitTime(timeout) {
                    return new Promise((done) => {
                        setTimeout(() => {
                            done();
                        }, timeout);
                    });
                }

                let changed = false;
                let botSkts = [];

                // STORAGE:
                let canStore;
                if (typeof(Storage) !== "undefined") {
                    canStore = true;
                }
                function saveVal(name, val) {
                    if (canStore)
                        localStorage.setItem(name, val);
                }
                function deleteVal(name) {
                    if (canStore)
                        localStorage.removeItem(name);
                }
                function getSavedVal(name) {
                    if (canStore)
                        return localStorage.getItem(name);
                    return null;
                }

                // CONFIGS:
                let gC = function(a, b) {
                    try {
                        let res = JSON.parse(getSavedVal(a));
                        if (typeof res === "object") {
                            return b;
                        } else {
                            return res;
                        }
                    } catch(e) {
                        alert("dieskid");
                        return b;
                    }
                };

                function setCommands() {
                    return {
                        "help": {
                            desc: "Show Commands",
                            action: function(message) {
                                for (let cmds in commands) {
                                    addMenuChText("/" + cmds, commands[cmds].desc, "lime", 1);
                                }
                            }
                        },
                        "clear": {
                            desc: "Clear Chats",
                            action: function(message) {
                                resetMenuChText();
                            }
                        },
                        "debug": {
                            desc: "Debug Mod For Development",
                            action: function(message) {
                                addDeadPlayer(player);
                                addMenuChText("Debug", "Done", "#99ee99", 1);
                            }
                        },
                        "play": {
                            desc: "Play Music ( /play [link] )",
                            action: function(message) {
                                let link = message.split(" ");
                                if (link[1]) {
                                    let audio = new Audio(link[1]);
                                    audio.play();
                                } else {
                                    addMenuChText("Warn", "Enter Link ( /play [link] )", "#99ee99", 1);
                                }
                            }
                        },
                        "bye": {
                            desc: "Leave Game",
                            action: function(message) {
                                unsafeWindow.leave();
                            }
                        },
                    };
                }
                function setConfigs() {
                    return {
                        stackedText: true,
                        HKH: true,
                        names: true,
                        adxtick: true,
                        autoOneFrame: true,
                        smartAutoInsta: true,
                        autobullspam: false,
                        safeWalk: true,
                        killChat: true,
                        autoBuy: true,
                        autoBuyEquip: true,
                        autoPush: true,
                        revTick: true,
                        spikeTick: true,
                        predictTick: true,
                        autoPlace: true,
                        autoReplace: true,
                        antiTrap: true,
                        slowOT: false,
                        attackDir: false,
                        noDir: true,
                        showDir: true,
                        autoRespawn: true
                    };
                }

                let commands = setCommands();
                let configs = setConfigs();
                autoRubyOnSpawn&&(configs.autoRespawn=1)

                unsafeWindow.removeConfigs = function() {
                    for (let cF in configs) {
                        deleteVal(cF, configs[cF]);
                    }
                };

                for (let cF in configs) {
                    configs[cF] = gC(cF, configs[cF]);
                }

                // MENU FUNCTIONS:
                unsafeWindow.changeMenu = function() {};
                unsafeWindow.debug = function() {};
                unsafeWindow.toggleNight = function() {};
                unsafeWindow.wasdMode = function() {};

                // PAGE 1:
                unsafeWindow.startGrind = function() {};

                // PAGE 3:
                unsafeWindow.connectFillBots = function() {};
                unsafeWindow.destroyFillBots = function() {};
                unsafeWindow.tryConnectBots = function() {};
                unsafeWindow.destroyBots = function() {};
                unsafeWindow.resBuild = function() {};
                unsafeWindow.toggleBotsCircle = function() {};
                unsafeWindow.toggleVisual = function() {};

                // SOME FUNCTIONS:
                unsafeWindow.prepareUI = function() {};
                unsafeWindow.leave = function() {};

                // nah hahahahahhh why good ping
                unsafeWindow.ping = imueheua ? 86 : 0;

                class deadfuturechickenmodrevival {
                    constructor(flarez, lore) {
                        this.inGame = false;
                        this.lover = flarez + lore;
                        this.baby = "ae86";
                        this.isBlack = 0;
                        this.webSocket = undefined;
                        this.checkBaby = function () {
                            this.baby !== "ae86" ? this.isBlack++ : this.isBlack--;
                            if (this.isBlack >= 1) return "bl4cky";
                            return "noting for you";
                        };
                        this.x2 = 0;
                        this.y2 = 0;
                        this.chat = "nOOB";
                        this.summon = function (tmpObj) {
                            this.x2 = tmpObj.x;
                            this.y2 = tmpObj.y;
                            this.chat = tmpObj.name + " ur so bad XDDDD";
                        };
                        this.commands = function (cmd) {
                            cmd == "rv3link" && unsafeWindow.open("https://florr.io/");
                            cmd == "woah" && unsafeWindow.open("https://www.youtube.com/watch?v=MO0AGukzj6M");
                            return cmd;
                        };
                        this.dayte = "11yearold";
                        this.memeganoob = "69yearold";
                        this.startDayteSpawn = function (tmpObj) {
                            let ratio = setInterval(() => {
                                this.x2 = tmpObj.x + 20;
                                this.y2 = tmpObj.y - 20;
                                this.chat = "UR SO BAD LOL";
                                if (tmpObj.name == "ae86") {
                                    this.chat = "omg ae86 go run";
                                    setTimeout(() => {
                                        this.inGame = false;
                                        clearInterval(ratio);
                                    }, 1000);
                                }
                            }, 1234);
                        };
                        this.AntiChickenModV69420 = function (tmpObj) {
                            return "!c!dc user " + tmpObj.name;
                        };
                    }
                };
                class HtmlAction {
                    constructor(element) {
                        this.element = element;
                    };
                    add(code) {
                        if (!this.element) return undefined;
                        this.element.innerHTML += code;
                    };
                    newLine(amount) {
                        let result = `<br>`;
                        if (amount > 0) {
                            result = ``;
                            for (let i = 0; i < amount; i++) {
                                result += `<br>`;
                            }
                        }
                        this.add(result);
                    };
                    checkBox(setting) {
                        let newCheck = `<input type = "checkbox"`;
                        setting.id && (newCheck += ` id = ${setting.id}`);
                        setting.style && (newCheck += ` style = ${setting.style.replaceAll(" ", "")}`);
                        setting.class && (newCheck += ` class = ${setting.class}`);
                        setting.checked && (newCheck += ` checked`);
                        setting.onclick && (newCheck += ` onclick = ${setting.onclick}`);
                        newCheck += `>`;
                        this.add(newCheck);
                    };
                    text(setting) {
                        let newText = `<input type = "text"`;
                        setting.id && (newText += ` id = ${setting.id}`);
                        setting.style && (newText += ` style = ${setting.style.replaceAll(" ", "")}`);
                        setting.class && (newText += ` class = ${setting.class}`);
                        setting.size && (newText += ` size = ${setting.size}`);
                        setting.maxLength && (newText += ` maxLength = ${setting.maxLength}`);
                        setting.value && (newText += ` value = ${setting.value}`);
                        setting.placeHolder && (newText += ` placeHolder = ${setting.placeHolder.replaceAll(" ", "&nbsp;")}`);
                        newText += `>`;
                        this.add(newText);
                    };
                    select(setting) {
                        let newSelect = `<select`;
                        setting.id && (newSelect += ` id = ${setting.id}`);
                        setting.style && (newSelect += ` style = ${setting.style.replaceAll(" ", "")}`);
                        setting.class && (newSelect += ` class = ${setting.class}`);
                        newSelect += `>`;
                        for (let options in setting.option) {
                            newSelect += `<option value = ${setting.option[options].id}`
                            setting.option[options].selected && (newSelect += ` selected`);
                            newSelect += `>${options}</option>`;
                        }
                        newSelect += `</select>`;
                        this.add(newSelect);
                    };
                    button(setting) {
                        let newButton = `<button`;
                        setting.id && (newButton += ` id = ${setting.id}`);
                        setting.style && (newButton += ` style = ${setting.style.replaceAll(" ", "")}`);
                        setting.class && (newButton += ` class = ${setting.class}`);
                        setting.onclick && (newButton += ` onclick = ${setting.onclick}`);
                        newButton += `>`;
                        setting.innerHTML && (newButton += setting.innerHTML);
                        newButton += `</button>`;
                        this.add(newButton);
                    };
                    selectMenu(setting) {
                        let newSelect = `<select`;
                        if (!setting.id) {
                            alert("please put id skid");
                            return;
                        }
                        unsafeWindow[setting.id + "Func"] = function() {};
                        setting.id && (newSelect += ` id = ${setting.id}`);
                        setting.style && (newSelect += ` style = ${setting.style.replaceAll(" ", "")}`);
                        setting.class && (newSelect += ` class = ${setting.class}`);
                        newSelect += ` onchange = window.${setting.id + "Func"}()`;
                        newSelect += `>`;
                        let last;
                        let i = 0;
                        for (let options in setting.menu) {
                            newSelect += `<option value = ${"option_" + options} id = ${"O_" + options}`;
                            setting.menu[options] && (newSelect += ` checked`);
                            newSelect += ` style = "color: ${setting.menu[options] ? "#000" : "#fff"}; background: ${setting.menu[options] ? "#8ecc51" : "#cc5151"};">${options}</option>`;
                            i++;
                        }
                        newSelect += `</select>`;

                        this.add(newSelect);

                        i = 0;
                        for (let options in setting.menu) {
                            unsafeWindow[options + "Func"] = function() {
                                setting.menu[options] = getEl("check_" + options).checked ? true : false;
                                saveVal(options, setting.menu[options]);

                                getEl("O_" + options).style.color = setting.menu[options] ? "#000" : "#fff";
                                getEl("O_" + options).style.background = setting.menu[options] ? "#8ecc51" : "#cc5151";

                                //getEl(setting.id).style.color = setting.menu[options] ? "#8ecc51" : "#cc5151";

                            };
                            this.checkBox({id: "check_" + options, style: `display: ${i == 0 ? "inline-block" : "none"};`, class: "checkB", onclick: `window.${options + "Func"}()`, checked: setting.menu[options]});
                            i++;
                        }

                        last = "check_" + getEl(setting.id).value.split("_")[1];
                        unsafeWindow[setting.id + "Func"] = function() {
                            getEl(last).style.display = "none";
                            last = "check_" + getEl(setting.id).value.split("_")[1];
                            getEl(last).style.display = "inline-block";

                            //getEl(setting.id).style.color = setting.menu[last.split("_")[1]] ? "#8ecc51" : "#fff";

                        };
                    };
                };
                class Html {
                    constructor() {
                        this.element = null;
                        this.action = null;
                        this.divElement = null;
                        this.startDiv = function (setting, func) {

                            let newDiv = document.createElement("div");
                            setting.id && (newDiv.id = setting.id);
                            setting.style && (newDiv.style = setting.style);
                            setting.class && (newDiv.className = setting.class);
                            this.element.appendChild(newDiv);
                            this.divElement = newDiv;

                            let addRes = new HtmlAction(newDiv);
                            typeof func == "function" && func(addRes);

                        };
                        this.addDiv = function (setting, func) {

                            let newDiv = document.createElement("div");
                            setting.id && (newDiv.id = setting.id);
                            setting.style && (newDiv.style = setting.style);
                            setting.class && (newDiv.className = setting.class);
                            setting.appendID && getEl(setting.appendID).appendChild(newDiv);
                            this.divElement = newDiv;

                            let addRes = new HtmlAction(newDiv);
                            typeof func == "function" && func(addRes);

                        };
                    };
                    set(id) {
                        this.element = getEl(id);
                        this.action = new HtmlAction(this.element);
                    };
                    resetHTML(text) {
                        if (text) {
                            this.element.innerHTML = ``;
                        } else {
                            this.element.innerHTML = ``;
                        }
                    };
                    setStyle(style) {

                        this.element.style = style;
                    };
                    setCSS(style) {
                        this.action.add(`<style>` + style + `</style>`);
                    };
                };

                let HTML = new Html();

                let nightMode = document.createElement("div");
                nightMode.id = "nightMode";
                document.body.appendChild(nightMode);
                HTML.set("nightMode");
                HTML.setStyle(`
            display: none;
            position: absolute;
            pointer-events: none;
            background-color: rgb(0, 0, 100);
            opacity: 0;
            top: 0%;
            width: 100%;
            height: 100%;
            animation-duration: 5s;
            animation-name: night2;
            `);
                HTML.resetHTML();
                HTML.setCSS(`
            @keyframes night1 {
                from {opacity: 0;}
                to {opacity: 0.35;}
            }
            @keyframes night2 {
                from {opacity: 0.35;}
                to {opacity: 0;}
            }
            `);

                let menuDiv = document.createElement("div");
                menuDiv.id = "menuDiv";
                document.body.appendChild(menuDiv);
                HTML.set("menuDiv");
                HTML.setStyle(`
            position: absolute;
            left: 20px;
            top: 20px;
            `);
                HTML.resetHTML();
                HTML.setCSS(`
            .menuClass{
                color: #fff;
                font-size: 31px;
                text-align: left;
                padding: 10px;
                padding-top: 7px;
                padding-bottom: 5px;
                width: 300px;
                background-color: rgba(0, 0, 0, 0.25);
                -webkit-border-radius: 4px;
                -moz-border-radius: 4px;
                border-radius: 4px;
            }
            .menuC {
                display: none;
                font-family: "Hammersmith One";
                font-size: 12px;
                max-height: 180px;
                overflow-y: scroll;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            .menuB {
                text-align: center;
                background-color: rgb(25, 25, 25);
                color: #fff;
                -webkit-border-radius: 4px;
                -moz-border-radius: 4px;
                border-radius: 4px;
                border: 2px solid #000;
                cursor: pointer;
            }
            .menuB:hover {
                border: 2px solid #fff;
            }
            .menuB:active {
                color: rgb(25, 25, 25);
                background-color: rgb(200, 200, 200);
            }
            .customText {
                color: #000;
                -webkit-border-radius: 4px;
                -moz-border-radius: 4px;
                border-radius: 4px;
                border: 2px solid #000;
            }
            .customText:focus {
                background-color: yellow;
            }
            .checkB {
                position: relative;
                top: 2px;
                accent-color: #888;
                cursor: pointer;
            }
            .Cselect {
                -webkit-border-radius: 4px;
                -moz-border-radius: 4px;
                border-radius: 4px;
                background-color: rgb(75, 75, 75);
                color: #fff;
                border: 1px solid #000;
            }
            #menuChanger {
                position: absolute;
                right: 10px;
                top: 10px;
                background-color: rgba(0, 0, 0, 0);
                color: #fff;
                border: none;
                cursor: pointer;
            }
            #menuChanger:hover {
                color: #000;
            }
            ::-webkit-scrollbar {
                width: 10px;
            }
            ::-webkit-scrollbar-track {
                opacity: 0;
            }
            ::-webkit-scrollbar-thumb {
                background-color: rgb(25, 25, 25);
                -webkit-border-radius: 4px;
                -moz-border-radius: 4px;
                border-radius: 4px;
            }
            ::-webkit-scrollbar-thumb:active {
                background-color: rgb(230, 230, 230);
            }
            `);
                let primaryGrindVariant,secondaryGrindVariant;
                HTML.startDiv({id: "menuHeadLine", class: "menuClass"}, (html) => {
                    html.add(`Mod:`);
                    html.button({id: "menuChanger", class: "material-icons", innerHTML: `sync`, onclick: "window.changeMenu()"});
                    HTML.addDiv({id: "menuButtons", style: "display: block; overflow-y: visible;", class: "menuC", appendID: "menuHeadLine"}, (html) => {
                        html.button({class: "menuB", innerHTML: "Debug", onclick: "window.debug()"});
                        html.button({class: "menuB", innerHTML: "Night Mode", onclick: "window.toggleNight()"});
                    });
                    HTML.addDiv({id: "menuMain", style: "display: block", class: "menuC", appendID: "menuHeadLine"}, (html) => {
                        html.button({class: "menuB", innerHTML: "Toggle Wasd Mode", onclick: "window.wasdMode()"});
                        html.newLine();
                        html.add(`Weapon Grinder: `);
                        html.checkBox({id: "weaponGrind", class: "checkB", onclick: "window.startGrind()"});
                        html.newLine(2);
                        HTML.addDiv({style: "font-size: 20px; color: #99ee99;", appendID: "menuMain"}, (html) => {
                            html.add(`Developing Settings:`);
                        });
                        html.add(`New Healing Beta:`);
                        html.checkBox({id: "healingBeta", class: "checkB", checked: true});
                        html.newLine();
                    });
                    HTML.addDiv({id: "menuConfig", class: "menuC", appendID: "menuHeadLine"}, (html) => {
                        html.add(`AutoPlacer Placement Tick: `);
                        html.text({id: "autoPlaceTick", class: "customText", value: "2", size: "2em", maxLength: "1"});
                        html.newLine();
                        html.add(`Configs: `);
                        html.selectMenu({id: "configsChanger", class: "Cselect", menu: configs});
                        html.newLine();
                        html.add(`InstaKill Type: `);
                        html.select({id: "instaType", class: "Cselect", option: {
                            OneShot: {
                                id: "oneShot",
                                selected: true
                            },
                            Rev: {
                                id: "rev",
                                selected: true
                            },
                            BoBull: {
                                id: "nobull"
                            },
                            Normal: {
                                id: "Normal",
                            },
                            OneTick: {
                                id: "oneTickType"
                            },
                            ThreeOneTickType: {
                                id: "threeOneTickType"
                            },
                        }});
                        html.newLine();
                        html.add(`AntiBull Type: `);
                        html.select({id: "antiBullType", class: "Cselect", option: {
                            "Disable AntiBull": {
                                id: "noab",
                                selected: true
                            },
                            "When Reloaded": {
                                id: "abreload",
                            },
                            "Primary Reloaded": {
                                id: "abalway"
                            }
                        }});
                        html.newLine();
                        html.add(`Backup Nobull Insta: `);
                        html.checkBox({id: "backupNobull", class: "checkB", checked: true});
                        html.newLine();
                        html.add(`Turret Gear Combat Assistance: `);
                        html.checkBox({id: "turretCombat", class: "checkB", checked: true});
                        html.newLine();
                        html.add(`Safe AntiSpikeTick: `);
                        html.checkBox({id: "safeAntiSpikeTick", class: "checkB", checked: true});
                        html.newLine();
                    });
                    HTML.addDiv({id: "menuOther", class: "menuC", appendID: "menuHeadLine"}, (html) => {
                        html.button({class: "menuB", innerHTML: "Connect Bots", onclick: "window.tryConnectBots()"});
                        html.button({class: "menuB", innerHTML: "Disconnect Bots", onclick: "window.destroyBots()"});
                        html.newLine();
                        html.button({class: "menuB", innerHTML: "Connect FBots", onclick: "window.connectFillBots()"});
                        html.button({class: "menuB", innerHTML: "Disconnect FBots", onclick: "window.destroyFillBots()"});
                        html.newLine();
                        html.button({class: "menuB", innerHTML: "Reset Break Objects", onclick: "window.resBuild()"});
                        html.newLine();
                        html.add(`Break Objects Range: `);
                        html.text({id: "breakRange", class: "customText", value: "700", size: "3em", maxLength: "4"});
                        html.newLine();
                        html.add(`Placer type: `);
                        html.select({
                            id: "autoPlacetype",
                            class: "Cselect",
                            option: {
                                ramdomplc:   { id: "ramdomplc", selected: 0 },
                                spamtrap:    { id: "spamtrap", selected: 0 },
                                aiplace: { id: "aiplace", selected: 0 },
                                magicplace:    { id: "magicplace", selected: 1 }
                            }
                        });
                        html.newLine();
                        html.add(`Predict Movement Type: `);
                        html.select({id: "predictType", class: "Cselect", option: {
                            "Disable Render": {
                                id: "disableRender",
                                selected: true
                            },
                            "X/Y and 2": {
                                id: "pre2",
                            },
                            "X/Y and 3": {
                                id: "pre3"
                            },
                            "X/Y and 4": {
                                id: "pre4"
                            },
                            "X/Y and 5": {
                                id: "pre5"
                            }
                        }});
                        html.newLine();
                        html.add(`Render Placers: `);
                        html.checkBox({id: "placeVis", class: "checkB", checked: true});
                        html.newLine();
                        html.add(`Visuals: `);
                        html.select({id: "visualType", class: "Cselect", option: {
                            "Old Shit": {
                                id: "ueh1",
                            },
                            "New shit": {
                                id: "ueh2",
                                selected: true
                            },
                        }});
                        html.newLine(2);
                        html.button({class: "menuB", innerHTML: "Toggle Fbots Circle", onclick: "window.toggleBotsCircle()"});
                        html.newLine();
                        html.add(`Circle Rad: `);
                        html.text({id: "circleRad", class: "customText", value: "200", size: "3em", maxLength: "4"});
                        html.newLine();
                        html.add(`Rad Speed: `);
                        html.text({id: "radSpeed", class: "customText", value: "0.1", size: "2em", maxLength: "3"});
                        html.newLine(2);
                        html.add(`Cross World: `);
                        html.checkBox({id: "funni", class: "checkB"});
                        html.newLine();
                        html.button({class: "menuB", innerHTML: "Toggle Another Visual", onclick: "window.toggleVisual()"});
                        html.newLine();
                    });
                    HTML.addDiv(
                        { id: "menuBotSettings", class: "menuC", appendID: "menuHeadLine" },
                        (html) => {
                            html.add(`Bot Settings:`);
                            html.newLine();

                            // autoRuby toggle
                            html.checkBox({
                                id: "autoRuby",
                                class: "checkB",
                                checked: false,
                            });
                            html.add(` autoRuby`);
                            html.newLine();

                            // autoRubyOnSpawn toggle
                            html.checkBox({
                                id: "autoRubyOnSpawn",
                                class: "checkB",
                                checked: autoRubyOnSpawn,
                            });
                            html.add(` autoRubyOnSpawn`);
                            html.newLine(2);

                            html.add(`Weapon Grind Settings:`);
                            html.newLine();

                            // grindPole toggle
                            html.checkBox({
                                id: "grindPole",
                                class: "checkB",
                                checked: grindPole,
                            });
                            html.add(` grindPole`);
                            html.newLine();

                            // primary variant select
                            html.add(`Primary Variant: `);
                            html.select({
                                id: "primaryGrindVariant",
                                class: "Cselect",
                                option: {
                                    Stone:   { id: "0", selected: primaryGrindVariant === 0 },
                                    Gold:    { id: "1", selected: primaryGrindVariant === 1 },
                                    Diamond: { id: "2", selected: primaryGrindVariant === 2 },
                                    Ruby:    { id: "3", selected: primaryGrindVariant === 3 }
                                }
                            });
                            html.newLine();

                            // secondary variant select
                            html.add(`Secondary Variant: `);
                            html.select({
                                id: "secondaryGrindVariant",
                                class: "Cselect",
                                option: {
                                    Stone:   { id: "0", selected: secondaryGrindVariant === 0 },
                                    Gold:    { id: "1", selected: secondaryGrindVariant === 1 },
                                    Diamond: { id: "2", selected: secondaryGrindVariant === 2 },
                                    Ruby:    { id: "3", selected: secondaryGrindVariant === 3 }
                                }
                            });
                            html.newLine(2);
                        }
                    );
                });

                let menuChatDiv = document.createElement("div");
                menuChatDiv.id = "menuChatDiv";
                document.body.appendChild(menuChatDiv);
                HTML.set("menuChatDiv");
                HTML.setStyle(`
            position: absolute;
            display: none;
            left: 0px;
            top: 0px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.65);
            `);
                HTML.resetHTML();
                HTML.setCSS(`
            .chDiv{
                color: #fff;
                padding: 5px;
                width: 340px;
                height: 280px;
                background-color: rgba(0, 0, 0, 0.35);
            }
            .chMainDiv{
                font-family: "Ubuntu";
                font-size: 12px;
                max-height: 235px;
                overflow-y: scroll;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            .chMainBox{
                position: absolute;
                left: 5px;
                bottom: 10px;
                width: 335px;
                height: 30px;
                background-color: rgb(128, 128, 128, 0.35);
                -webkit-border-radius: 4px;
                -moz-border-radius: 4px;
                border-radius: 4px;
                color: #fff;
                font-family: "Ubuntu";
                font-size: 12px;
                border: none;
                outline: none;
            }
            `);
                HTML.startDiv({id: "mChDiv", class: "chDiv"}, (html) => {
                    HTML.addDiv({id: "mChMain", class: "chMainDiv", appendID: "mChDiv"}, (html) => {
                    });
                    html.text({id: "mChBox", class: "chMainBox", placeHolder: `To chat click here or press "Enter" key`});
                });

                let menuChats = getEl("mChMain");
                let menuChatBox = getEl("mChBox");
                let menuCBFocus = false;
                let menuChCounts = 0;
                getEl('grindPole').addEventListener('click',e=>{
                    (grindPole = !grindPole,console.log('grindPole:', grindPole))
                })
                getEl('autoRuby').addEventListener('click',e=>{
                    (autoRuby = !autoRuby,console.log('autoRuby:', autoRuby))
                })
                getEl('autoRubyOnSpawn').addEventListener('click',e=>{
                    (autoRubyOnSpawn = !autoRubyOnSpawn,console.log('autoRubyOnSpawn:', autoRubyOnSpawn))
                })
                getEl('primaryGrindVariant').addEventListener('change', e => {
                    primaryGrindVariant = +e.target.value;
                    console.log('primaryGrindVariant:', primaryGrindVariant);
                });
                getEl('secondaryGrindVariant').addEventListener('change', e => {
                    secondaryGrindVariant = +e.target.value;
                    console.log('secondaryGrindVariant:', secondaryGrindVariant);
                });
                menuChatBox.value = "";
                menuChatBox.addEventListener("focus", () => {
                    menuCBFocus = true;
                });
                menuChatBox.addEventListener("blur", () => {
                    menuCBFocus = false;
                });

                function addMenuChText(name, message, color, noTimer) {
                    HTML.set("menuChatDiv");
                    color = color||"white";

                    let time = new Date();
                    let min = time.getMinutes();
                    let hour = time.getHours();

                    let getAMPM = hour >= 12 ? "PM" : "AM";
                    let text = ``;
                    // if (!noTimer) text += `[${(hour % 12) + ":" + min + " " + getAMPM}]`;
                    if (name) text += `${(!noTimer ? " - " : "") + name}`;
                    if (message) text += `${(name ? ": " : !noTimer ? " - " : "") + message}\n`;

                    HTML.addDiv({id: "menuChDisp" + menuChCounts, style: `color: ${color}`, appendID: "mChMain"}, (html) => {
                        html.add(text);
                    });
                    menuChats.scrollTop = menuChats.scrollHeight;
                    menuChCounts++;
                }
                function resetMenuChText() {
                    menuChats.innerHTML = ``;
                    menuChCounts = 0;
                    addMenuChText(null, "Chat '/help' for a list of chat commands.", "white", 1)
                }
                resetMenuChText();

                let menuIndex = 0;
                let menus = ["menuMain", "menuConfig", "menuOther",'menuBotSettings'];
                unsafeWindow.changeMenu = function() {
                    getEl(menus[menuIndex % menus.length]).style.display = "none";
                    menuIndex++;
                    getEl(menus[menuIndex % menus.length]).style.display = "block";
                };

                let mStatus = document.createElement("div");
                mStatus.id = "status";
                getEl("gameUI").appendChild(mStatus);
                HTML.set("status");
                HTML.setStyle(`
            display: block;
            position: absolute;
            color: #ddd;
            font: 15px Hammersmith One;
            bottom: 215px;
            left: 20px;
            `);
                HTML.resetHTML();
                HTML.setCSS(`
            .sizing {
                font-size: 15px;
            }
            .mod {
                font-size: 15px;
                display: inline-block;
            }
            `);
                HTML.startDiv({id: "uehmod", class: "sizing"}, (html) => {
                    html.add(`Ping: `);
                    HTML.addDiv({id: "pingFps", class: "mod", appendID: "uehmod"}, (html) => {
                        html.add("None");
                    });
                    html.newLine();
                    html.add(`Packet: `);
                    HTML.addDiv({id: "packetStatus", class: "mod", appendID: "uehmod"}, (html) => {
                        html.add("None");
                    });
                });

                /*function modLog() {
                let logs = [];
                for (let i = 0; i < arguments.length; i++) {
                    logs.push(arguments[i]);
                }
                getEl("modLog").innerHTML = logs;
            }*/

                let openMenu = false;

                let WS = null;
                let socketID = undefined;
                let useWasd = false;
                let secPacket = 0;
                let secMax = 110;
                let secTime = 1000;
                let firstSend = {
                    sec: false
                };
                let game = {
                    tick: 0,
                    tickQueue: [],
                    tickBase: function (set, tick) {
                        if (this.tickQueue[this.tick + tick]) {
                            this.tickQueue[this.tick + tick].push(set);
                        } else {
                            this.tickQueue[this.tick + tick] = [set];
                        }
                    },
                    tickRate: (1000 / config.serverUpdateRate),
                    tickSpeed: 0,
                    lastTick: performance.now()
                };
                let modConsole = [];

                let dontSend = false;
                let fpsTimer = {
                    last: 0,
                    time: 0,
                    ltime: 0
                }
                let lastMoveDir = undefined;
                let lastsp = ["cc", 1, "__proto__"];
                _lastsp=lastsp;
                loggingpack=false;
                packs=[]
                startLog=function(m){
                    loggingpack=true
                    packs=[];
                    setTimeout(()=>{
                        loggingpack=false
                        console.log(packs)
                    },m)
                }
                WebSocket.prototype.nsend = WebSocket.prototype.send;
                WebSocket.prototype.send = function (message) {
                    if(!WS){
                        WS=this
                        WS.addEventListener("message", function (msg) {
                            getMessage(msg);
                        });
                        WS.addEventListener("close", (event) => {
                            if (event.code == 4001) {
                                //window.location.reload();
                            }
                        });
                        // assume WS is your WebSocket instance
                        addEventListener('beforeunload', () => {
                            if (WS && WS.readyState === WebSocket.OPEN&&confirm('do it?')) {
                                // optional: log that we're closing
                                console.log('👋 closing WS before unload');
                                WS.close(1000, 'Page unload');
                            }
                        });
                    };
                    if (this.url!=WS) {
                        dontSend = false;

                        // EXTRACT DATA ARRAY:
                        let data = new Uint8Array(message);
                        let parsed = window.msgpack.decode(data);
                        let type = parsed[0];
                        data = parsed[1];

                        // SEND MESSAGE:
                        if (type == "6") {

                            if (data[0]) {
                                // ANTI PROFANITY:
                                let profanity = [];
                                let tmpString;
                                profanity.forEach((profany) => {
                                    if (data[0].indexOf(profany) > -1) {
                                        tmpString = "";
                                        for (let i = 0; i < profany.length; ++i) {
                                            if (i == 1) {
                                                tmpString += String.fromCharCode(0);
                                            }
                                            tmpString += profany[i];
                                        }
                                        let re = new RegExp(profany, "g");
                                        data[0] = data[0].replace(re, tmpString);
                                    }
                                });

                                // FIX CHAT:
                                data[0] = data[0].slice(0, 30);
                            }
                        } else if (type == "L") {
                            // MAKE SAME CLAN:
                            data[0] = data[0] + (String.fromCharCode(0).repeat(7));
                            data[0] = data[0].slice(0, 7);
                        } else if (type == "M") {
                            // APPLY CYAN COLOR:
                            data[0].name = data[0].name == "" ? "unknown" : data[0].name;
                            data[0].moofoll = true;
                            data[0].skin = data[0].skin == 10 ? "__proto__" : data[0].skin;
                            lastsp = [data[0].name, data[0].moofoll, data[0].skin];
                        } else if (type == "D") {
                            if ((my.lastDir == data[0]) || [null, undefined].includes(data[0])) {
                                dontSend = true;
                            } else {
                                my.lastDir = data[0];
                            }
                        } else if (type == "d") {
                            if (!data[2]) {
                                dontSend = true;
                            } else {
                                if (![null, undefined].includes(data[1])) {
                                    my.lastDir = data[1];
                                }
                            }
                        } else if (type == "K") {
                            if (!data[1]) {
                                dontSend = true;
                            }
                        } else if (type == "14") {
                            instaC.wait = !instaC.wait;
                            dontSend = true;
                        } else if (type == "9") {
                            if (data[1]) {
                                if (player.moveDir == data[0]) {
                                    dontSend = true;
                                }
                                player.moveDir = data[0];
                            } else {
                                dontSend = true;
                            }
                        }
                        if (!dontSend) {
                            let binary = window.msgpack.encode([type, data]);
                            this.nsend(binary);
                            // START COUNT:
                            if (!firstSend.sec) {
                                firstSend.sec = true;
                                setTimeout(() => {
                                    firstSend.sec = false;
                                    secPacket = 0;
                                }, secTime);
                            }
                            secPacket++;
                        }
                    } else {
                        this.nsend(message);
                    }
                }

                /*WS = new WebSocket(wssUrl);
            WS.binaryType = "arraybuffer";
            WS.addEventListener("message", function (msg) {
                getMessage(msg);
            });
            WS.addEventListener("close", (event) => {
                if (event.code == 4001) {
                    window.location.reload();
                }
            });
            // Optionally do something on open:
            WS.addEventListener("open", () => {
                console.log("🎉 Connected to", wssUrl);
            });*/
                var isteamAction
                let canReq=1
                joinTeam = function(team=_GM_getValue('Mclan')) {
                    // 1) Pad (or trim) to exactly 7 chars using '\x00'
                    //team = (team + '\x00'.repeat(7)).slice(0, 7);

                    // 2) Rate-limit requests
                    if (!canReq) return;
                    canReq = 0;

                    // 3) Leave current team if needed
                    setTimeout(() => { canReq = 1 }, 2000)
                    if (_things.player.team === team||_things.player.team&&_things.player.team.replaceAll('\x00','')==team) return;
                    if (_things.player.team) (leaveTeam());

                    // 4) DEBUG log with literal '\x00'
                    console.log(
                        'Joining:',
                        team,//.replace(/\x00/g, '\\x00'),
                        'len=', team.length
                    );
                    // → "Joining: d\x00\x00\x00\x00\x00\x00 len= 7"

                    // 5) Send packets
                    let rng=_random(['b','L'])
                    _things.packet(rng,team)
                    //_things.packet('L', team);
                    //olgGMS('acc', {});
                    rng=='b'&&setTimeout(()=>(olgGMS('acc', {}),olgGMS('acc', { sid: player.sid, team, stamp: Date.now() })),pingTime+150)
                };


                leaveTeam=function(){
                    _things.packet('N',_things.player.team)
                }
                //let alliances=[]
                addAlliance=function(a){
                    if(!a)return;
                    console.log(a,'added')
                    //alliances.push(a)
                }
                deleteAlliance=function(a){
                    if(!a)return;
                    console.log(a,'removed')
                    //alliances=alliances.filter(e=>e!=a)
                }

                let io = {
                    send: packet
                };

                setInterval(()=>{try{nonBreak=!!_things.enemy.enemy}catch{}},1000)

                allowChats=0;allowComands=1
                function packet(type) {
                    let data = Array.prototype.slice.call(arguments, 1);
                    // SEND MESSAGE:
                    if(type=='9'){
                        if(_things.moveNOW){
                            data[1]=_things.moveNOW;
                            lastMoveDir=_things.moveNOW;
                            _things.moveNOW=null
                        }
                        if(!millDone&&autoGo&&_things.player.moveDir!=lastMoveDir){
                            lastMoveDir=data[1]=mills.place ? millAngle_ : null
                            return WS.send(unsafeWindow.msgpack.encode([type, data]));
                        }
                        //_things.packet(_things.moveKey, mills.place ? millAngle_ : null, 1);
                    }
                    if(type=='9'){
                        //console.trace(lastMoveDir,data[1])
                        //console.trace()
                    }
                    if(type=='9'&&!autoPush){
                        //console.log(arguments[1],lastMoveDir)
                        if(_things.player.moveDir==lastMoveDir)return;
                        //if(autoGo&&)
                    }

                    // EXTRACT DATA ARRAY:

                    let binary = unsafeWindow.msgpack.encode([type, data]);
                    WS.send(binary);
                }

                function origPacket(type) {
                    // EXTRACT DATA ARRAY:
                    let data = Array.prototype.slice.call(arguments, 1);

                    // SEND MESSAGE:
                    let binary = unsafeWindow.msgpack.encode([type, data]);
                    WS.nsend(binary);
                }

                unsafeWindow.leave = function() {
                    origPacket("kys", {
                        "frvr is so bad": true,
                        "sidney is too good": true,
                        "dev are too weak": true,
                    });
                };

                //...lol

                function getMessage(message) {
                    let data = new Uint8Array(message.data);
                    let parsed = unsafeWindow.msgpack.decode(data);
                    let type = parsed[0];
                    data = parsed[1];
                    if(loggingpack){
                        packs.push([type,...data])
                    }
                    let events = {
                        A: setInitData,
                        //B: disconnect,
                        C: setupGame,
                        D: addPlayer,
                        E: removePlayer,
                        a: updatePlayers,
                        G: updateLeaderboard,
                        H: loadGameObject,
                        I: loadAI,
                        J: animateAI,
                        K: gatherAnimation,
                        L: wiggleGameObject,
                        M: shootTurret,
                        N: updatePlayerValue,
                        O: updateHealth,
                        P: killPlayer,
                        Q: killObject,
                        R: killObjects,
                        S: updateItemCounts,
                        T: updateAge,
                        U: updateUpgrades,
                        V: updateItems,
                        X: addProjectile,
                        Y: remProjectile,
                        //Z: serverShutdownNotice,
                        0: addAlliance,
                        1: deleteAlliance,
                        2: allianceNotification,
                        3: setPlayerTeam,
                        4: setAlliancePlayers,
                        5: updateStoreItems,
                        6: receiveChat,
                        7: updateMinimap,
                        8: showText,
                        9: pingMap,
                        //0: pingSocketResponse,
                    };
                    if (type == "io-init") {
                        socketID = data[0];
                    } else {
                        if (events[type]) {
                            events[type].apply(undefined, data);
                        }
                    }
                }

                // MATHS:
                Math.lerpAngle = function (value1, value2, amount) {
                    let difference = Math.abs(value2 - value1);
                    if (difference > Math.PI) {
                        if (value1 > value2) {
                            value2 += Math.PI * 2;
                        } else {
                            value1 += Math.PI * 2;
                        }
                    }
                    let value = value2 + ((value1 - value2) * amount);
                    if (value >= 0 && value <= Math.PI * 2) return value;
                    return value % (Math.PI * 2);
                };

                // REOUNDED RECTANGLE:
                CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                    if (w < 2 * r) r = w / 2;
                    if (h < 2 * r) r = h / 2;
                    if (r < 0)
                        r = 0;
                    this.beginPath();
                    this.moveTo(x+r, y);
                    this.arcTo(x+w, y, x+w, y+h, r);
                    this.arcTo(x+w, y+h, x, y+h, r);
                    this.arcTo(x, y+h, x, y, r);
                    this.arcTo(x, y, x+w, y, r);
                    this.closePath();
                    return this;
                };

                // GLOBAL VALUES:

                let petals = [];
                let allChats = [];

                let ais = [];
                let players = [];
                let alliances = [];
                let alliancePlayers = [];
                let allianceNotifications = [];
                let gameObjects = [];
                let liztobj = [];
                let projectiles = [];
                let deadPlayers = [];

                let breakObjects = [];

                let player;
                let playerSID;
                let tmpObj;

                let enemy = [];
                let nears = [];
                let near = [];

                let my = {
                    reloaded: false,
                    waitHit: 0,
                    autoAim: false,
                    revAim: false,
                    ageInsta: true,
                    reSync: false,
                    bullTick: 0,
                    anti0Tick: 0,
                    antiSync: false,
                    safePrimary: function (tmpObj) {
                        return [0, 8].includes(tmpObj.primaryIndex);
                    },
                    safeSecondary: function (tmpObj) {
                        return [10, 11, 14].includes(tmpObj.secondaryIndex);
                    },
                    lastDir: 0,
                    autoPush: false,
                    pushData: {}
                }

                // FIND OBJECTS BY ID/SID:
                function findID(tmpObj, tmp) {
                    return tmpObj.find((THIS) => THIS.id == tmp);
                }

                function findSID(tmpObj, tmp) {
                    return tmpObj.find((THIS) => THIS.sid == tmp);
                }

                function findPlayerByID(id) {
                    return findID(players, id);
                }

                function findPlayerBySID(sid) {
                    return findSID(players, sid);
                }
                unsafeWindow.findPlayerBySID=findPlayerBySID
                function findAIBySID(sid) {
                    return findSID(ais, sid);
                }

                function findObjectBySid(sid) {
                    return findSID(gameObjects, sid);
                }

                function findProjectileBySid(sid) {
                    return findSID(gameObjects, sid);
                }

                let gameName = getEl("gameName");
                gameName.innerText = "hacker";
                let adCard = getEl("adCard");
                //adCard.remove();
                let promoImageHolder = getEl("promoImgHolder");
                //promoImageHolder.remove();

                let chatButton = getEl("chatButton");
                chatButton.remove();
                let gameCanvas = getEl("gameCanvas");
                let mainContext = gameCanvas.getContext("2d");
                let mapDisplay = getEl("mapDisplay");
                let mapContext = mapDisplay.getContext("2d");
                mapDisplay.width = 300;
                mapDisplay.height = 300;
                let storeMenu = getEl("storeMenu");
                let storeHolder = getEl("storeHolder");
                let upgradeHolder = getEl("upgradeHolder");
                let upgradeCounter = getEl("upgradeCounter");
                let chatBox = getEl("chatBox");
                chatBox.autocomplete = "off";
                chatBox.style.textAlign = "center";
                chatBox.style.width = "18em";
                let chatHolder = getEl("chatHolder");
                let actionBar = getEl("actionBar");
                let leaderboardData = getEl("leaderboardData");
                let itemInfoHolder = getEl("itemInfoHolder");
                let menuCardHolder = getEl("menuCardHolder");
                let mainMenu = getEl("mainMenu");
                let diedText = getEl("diedText");
                let screenWidth;
                let screenHeight;
                let maxScreenWidth = config.maxScreenWidth;
                let maxScreenHeight = config.maxScreenHeight;
                let pixelDensity = 1;
                let delta;
                let now;
                let lastUpdate = performance.now();
                let camX;
                let camY;
                let tmpDir;
                let mouseX = 0;
                let mouseY = 0;
                let allianceMenu = getEl("allianceMenu");
                let waterMult = 1;
                let waterPlus = 0;

                let outlineColor = "#525252";
                let darkOutlineColor = "#3d3f42";
                let outlineWidth = 5.5;

                let isNight = false;
                let firstSetup = true;
                let keys = {};
                let moveKeys = {
                    87: [0, -1],
                    38: [0, -1],
                    83: [0, 1],
                    40: [0, 1],
                    65: [-1, 0],
                    37: [-1, 0],
                    68: [1, 0],
                    39: [1, 0],
                };
                let attackState = 0;
                let inGame = false;

                let macro = {};
                let pads = {placeSpawnPads:0};
                let lastDir;

                let lastLeaderboardData = [];

                // ON LOAD:
                let inWindow = true;
                unsafeWindow.onblur = function () {
                    inWindow = false;
                };
                unsafeWindow.onfocus = function () {
                    inWindow = true;
                    if (player && player.alive) {
                        // resetMoveDir();
                    }
                };

                let placeVisible = [];
                let profanityList = ["cunt", "whore", "fuck", "shit", "faggot", "nigger",
                                     "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex",
                                     "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune",
                                     "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard"];

                /** CLASS CODES */

                class Utils {
                    constructor() {
                        // MATH UTILS:
                        let mathABS = Math.abs,
                            mathCOS = Math.cos,
                            mathSIN = Math.sin,
                            mathPOW = Math.pow,
                            mathSQRT = Math.sqrt,
                            mathATAN2 = Math.atan2,
                            mathPI = Math.PI;

                        let _this = this;

                        this.shouldDrawCCW = function(a, b) {
                            // normalize diff into [0, 2π)
                            const diff = (b - a + 2*Math.PI) % (2*Math.PI);
                            // if diff > π, the shorter way is ccw (anticlockwise)
                            return diff > Math.PI;
                        };
                        // GLOBAL UTILS:
                        this.round = function(n, v) {
                            return Math.round(n * v) / v;
                        };
                        this.toRad = function (angle) {
                            return angle * (mathPI / 180);
                        };
                        this.toAng = function (radian) {
                            return radian / (mathPI / 180);
                        };
                        this.randInt = function (min, max) {
                            return Math.floor(Math.random() * (max - min + 1)) + min;
                        };
                        this.randFloat = function (min, max) {
                            return Math.random() * (max - min + 1) + min;
                        };
                        this.lerp = function (value1, value2, amount) {
                            return value1 + (value2 - value1) * amount;
                        };
                        this.decel = function (val, cel) {
                            if (val > 0)
                                val = Math.max(0, val - cel);
                            else if (val < 0)
                                val = Math.min(0, val + cel);
                            return val;
                        };
                        this.getDistance = function (x1, y1, x2, y2) {
                            return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
                        };
                        this.getDist = function (tmp1, tmp2, type1, type2) {
                            let tmpXY1 = {
                                x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                                y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                            };
                            let tmpXY2 = {
                                x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                                y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                            };
                            return mathSQRT((tmpXY2.x -= tmpXY1.x) * tmpXY2.x + (tmpXY2.y -= tmpXY1.y) * tmpXY2.y);
                        };
                        this.getDirection = function (x1, y1, x2, y2) {
                            return mathATAN2(y1 - y2, x1 - x2);
                        };
                        this.getDirect = function (tmp1, tmp2, type1, type2) {
                            let tmpXY1 = {
                                x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                                y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                            };
                            let tmpXY2 = {
                                x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                                y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                            };
                            return mathATAN2(tmpXY1.y - tmpXY2.y, tmpXY1.x - tmpXY2.x);
                        };
                        this.getAngleDist = function (a, b) {
                            let p = mathABS(b - a) % (mathPI * 2);
                            return (p > mathPI ? (mathPI * 2) - p : p);
                        };
                        this.isNumber = function (n) {
                            return (typeof n == "number" && !isNaN(n) && isFinite(n));
                        };
                        this.isString = function (s) {
                            return (s && typeof s == "string");
                        };
                        this.kFormat = function (num) {
                            return num > 999 ? (num / 1000).toFixed(1) + "k" : num;
                        };
                        this.sFormat = function (num) {
                            let fixs = [
                                {num: 1e3, string: "k"},
                                {num: 1e6, string: "m"},
                                {num: 1e9, string: "b"},
                                {num: 1e12, string: "q"}
                            ].reverse();
                            let sp = fixs.find(v => num >= v.num);
                            if (!sp) return num;
                            return (num / sp.num).toFixed(1) + sp.string;
                        };
                        this.capitalizeFirst = function (string) {
                            return string.charAt(0).toUpperCase() + string.slice(1);
                        };
                        this.fixTo = function (n, v) {
                            return parseFloat(n.toFixed(v));
                        };
                        this.sortByPoints = function (a, b) {
                            return parseFloat(b.points) - parseFloat(a.points);
                        };
                        this.lineInRect = function (recX, recY, recX2, recY2, x1, y1, x2, y2) {
                            let minX = x1;
                            let maxX = x2;
                            if (x1 > x2) {
                                minX = x2;
                                maxX = x1;
                            }
                            if (maxX > recX2)
                                maxX = recX2;
                            if (minX < recX)
                                minX = recX;
                            if (minX > maxX)
                                return false;
                            let minY = y1;
                            let maxY = y2;
                            let dx = x2 - x1;
                            if (Math.abs(dx) > 0.0000001) {
                                let a = (y2 - y1) / dx;
                                let b = y1 - a * x1;
                                minY = a * minX + b;
                                maxY = a * maxX + b;
                            }
                            if (minY > maxY) {
                                let tmp = maxY;
                                maxY = minY;
                                minY = tmp;
                            }
                            if (maxY > recY2)
                                maxY = recY2;
                            if (minY < recY)
                                minY = recY;
                            if (minY > maxY)
                                return false;
                            return true;
                        };
                        this.containsPoint = function (element, x, y) {
                            let bounds = element.getBoundingClientRect();
                            let left = bounds.left + unsafeWindow.scrollX;
                            let top = bounds.top + unsafeWindow.scrollY;
                            let width = bounds.width;
                            let height = bounds.height;

                            let insideHorizontal = x > left && x < left + width;
                            let insideVertical = y > top && y < top + height;
                            return insideHorizontal && insideVertical;
                        };
                        this.mousifyTouchEvent = function (event) {
                            let touch = event.changedTouches[0];
                            event.screenX = touch.screenX;
                            event.screenY = touch.screenY;
                            event.clientX = touch.clientX;
                            event.clientY = touch.clientY;
                            event.pageX = touch.pageX;
                            event.pageY = touch.pageY;
                        };
                        this.hookTouchEvents = function (element, skipPrevent) {
                            let preventDefault = !skipPrevent;
                            let isHovering = false;
                            // let passive = unsafeWindow.Modernizr.passiveeventlisteners ? {passive: true} : false;
                            let passive = false;
                            element.addEventListener("touchstart", this.checkTrusted(touchStart), passive);
                            element.addEventListener("touchmove", this.checkTrusted(touchMove), passive);
                            element.addEventListener("touchend", this.checkTrusted(touchEnd), passive);
                            element.addEventListener("touchcancel", this.checkTrusted(touchEnd), passive);
                            element.addEventListener("touchleave", this.checkTrusted(touchEnd), passive);

                            function touchStart(e) {
                                _this.mousifyTouchEvent(e);
                                unsafeWindow.setUsingTouch(true);
                                if (preventDefault) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                if (element.onmouseover)
                                    element.onmouseover(e);
                                isHovering = true;
                            }

                            function touchMove(e) {
                                _this.mousifyTouchEvent(e);
                                unsafeWindow.setUsingTouch(true);
                                if (preventDefault) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                if (_this.containsPoint(element, e.pageX, e.pageY)) {
                                    if (!isHovering) {
                                        if (element.onmouseover)
                                            element.onmouseover(e);
                                        isHovering = true;
                                    }
                                } else {
                                    if (isHovering) {
                                        if (element.onmouseout)
                                            element.onmouseout(e);
                                        isHovering = false;
                                    }
                                }
                            }

                            function touchEnd(e) {
                                _this.mousifyTouchEvent(e);
                                unsafeWindow.setUsingTouch(true);
                                if (preventDefault) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                if (isHovering) {
                                    if (element.onclick)
                                        element.onclick(e);
                                    if (element.onmouseout)
                                        element.onmouseout(e);
                                    isHovering = false;
                                }
                            }
                        };
                        this.removeAllChildren = function (element) {
                            while (element.hasChildNodes()) {
                                element.removeChild(element.lastChild);
                            }
                        };
                        this.generateElement = function (config) {
                            let element = document.createElement(config.tag || "div");

                            function bind(configValue, elementValue) {
                                if (config[configValue])
                                    element[elementValue] = config[configValue];
                            }
                            bind("text", "textContent");
                            bind("html", "innerHTML");
                            bind("class", "className");
                            for (let key in config) {
                                switch (key) {
                                    case "tag":
                                    case "text":
                                    case "html":
                                    case "class":
                                    case "style":
                                    case "hookTouch":
                                    case "parent":
                                    case "children":
                                        continue;
                                    default:
                                        break;
                                }
                                element[key] = config[key];
                            }
                            if (element.onclick)
                                element.onclick = this.checkTrusted(element.onclick);
                            if (element.onmouseover)
                                element.onmouseover = this.checkTrusted(element.onmouseover);
                            if (element.onmouseout)
                                element.onmouseout = this.checkTrusted(element.onmouseout);
                            if (config.style) {
                                element.style.cssText = config.style;
                            }
                            if (config.hookTouch) {
                                this.hookTouchEvents(element);
                            }
                            if (config.parent) {
                                config.parent.appendChild(element);
                            }
                            if (config.children) {
                                for (let i = 0; i < config.children.length; i++) {
                                    element.appendChild(config.children[i]);
                                }
                            }
                            return element;
                        };
                        this.checkTrusted = function (callback) {
                            return function (ev) {
                                if (ev && ev instanceof Event && (ev && typeof ev.isTrusted == "boolean" ? ev.isTrusted : true)) {
                                    callback(ev);
                                } else {
                                    //console.error("Event is not trusted.", ev);
                                }
                            };
                        };
                        this.randomString = function (length) {
                            let text = "";
                            let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                            for (let i = 0; i < length; i++) {
                                text += possible.charAt(Math.floor(Math.random() * possible.length));
                            }
                            return text;
                        };
                        this.countInArray = function (array, val) {
                            let count = 0;
                            for (let i = 0; i < array.length; i++) {
                                if (array[i] === val) count++;
                            }
                            return count;
                        };
                        this.hexToRgb = function(hex) {
                            return hex.slice(1).match(/.{1,2}/g).map(g => parseInt(g, 16));
                        };
                        this.getRgb = function(r, g, b) {
                            return [r / 255, g / 255, b / 255].join(", ");
                        };
                    }
                };
                class Animtext {
                    // ANIMATED TEXT:
                    constructor() {
                        // INIT:
                        this.init = function(x, y, scale, speed, life, text, color) {
                            this.x = x;
                            this.y = y;
                            this.color = color;
                            this.scale = scale;
                            this.startScale = this.scale;
                            this.maxScale = scale * 1.5;
                            this.scaleSpeed = 0.7;
                            this.speed = speed;
                            this.life = life;
                            this.text = text;
                            this.acc = 1;
                            this.alpha = 0;
                            this.maxLife = life;
                            this.ranX = UTILS.randFloat(-1, 1);
                        };

                        // UPDATE:
                        this.update = function(delta) {
                            if (this.life) {
                                this.life -= delta;
                                if (config.anotherVisual) {
                                    this.y -= this.speed * delta * this.acc;
                                    this.acc -= delta / (this.maxLife / 2.5);
                                    if (this.life <= 200) {
                                        if (this.alpha > 0) {
                                            this.alpha = Math.max(0, this.alpha - (delta / 300));
                                        }
                                    } else {
                                        if (this.alpha < 1) {
                                            this.alpha = Math.min(1, this.alpha + (delta / 100));
                                        }
                                    }
                                    this.x += this.ranX;
                                } else {
                                    this.y -= this.speed * delta;
                                }
                                this.scale += this.scaleSpeed * delta;
                                if (this.scale >= this.maxScale) {
                                    this.scale = this.maxScale;
                                    this.scaleSpeed *= -1;
                                } else if (this.scale <= this.startScale) {
                                    this.scale = this.startScale;
                                    this.scaleSpeed = 0;
                                }
                                if (this.life <= 0) {
                                    this.life = 0;
                                }
                            }
                        };

                        // RENDER:
                        this.render = function(ctxt, xOff, yOff) {
                            ctxt.lineWidth = 10;
                            ctxt.fillStyle = this.color;
                            ctxt.font = this.scale + "px " + (config.anotherVisual ? "Ubuntu" : "Hammersmith One");
                            if (config.anotherVisual) {
                                ctxt.globalAlpha = this.alpha;
                                ctxt.strokeStyle = darkOutlineColor;
                                ctxt.strokeText(this.text, this.x - xOff, this.y - yOff);
                            }
                            ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
                            ctxt.globalAlpha = 1;
                        };
                    }
                };
                class Textmanager {
                    // TEXT MANAGER:
                    constructor() {
                        this.texts = [];
                        this.stack = [];

                        // UPDATE:
                        this.update = function(delta, ctxt, xOff, yOff) {
                            ctxt.textBaseline = "middle";
                            ctxt.textAlign = "center";
                            for (let i = 0; i < this.texts.length; ++i) {
                                if (this.texts[i].life) {
                                    this.texts[i].update(delta);
                                    this.texts[i].render(ctxt, xOff, yOff);
                                }
                            }
                        };

                        // SHOW TEXT:
                        this.showText = function(x, y, scale, speed, life, text, color) {
                            let tmpText;
                            for(let i = 0; i < this.texts.length; ++i) {
                                if (!this.texts[i].life) {
                                    tmpText = this.texts[i];
                                    break;
                                }
                            }
                            if (!tmpText) {
                                tmpText = new Animtext();
                                this.texts.push(tmpText);
                            }
                            tmpText.init(x, y, scale, speed, life, text, color);
                        };
                    }
                }
                class GameObject {
                    constructor(sid) {
                        this.sid = sid;

                        // INIT:
                        this.init = function (x, y, dir, scale, type, data, owner) {
                            data = data || {};
                            this.sentTo = {};
                            this.gridLocations = [];
                            this.active = true;
                            this.alive = true;
                            this.doUpdate = data.doUpdate;
                            this.x = x;
                            this.y = y;
                            if (config.anotherVisual) {
                                this.dir = dir + Math.PI;
                            } else {
                                this.dir = dir;
                            }
                            this.lastDir = dir;
                            this.xWiggle = 0;
                            this.yWiggle = 0;
                            this.visScale = scale;
                            this.scale = scale;
                            this.type = type;
                            this.id = data.id;
                            this.owner = owner;
                            this.name = data.name;
                            this.isItem = (this.id != undefined);
                            this.group = data.group;
                            this.maxHealth = data.health;
                            this.health = this.maxHealth;
                            this.layer = 2;
                            if (this.group != undefined) {
                                this.layer = this.group.layer;
                            } else if (this.type == 0) {
                                this.layer = 3;
                            } else if (this.type == 2) {
                                this.layer = 0;
                            } else if (this.type == 4) {
                                this.layer = -1;
                            }
                            this.colDiv = data.colDiv || 1;
                            this.blocker = data.blocker;
                            this.ignoreCollision = data.ignoreCollision;
                            this.dontGather = data.dontGather;
                            this.hideFromEnemy = data.hideFromEnemy;
                            this.friction = data.friction;
                            this.projDmg = data.projDmg;
                            this.dmg = data.dmg;
                            this.pDmg = data.pDmg;
                            this.pps = data.pps;
                            this.zIndex = data.zIndex || 0;
                            this.turnSpeed = data.turnSpeed;
                            this.req = data.req;
                            this.trap = data.trap;
                            this.healCol = data.healCol;
                            this.teleport = data.teleport;
                            this.boostSpeed = data.boostSpeed;
                            this.projectile = data.projectile;
                            this.shootRange = data.shootRange;
                            this.shootRate = data.shootRate;
                            this.shootCount = this.shootRate;
                            this.spawnPoint = data.spawnPoint;
                            this.onNear = 0;
                            this.breakObj = false;
                            this.alpha = data.alpha||1;
                            this.maxAlpha = data.alpha||1;
                            this.damaged = 0;
                        };

                        // GET HIT:
                        this.changeHealth = function (amount, doer) {
                            this.health += amount;
                            return (this.health <= 0);
                        };

                        // GET SCALE:
                        this.getScale = function (sM, ig) {
                            sM = sM || 1;
                            return this.name=="teleporter"?200:this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4) ?
                                                                             1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
                        };

                        // VISIBLE TO PLAYER:
                        this.visibleToPlayer = function (player) {
                            return !(this.hideFromEnemy) || (this.owner && (this.owner == player ||
                                                                            (this.owner.team && player.team == this.owner.team)));
                        };

                        // UPDATE:
                        this.update = function (delta) {
                            if (this.active) {
                                if (this.xWiggle) {
                                    this.xWiggle *= Math.pow(0.99, delta);
                                }
                                if (this.yWiggle) {
                                    this.yWiggle *= Math.pow(0.99, delta);
                                }
                                if (config.anotherVisual) {
                                    let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
                                    if (d2 > 0.01) {
                                        this.dir += d2 / 5;
                                    } else {
                                        this.dir = this.lastDir;
                                    }
                                } else {
                                    if (this.turnSpeed && this.dmg) {
                                        this.dir += this.turnSpeed * delta;
                                    }
                                }
                            } else {
                                if (this.alive) {
                                    this.alpha -= delta / (200 / this.maxAlpha);
                                    this.visScale += delta / (this.scale / 2.5);
                                    if (this.alpha <= 0) {
                                        this.alpha = 0;
                                        this.alive = false;
                                    }
                                }
                            }
                        };

                        // CHECK TEAM:
                        this.isTeamObject = function (tmpObj) {
                            return this.owner == null ? true : (this.owner && tmpObj.sid == this.owner.sid || tmpObj.findAllianceBySid(this.owner.sid));
                        };
                    }
                }
                class Items {
                    constructor() {
                        // ITEM GROUPS:
                        this.groups = [
                            {
                                id: 0,
                                name: "food",
                                layer: 0
                            }, {
                                id: 1,
                                name: "walls",
                                place: true,
                                limit: 30,
                                layer: 0
                            }, {
                                id: 2,
                                name: "spikes",
                                place: true,
                                limit: 15,
                                layer: 0
                            }, {
                                id: 3,
                                name: "mill",
                                place: true,
                                limit: 7,
                                layer: 1
                            }, {
                                id: 4,
                                name: "mine",
                                place: true,
                                limit: 1,
                                layer: 0
                            }, {
                                id: 5,
                                name: "trap",
                                place: true,
                                limit: 6,
                                layer: -1
                            }, {
                                id: 6,
                                name: "booster",
                                place: true,
                                limit: 12,
                                layer: -1
                            }, {
                                id: 7,
                                name: "turret",
                                place: true,
                                limit: 2,
                                layer: 1
                            }, {
                                id: 8,
                                name: "watchtower",
                                place: true,
                                limit: 12,
                                layer: 1
                            }, {
                                id: 9,
                                name: "buff",
                                place: true,
                                limit: 4,
                                layer: -1
                            }, {
                                id: 10,
                                name: "spawn",
                                place: true,
                                limit: 1,
                                layer: -1
                            }, {
                                id: 11,
                                name: "sapling",
                                place: true,
                                limit: 2,
                                layer: 0
                            }, {
                                id: 12,
                                name: "blocker",
                                place: true,
                                limit: 3,
                                layer: -1
                            }, {
                                id: 13,
                                name: "teleporter",
                                place: true,
                                limit: 2,
                                layer: -1
                            }];

                        // PROJECTILES:
                        this.projectiles = [{
                            indx: 0,
                            layer: 0,
                            src: "arrow_1",
                            dmg: 25,
                            speed: 1.6,
                            scale: 103,
                            range: 1000
                        }, {
                            indx: 1,
                            layer: 1,
                            dmg: 25,
                            scale: 20,
                            speed:1.5
                        }, {
                            indx: 0,
                            layer: 0,
                            src: "arrow_1",
                            dmg: 35,
                            speed: 2.5,
                            scale: 103,
                            range: 1200
                        }, {
                            indx: 0,
                            layer: 0,
                            src: "arrow_1",
                            dmg: 30,
                            speed: 2,
                            scale: 103,
                            range: 1200
                        }, {
                            indx: 1,
                            layer: 1,
                            dmg: 16,
                            scale: 20
                        }, {
                            indx: 0,
                            layer: 0,
                            src: "bullet_1",
                            dmg: 50,
                            speed: 3.6,
                            scale: 160,
                            range: 1400
                        }];

                        // WEAPONS:
                        this.weapons = [
                            {
                                id: 0,
                                type: 0,
                                name: "tool hammer",
                                desc: "tool for gathering all resources",
                                src: "hammer_1",
                                length: 140,
                                width: 140,
                                xOff: -3,
                                yOff: 18,
                                dmg: 25,
                                range: 65,
                                gather: 1,
                                speed: 300
                            }, {
                                id: 1,
                                type: 0,
                                age: 2,
                                name: "hand axe",
                                desc: "gathers resources at a higher rate",
                                src: "axe_1",
                                length: 140,
                                width: 140,
                                xOff: 3,
                                yOff: 24,
                                dmg: 30,
                                spdMult: 1,
                                range: 70,
                                gather: 2,
                                speed: 400
                            }, {
                                id: 2,
                                type: 0,
                                age: 8,
                                pre: 1,
                                name: "great axe",
                                desc: "deal more damage and gather more resources",
                                src: "great_axe_1",
                                length: 140,
                                width: 140,
                                xOff: -8,
                                yOff: 25,
                                dmg: 35,
                                spdMult: 1,
                                range: 75,
                                gather: 4,
                                speed: 400
                            }, {
                                id: 3,
                                type: 0,
                                age: 2,
                                name: "short sword",
                                desc: "increased attack power but slower move speed",
                                src: "sword_1",
                                iPad: 1.3,
                                length: 130,
                                width: 210,
                                xOff: -8,
                                yOff: 46,
                                dmg: 35,
                                spdMult: 0.85,
                                range: 110,
                                gather: 1,
                                speed: 300
                            }, {
                                id: 4,
                                type: 0,
                                age: 8,
                                pre: 3,
                                name: "katana",
                                desc: "greater range and damage",
                                src: "samurai_1",
                                iPad: 1.3,
                                length: 130,
                                width: 210,
                                xOff: -8,
                                yOff: 59,
                                dmg: 40,
                                spdMult: 0.8,
                                range: 118,
                                gather: 1,
                                speed: 300
                            }, {
                                id: 5,
                                type: 0,
                                age: 2,
                                name: "polearm",
                                desc: "long range melee weapon",
                                src: "spear_1",
                                iPad: 1.3,
                                length: 130,
                                width: 210,
                                xOff: -8,
                                yOff: 53,
                                dmg: 45,
                                knock: 0.2,
                                spdMult: 0.82,
                                range: 142,
                                gather: 1,
                                speed: 700
                            }, {
                                id: 6,
                                type: 0,
                                age: 2,
                                name: "bat",
                                desc: "fast long range melee weapon",
                                src: "bat_1",
                                iPad: 1.3,
                                length: 110,
                                width: 180,
                                xOff: -8,
                                yOff: 53,
                                dmg: 20,
                                knock: 0.7,
                                range: 110,
                                gather: 1,
                                speed: 300
                            }, {
                                id: 7,
                                type: 0,
                                age: 2,
                                name: "daggers",
                                desc: "really fast short range weapon",
                                src: "dagger_1",
                                iPad: 0.8,
                                length: 110,
                                width: 110,
                                xOff: 18,
                                yOff: 0,
                                dmg: 20,
                                knock: 0.1,
                                range: 65,
                                gather: 1,
                                hitSlow: 0.1,
                                spdMult: 1.13,
                                speed: 100
                            }, {
                                id: 8,
                                type: 0,
                                age: 2,
                                name: "stick",
                                desc: "great for gathering but very weak",
                                src: "stick_1",
                                length: 140,
                                width: 140,
                                xOff: 3,
                                yOff: 24,
                                dmg: 1,
                                spdMult: 1,
                                range: 70,
                                gather: 7,
                                speed: 400
                            }, {
                                id: 9,
                                type: 1,
                                age: 6,
                                name: "hunting bow",
                                desc: "bow used for ranged combat and hunting",
                                src: "bow_1",
                                req: ["wood", 4],
                                length: 120,
                                width: 120,
                                xOff: -6,
                                yOff: 0,
                                Pdmg: 25,
                                projectile: 0,
                                spdMult: 0.75,
                                speed: 600
                            }, {
                                id: 10,
                                type: 1,
                                age: 6,
                                name: "great hammer",
                                desc: "hammer used for destroying structures",
                                src: "great_hammer_1",
                                length: 140,
                                width: 140,
                                xOff: -9,
                                yOff: 25,
                                dmg: 10,
                                Pdmg: 10,
                                spdMult: 0.88,
                                range: 75,
                                sDmg: 7.5,
                                gather: 1,
                                speed: 400
                            }, {
                                id: 11,
                                type: 1,
                                age: 6,
                                name: "wooden shield",
                                desc: "blocks projectiles and reduces melee damage",
                                src: "shield_1",
                                length: 120,
                                width: 120,
                                shield: 0.2,
                                xOff: 6,
                                yOff: 0,
                                Pdmg: 0,
                                spdMult: 0.7
                            }, {
                                id: 12,
                                type: 1,
                                age: 8,
                                pre: 9,
                                name: "crossbow",
                                desc: "deals more damage and has greater range",
                                src: "crossbow_1",
                                req: ["wood", 5],
                                aboveHand: true,
                                armS: 0.75,
                                length: 120,
                                width: 120,
                                xOff: -4,
                                yOff: 0,
                                Pdmg: 35,
                                projectile: 2,
                                spdMult: 0.7,
                                speed: 700
                            }, {
                                id: 13,
                                type: 1,
                                age: 9,
                                pre: 12,
                                name: "repeater crossbow",
                                desc: "high firerate crossbow with reduced damage",
                                src: "crossbow_2",
                                req: ["wood", 10],
                                aboveHand: true,
                                armS: 0.75,
                                length: 120,
                                width: 120,
                                xOff: -4,
                                yOff: 0,
                                Pdmg: 30,
                                projectile: 3,
                                spdMult: 0.7,
                                speed: 230
                            }, {
                                id: 14,
                                type: 1,
                                age: 6,
                                name: "mc grabby",
                                desc: "steals resources from enemies",
                                src: "grab_1",
                                length: 130,
                                width: 210,
                                xOff: -8,
                                yOff: 53,
                                dmg: 0,
                                Pdmg: 0,
                                steal: 250,
                                knock: 0.2,
                                spdMult: 1.05,
                                range: 125,
                                gather: 0,
                                speed: 700
                            }, {
                                id: 15,
                                type: 1,
                                age: 9,
                                pre: 12,
                                name: "musket",
                                desc: "slow firerate but high damage and range",
                                src: "musket_1",
                                req: ["stone", 10],
                                aboveHand: true,
                                rec: 0.35,
                                armS: 0.6,
                                hndS: 0.3,
                                hndD: 1.6,
                                length: 205,
                                width: 205,
                                xOff: 25,
                                yOff: 0,
                                Pdmg: 50,
                                projectile: 5,
                                hideProjectile: true,
                                spdMult: 0.6,
                                speed: 1500
                            }];

                        // ITEMS:
                        this.list = [{
                            group: this.groups[0],
                            name: "apple",
                            desc: "restores 20 health when consumed",
                            req: ["food", 10],
                            consume: function (doer) {
                                return doer.changeHealth(20, doer);
                            },
                            scale: 22,
                            holdOffset: 15,
                            healing: 20,
                            itemID: 0,
                            itemAID: 16,
                        }, {
                            age: 3,
                            group: this.groups[0],
                            name: "cookie",
                            desc: "restores 40 health when consumed",
                            req: ["food", 15],
                            consume: function (doer) {
                                return doer.changeHealth(40, doer);
                            },
                            scale: 27,
                            holdOffset: 15,
                            healing: 40,
                            itemID: 1,
                            itemAID: 17,
                        }, {
                            age: 7,
                            group: this.groups[0],
                            name: "cheese",
                            desc: "restores 30 health and another 50 over 5 seconds",
                            req: ["food", 25],
                            consume: function (doer) {
                                if (doer.changeHealth(30, doer) || doer.health < 100) {
                                    doer.dmgOverTime.dmg = -10;
                                    doer.dmgOverTime.doer = doer;
                                    doer.dmgOverTime.time = 5;
                                    return true;
                                }
                                return false;
                            },
                            scale: 27,
                            holdOffset: 15,
                            healing: 30,
                            itemID: 2,
                            itemAID: 18,
                        }, {
                            group: this.groups[1],
                            name: "wood wall",
                            desc: "provides protection for your village",
                            req: ["wood", 10],
                            projDmg: true,
                            health: 380,
                            scale: 50,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 3,
                            itemAID: 19,
                        }, {
                            age: 3,
                            group: this.groups[1],
                            name: "stone wall",
                            desc: "provides improved protection for your village",
                            req: ["stone", 25],
                            health: 900,
                            scale: 50,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 4,
                            itemAID: 20,
                        }, {
                            age: 7,
                            group: this.groups[1],
                            name: "castle wall",
                            desc: "provides powerful protection for your village",
                            req: ["stone", 35],
                            health: 1500,
                            scale: 52,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 5,
                            itemAID: 21,
                        }, {
                            group: this.groups[2],
                            name: "spikes",
                            desc: "damages enemies when they touch them",
                            req: ["wood", 20, "stone", 5],
                            health: 400,
                            dmg: 20,
                            scale: 49,
                            spritePadding: -23,
                            holdOffset: 8,
                            placeOffset: -5,
                            itemID: 6,
                            itemAID: 22,
                        }, {
                            age: 5,
                            group: this.groups[2],
                            name: "greater spikes",
                            desc: "damages enemies when they touch them",
                            req: ["wood", 30, "stone", 10],
                            health: 500,
                            dmg: 35,
                            scale: 52,
                            spritePadding: -23,
                            holdOffset: 8,
                            placeOffset: -5,
                            itemID: 7,
                            itemAID: 23,
                        }, {
                            age: 9,
                            group: this.groups[2],
                            name: "poison spikes",
                            desc: "poisons enemies when they touch them",
                            req: ["wood", 35, "stone", 15],
                            health: 600,
                            dmg: 30,
                            pDmg: 5,
                            scale: 52,
                            spritePadding: -23,
                            holdOffset: 8,
                            placeOffset: -5,
                            itemID: 8,
                            itemAID: 24,
                        }, {
                            age: 9,
                            group: this.groups[2],
                            name: "spinning spikes",
                            desc: "damages enemies when they touch them",
                            req: ["wood", 30, "stone", 20],
                            health: 500,
                            dmg: 45,
                            turnSpeed: 0.003,
                            scale: 52,
                            spritePadding: -23,
                            holdOffset: 8,
                            placeOffset: -5,
                            itemID: 9,
                            itemAID: 25,
                        }, {
                            group: this.groups[3],
                            name: "windmill",
                            desc: "generates gold over time",
                            req: ["wood", 50, "stone", 10],
                            health: 400,
                            pps: 1,
                            turnSpeed: 0.0016,
                            spritePadding: 25,
                            iconLineMult: 12,
                            scale: 45,
                            holdOffset: 20,
                            placeOffset: 5,
                            itemID: 10,
                            itemAID: 26,
                        }, {
                            age: 5,
                            group: this.groups[3],
                            name: "faster windmill",
                            desc: "generates more gold over time",
                            req: ["wood", 60, "stone", 20],
                            health: 500,
                            pps: 1.5,
                            turnSpeed: 0.0025,
                            spritePadding: 25,
                            iconLineMult: 12,
                            scale: 47,
                            holdOffset: 20,
                            placeOffset: 5,
                            itemID: 11,
                            itemAID: 27,
                        }, {
                            age: 8,
                            group: this.groups[3],
                            name: "power mill",
                            desc: "generates more gold over time",
                            req: ["wood", 100, "stone", 50],
                            health: 800,
                            pps: 2,
                            turnSpeed: 0.005,
                            spritePadding: 25,
                            iconLineMult: 12,
                            scale: 47,
                            holdOffset: 20,
                            placeOffset: 5,
                            itemID: 12,
                            itemAID: 28,
                        }, {
                            age: 5,
                            group: this.groups[4],
                            type: 2,
                            name: "mine",
                            desc: "allows you to mine stone",
                            req: ["wood", 20, "stone", 100],
                            iconLineMult: 12,
                            scale: 65,
                            holdOffset: 20,
                            placeOffset: 0,
                            itemID: 13,
                            itemAID: 29,
                        }, {
                            age: 5,
                            group: this.groups[11],
                            type: 0,
                            name: "sapling",
                            desc: "allows you to farm wood",
                            req: ["wood", 150],
                            iconLineMult: 12,
                            colDiv: 0.5,
                            scale: 110,
                            holdOffset: 50,
                            placeOffset: -15,
                            itemID: 14,
                            itemAID: 30,
                        }, {
                            age: 4,
                            group: this.groups[5],
                            name: "pit trap",
                            desc: "pit that traps enemies if they walk over it",
                            req: ["wood", 30, "stone", 30],
                            trap: true,
                            ignoreCollision: true,
                            hideFromEnemy: true,
                            health: 500,
                            colDiv: 0.2,
                            scale: 50,
                            holdOffset: 20,
                            placeOffset: -5,
                            alpha: 0.6,
                            itemID: 15,
                            itemAID: 31,
                        }, {
                            age: 4,
                            group: this.groups[6],
                            name: "boost pad",
                            desc: "provides boost when stepped on",
                            req: ["stone", 20, "wood", 5],
                            ignoreCollision: true,
                            boostSpeed: 1.5,
                            health: 150,
                            colDiv: 0.7,
                            scale: 45,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 16,
                            itemAID: 32,
                        }, {
                            age: 7,
                            group: this.groups[7],
                            doUpdate: true,
                            name: "turret",
                            desc: "defensive structure that shoots at enemies",
                            req: ["wood", 200, "stone", 150],
                            health: 800,
                            projectile: 1,
                            shootRange: 700,
                            shootRate: 2200,
                            scale: 43,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 17,
                            itemAID: 33,
                        }, {
                            age: 7,
                            group: this.groups[8],
                            name: "platform",
                            desc: "platform to shoot over walls and cross over water",
                            req: ["wood", 20],
                            ignoreCollision: true,
                            zIndex: 1,
                            health: 300,
                            scale: 43,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 18,
                            itemAID: 34,
                        }, {
                            age: 7,
                            group: this.groups[9],
                            name: "healing pad",
                            desc: "standing on it will slowly heal you",
                            req: ["wood", 30, "food", 10],
                            ignoreCollision: true,
                            healCol: 15,
                            health: 400,
                            colDiv: 0.7,
                            scale: 45,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 19,
                            itemAID: 35,
                        }, {
                            age: 9,
                            group: this.groups[10],
                            name: "spawn pad",
                            desc: "you will spawn here when you die but it will dissapear",
                            req: ["wood", 100, "stone", 100],
                            health: 400,
                            ignoreCollision: true,
                            spawnPoint: true,
                            scale: 45,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 20,
                            itemAID: 36,
                        }, {
                            age: 7,
                            group: this.groups[12],
                            name: "blocker",
                            desc: "blocks building in radius",
                            req: ["wood", 30, "stone", 25],
                            ignoreCollision: true,
                            blocker: 300,
                            health: 400,
                            colDiv: 0.7,
                            scale: 45,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 21,
                            itemAID: 37,
                        }, {
                            age: 7,
                            group: this.groups[13],
                            name: "teleporter",
                            desc: "teleports you to a random point on the map",
                            req: ["wood", 60, "stone", 60],
                            ignoreCollision: true,
                            teleport: true,
                            health: 200,
                            colDiv: 0.7,
                            scale: 45,
                            holdOffset: 20,
                            placeOffset: -5,
                            itemID: 22,
                            itemAID: 38
                        }];

                        // CHECK ITEM ID:
                        this.checkItem = {
                            index: function(id, myItems) {
                                return [0, 1, 2].includes(id) ? 0 :
                                [3, 4, 5].includes(id) ? 1 :
                                [6, 7, 8, 9].includes(id) ? 2 :
                                [10, 11, 12].includes(id) ? 3 :
                                [13, 14].includes(id) ? 5 :
                                [15, 16].includes(id) ? 4 :
                                [17, 18, 19, 21, 22].includes(id) ?
                                    [13, 14].includes(myItems) ? 6 :
                                5 :
                                id == 20 ?
                                    [13, 14].includes(myItems) ? 7 :
                                6 :
                                undefined;
                            }
                        }

                        // ASSIGN IDS:
                        for (let i = 0; i < this.list.length; ++i) {
                            this.list[i].id = i;
                            if (this.list[i].pre) this.list[i].pre = i - this.list[i].pre;
                        }

                        // TROLOLOLOL:
                        if (typeof window !== "undefined") {
                            function shuffle(a) {
                                for (let i = a.length - 1; i > 0; i--) {
                                    const j = Math.floor(Math.random() * (i + 1));
                                    [a[i], a[j]] = [a[j], a[i]];
                                }
                                return a;
                            }
                            //shuffle(this.list);
                        }
                    }
                }
                class Objectmanager {
                    constructor(GameObject, gameObjects, UTILS, config, players, server) {
                        let mathFloor = Math.floor,
                            mathABS = Math.abs,
                            mathCOS = Math.cos,
                            mathSIN = Math.sin,
                            mathPOW = Math.pow,
                            mathSQRT = Math.sqrt;

                        this.ignoreAdd = false;
                        this.hitObj = [];

                        // DISABLE OBJ:
                        this.disableObj = function (obj) {
                            obj.active = false;
                            if (config.anotherVisual) {
                            } else {
                                obj.alive = false;
                            }
                        };

                        // ADD NEW:
                        let tmpObj;
                        this.add = function (sid, x, y, dir, s, type, data, setSID, owner) {
                            tmpObj = findObjectBySid(sid);
                            if (!tmpObj) {
                                tmpObj = gameObjects.find((tmp) => !tmp.active);
                                if (!tmpObj) {
                                    tmpObj = new GameObject(sid);
                                    gameObjects.push(tmpObj);
                                }
                            }
                            if (setSID) {
                                tmpObj.sid = sid;
                            }
                            tmpObj.init(x, y, dir, s, type, data, owner);
                        };

                        // DISABLE BY SID:
                        this.disableBySid = function (sid) {
                            let find = findObjectBySid(sid);
                            if (find) {
                                this.disableObj(find);
                            }
                        };

                        // REMOVE ALL FROM PLAYER:
                        this.removeAllItems = function(sid, server) {
                            gameObjects.filter((tmp) => tmp.active && tmp.owner && tmp.owner.sid == sid).forEach((tmp) => this.disableObj(tmp));
                        };

                        // CHECK IF PLACABLE:
                        this.checkItemLocation = function(x, y, s, sM, indx, ignoreWater, placer) {
                            let cantPlace = gameObjects.find((tmp) => tmp.active && UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem)));
                            if (cantPlace) return false;
                            if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) return false;
                            return true;
                        };
                        this.customCheckItemLocation = (x, y, s, sM, indx, ignoreWater, placer, ignoreId, gameObjects, UTILS, config) => {
                            let cantPlace = gameObjects.find(
                                tmp =>
                                tmp.active &&
                                tmp.x !== ignoreId.x &&
                                tmp.y !== ignoreId.y &&
                                tmp.id !== ignoreId.id &&
                                UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem))
                            );

                            if (cantPlace) return false;
                            if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) return false;

                            return true;
                        };
                    }
                }
                class Projectile {
                    constructor(players, ais, objectManager, items, config, UTILS, server) {

                        // INIT:
                        this.init = function (indx, x, y, dir, spd, dmg, rng, scl, owner) {
                            this.active = true;
                            this.tickActive = true;
                            this.indx = indx;
                            this.x = x;
                            this.y = y;
                            this.x2 = x;
                            this.y2 = y;
                            this.dir = dir;
                            this.skipMov = true;
                            this.speed = spd;
                            this.dmg = dmg;
                            this.scale = scl;
                            this.range = rng;
                            this.r2 = rng;
                            this.owner = owner;
                        };

                        // UPDATE:
                        this.update = function (delta) {
                            if (this.active) {
                                let tmpSpeed = this.speed * delta;
                                if (!this.skipMov) {
                                    this.x += tmpSpeed * Math.cos(this.dir);
                                    this.y += tmpSpeed * Math.sin(this.dir);
                                    this.range -= tmpSpeed;
                                    if (this.range <= 0) {
                                        this.x += this.range * Math.cos(this.dir);
                                        this.y += this.range * Math.sin(this.dir);
                                        tmpSpeed = 1;
                                        this.range = 0;
                                        this.active = false;
                                    }
                                } else {
                                    this.skipMov = false;
                                }
                            }
                        };
                        this.tickUpdate = function (delta) {
                            if (this.tickActive) {
                                let tmpSpeed = this.speed * delta;
                                if (!this.skipMov) {
                                    this.x2 += tmpSpeed * Math.cos(this.dir);
                                    this.y2 += tmpSpeed * Math.sin(this.dir);
                                    this.r2 -= tmpSpeed;
                                    if (this.r2 <= 0) {
                                        this.x2 += this.r2 * Math.cos(this.dir);
                                        this.y2 += this.r2 * Math.sin(this.dir);
                                        tmpSpeed = 1;
                                        this.r2 = 0;
                                        this.tickActive = false;
                                    }
                                } else {
                                    this.skipMov = false;
                                }
                            }
                        };
                    }
                };
                class Store {
                    constructor() {
                        // STORE HATS:
                        this.hats = [
                            {
                                id: 45,
                                name: "Shame!",
                                dontSell: true,
                                price: 0,
                                scale: 120,
                                desc: "hacks are for winners"
                            }, {
                                id: 51,
                                name: "Moo Cap",
                                price: 0,
                                scale: 120,
                                desc: "coolest mooer around"
                            }, {
                                id: 50,
                                name: "Apple Cap",
                                price: 0,
                                scale: 120,
                                desc: "apple farms remembers"
                            }, {
                                id: 28,
                                name: "Moo Head",
                                price: 0,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 29,
                                name: "Pig Head",
                                price: 0,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 30,
                                name: "Fluff Head",
                                price: 0,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 36,
                                name: "Pandou Head",
                                price: 0,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 37,
                                name: "Bear Head",
                                price: 0,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 38,
                                name: "Monkey Head",
                                price: 0,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 44,
                                name: "Polar Head",
                                price: 0,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 35,
                                name: "Fez Hat",
                                price: 0,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 42,
                                name: "Enigma Hat",
                                price: 0,
                                scale: 120,
                                desc: "join the enigma army"
                            }, {
                                id: 43,
                                name: "Blitz Hat",
                                price: 0,
                                scale: 120,
                                desc: "hey everybody i'm blitz"
                            }, {
                                id: 49,
                                name: "Bob XIII Hat",
                                price: 0,
                                scale: 120,
                                desc: "like and subscribe"
                            }, {
                                id: 57,
                                name: "Pumpkin",
                                price: 50,
                                scale: 120,
                                desc: "Spooooky"
                            }, {
                                id: 8,
                                name: "Bummle Hat",
                                price: 100,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 2,
                                name: "Straw Hat",
                                price: 500,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 15,
                                name: "Winter Cap",
                                price: 600,
                                scale: 120,
                                desc: "allows you to move at normal speed in snow",
                                coldM: 1
                            }, {
                                id: 5,
                                name: "Cowboy Hat",
                                price: 1000,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 4,
                                name: "Ranger Hat",
                                price: 2000,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 18,
                                name: "Explorer Hat",
                                price: 2000,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 31,
                                name: "Flipper Hat",
                                price: 2500,
                                scale: 120,
                                desc: "have more control while in water",
                                watrImm: true
                            }, {
                                id: 1,
                                name: "Marksman Cap",
                                price: 3000,
                                scale: 120,
                                desc: "increases arrow speed and range",
                                aMlt: 1.3
                            }, {
                                id: 10,
                                name: "Bush Gear",
                                price: 3000,
                                scale: 160,
                                desc: "allows you to disguise yourself as a bush"
                            }, {
                                id: 48,
                                name: "Halo",
                                price: 3000,
                                scale: 120,
                                desc: "no effect"
                            }, {
                                id: 6,
                                name: "Soldier Helmet",
                                price: 4000,
                                scale: 120,
                                desc: "reduces damage taken but slows movement",
                                spdMult: 0.94,
                                dmgMult: 0.75
                            }, {
                                id: 23,
                                name: "Anti Venom Gear",
                                price: 4000,
                                scale: 120,
                                desc: "makes you immune to poison",
                                poisonRes: 1
                            }, {
                                id: 13,
                                name: "Medic Gear",
                                price: 5000,
                                scale: 110,
                                desc: "slowly regenerates health over time",
                                healthRegen: 3
                            }, {
                                id: 9,
                                name: "Miners Helmet",
                                price: 5000,
                                scale: 120,
                                desc: "earn 1 extra gold per resource",
                                extraGold: 1
                            }, {
                                id: 32,
                                name: "Musketeer Hat",
                                price: 5000,
                                scale: 120,
                                desc: "reduces cost of projectiles",
                                projCost: 0.5
                            }, {
                                id: 7,
                                name: "Bull Helmet",
                                price: 6000,
                                scale: 120,
                                desc: "increases damage done but drains health",
                                healthRegen: -5,
                                dmgMultO: 1.5,
                                spdMult: 0.96
                            }, {
                                id: 22,
                                name: "Emp Helmet",
                                price: 6000,
                                scale: 120,
                                desc: "turrets won't attack but you move slower",
                                antiTurret: 1,
                                spdMult: 0.7
                            }, {
                                id: 12,
                                name: "Booster Hat",
                                price: 6000,
                                scale: 120,
                                desc: "increases your movement speed",
                                spdMult: 1.16
                            }, {
                                id: 26,
                                name: "Barbarian Armor",
                                price: 8000,
                                scale: 120,
                                desc: "knocks back enemies that attack you",
                                dmgK: 0.6
                            }, {
                                id: 21,
                                name: "Plague Mask",
                                price: 10000,
                                scale: 120,
                                desc: "melee attacks deal poison damage",
                                poisonDmg: 5,
                                poisonTime: 6
                            }, {
                                id: 46,
                                name: "Bull Mask",
                                price: 10000,
                                scale: 120,
                                desc: "bulls won't target you unless you attack them",
                                bullRepel: 1
                            }, {
                                id: 14,
                                name: "Windmill Hat",
                                topSprite: true,
                                price: 10000,
                                scale: 120,
                                desc: "generates points while worn",
                                pps: 1.5
                            }, {
                                id: 11,
                                name: "Spike Gear",
                                topSprite: true,
                                price: 10000,
                                scale: 120,
                                desc: "deal damage to players that damage you",
                                dmg: 0.45
                            }, {
                                id: 53,
                                name: "Turret Gear",
                                topSprite: true,
                                price: 10000,
                                scale: 120,
                                desc: "you become a walking turret",
                                turret: {
                                    proj: 1,
                                    range: 700,
                                    rate: 2500
                                },
                                spdMult: 0.7
                            }, {
                                id: 20,
                                name: "Samurai Armor",
                                price: 12000,
                                scale: 120,
                                desc: "increased attack speed and fire rate",
                                atkSpd: 0.78
                            }, {
                                id: 58,
                                name: "Dark Knight",
                                price: 12000,
                                scale: 120,
                                desc: "restores health when you deal damage",
                                healD: 0.4
                            }, {
                                id: 27,
                                name: "Scavenger Gear",
                                price: 15000,
                                scale: 120,
                                desc: "earn double points for each kill",
                                kScrM: 2
                            }, {
                                id: 40,
                                name: "Tank Gear",
                                price: 15000,
                                scale: 120,
                                desc: "increased damage to buildings but slower movement",
                                spdMult: 0.3,
                                bDmg: 3.3
                            }, {
                                id: 52,
                                name: "Thief Gear",
                                price: 15000,
                                scale: 120,
                                desc: "steal half of a players gold when you kill them",
                                goldSteal: 0.5
                            }, {
                                id: 55,
                                name: "Bloodthirster",
                                price: 20000,
                                scale: 120,
                                desc: "Restore Health when dealing damage. And increased damage",
                                healD: 0.25,
                                dmgMultO: 1.2,
                            }, {
                                id: 56,
                                name: "Assassin Gear",
                                price: 20000,
                                scale: 120,
                                desc: "Go invisible when not moving. Can't eat. Increased speed",
                                noEat: true,
                                spdMult: 1.1,
                                invisTimer: 1000
                            }];

                        // STORE ACCESSORIES:
                        this.accessories = [
                            {
                                id: 12,
                                name: "Snowball",
                                price: 1000,
                                scale: 105,
                                xOff: 18,
                                desc: "no effect"
                            }, {
                                id: 9,
                                name: "Tree Cape",
                                price: 1000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 10,
                                name: "Stone Cape",
                                price: 1000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 3,
                                name: "Cookie Cape",
                                price: 1500,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 8,
                                name: "Cow Cape",
                                price: 2000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 11,
                                name: "Monkey Tail",
                                price: 2000,
                                scale: 97,
                                xOff: 25,
                                desc: "Super speed but reduced damage",
                                spdMult: 1.35,
                                dmgMultO: 0.2
                            }, {
                                id: 17,
                                name: "Apple Basket",
                                price: 3000,
                                scale: 80,
                                xOff: 12,
                                desc: "slowly regenerates health over time",
                                healthRegen: 1
                            }, {
                                id: 6,
                                name: "Winter Cape",
                                price: 3000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 4,
                                name: "Skull Cape",
                                price: 4000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 5,
                                name: "Dash Cape",
                                price: 5000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 2,
                                name: "Dragon Cape",
                                price: 6000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 1,
                                name: "Super Cape",
                                price: 8000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 7,
                                name: "Troll Cape",
                                price: 8000,
                                scale: 90,
                                desc: "no effect"
                            }, {
                                id: 14,
                                name: "Thorns",
                                price: 10000,
                                scale: 115,
                                xOff: 20,
                                desc: "no effect"
                            }, {
                                id: 15,
                                name: "Blockades",
                                price: 10000,
                                scale: 95,
                                xOff: 15,
                                desc: "no effect"
                            }, {
                                id: 20,
                                name: "Devils Tail",
                                price: 10000,
                                scale: 95,
                                xOff: 20,
                                desc: "no effect"
                            }, {
                                id: 16,
                                name: "Sawblade",
                                price: 12000,
                                scale: 90,
                                spin: true,
                                xOff: 0,
                                desc: "deal damage to players that damage you",
                                dmg: 0.15
                            }, {
                                id: 13,
                                name: "Angel Wings",
                                price: 15000,
                                scale: 138,
                                xOff: 22,
                                desc: "slowly regenerates health over time",
                                healthRegen: 3
                            }, {
                                id: 19,
                                name: "Shadow Wings",
                                price: 15000,
                                scale: 138,
                                xOff: 22,
                                desc: "increased movement speed",
                                spdMult: 1.1
                            }, {
                                id: 18,
                                name: "Blood Wings",
                                price: 20000,
                                scale: 178,
                                xOff: 26,
                                desc: "restores health when you deal damage",
                                healD: 0.2
                            }, {
                                id: 21,
                                name: "Corrupt X Wings",
                                price: 20000,
                                scale: 178,
                                xOff: 26,
                                desc: "deal damage to players that damage you",
                                dmg: 0.25
                            }];
                    }
                };
                let timeSinceLastBlock = 0;
                let switchBackTimeout = null;

                class ProjectileManager {
                    constructor(Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
                        this.addProjectile = function (x, y, dir, range, speed, indx, owner, ignoreObj, layer, inWindow) {
                            let tmpData = items.projectiles[indx];
                            let tmpProj;
                            for (let i = 0; i < projectiles.length; ++i) {
                                if (!projectiles[i].active) {
                                    tmpProj = projectiles[i];
                                    break;
                                }
                            }
                            if (!tmpProj) {
                                tmpProj = new Projectile(players, ais, objectManager, items, config, UTILS, server);
                                tmpProj.sid = projectiles.length;
                                projectiles.push(tmpProj);
                            }
                            tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner);
                            tmpProj.ignoreObj = ignoreObj;
                            tmpProj.layer = layer || tmpData.layer;
                            tmpProj.inWindow = inWindow;
                            tmpProj.src = tmpData.src;

                            let d = checkProj(tmpProj, player);
                            if (d && _things.player.weapons[1] == 11) {
                                setTimeout(() => {
                                    _things.aimAt({ x, y });
                                    selectWeapon(player.weapons[1]); // equip shield

                                    const now = Date.now();
                                    if ((now - timeSinceLastBlock) > 3000) {
                                        selectWeapon(player.weapons[1]);
                                    }

                                    timeSinceLastBlock = now;

                                    // 🛡️ Schedule return to main weapon
                                    if (switchBackTimeout) clearTimeout(switchBackTimeout);
                                    switchBackTimeout = setTimeout(() => {
                                        // Make sure no new projectile came in
                                        if (Date.now() - timeSinceLastBlock >= 300) {
                                            chat('Get parried')
                                            selectWeapon(player.weapons[0]); // return to sword or smth
                                            switchBackTimeout = null;
                                        }
                                    }, 300 + d.time); // waits till block then 300ms buffer

                                }, d.time);
                            }

                            return tmpProj;
                        };
                    }
                };

                /**
 * Checks if a projectile will hit the player circle.
 * @param {Object} proj – projectile with { x, y, dir, speed, range }
 * @param {Object} p – player with { x, y, scale, pingTime }
 * @returns {false|{dir: number, time: number}} angle in rads & time before hit (ticks) or false
 */
                function checkProj(proj, p = player) {
                    const dx = p.x - proj.x;
                    const dy = p.y - proj.y;
                    const r = p.scale || 35;           // player radius
                    const dir = proj.dir;
                    const vx = Math.cos(dir);
                    const vy = Math.sin(dir);

                    // Quadratic: t^2 - 2*(dx*vx+dy*vy)*t + (dx^2+dy^2 - r^2) = 0
                    const B = -2 * (dx * vx + dy * vy);
                    const C = dx * dx + dy * dy - r * r;
                    const D = B * B - 4 * C;           // since a=1
                    console.log(
                        UTILS.getDirection(proj,p),proj.dir,
                        UTILS.getDirection(p,proj)//proj.dir,
                    )
                    if (D < 0) return false;           // no intersection, sksksk
                    const sqrtD = Math.sqrt(D);
                    let tHit = (-B - sqrtD) / 2;       // first root
                    if (tHit < 0) tHit = (-B + sqrtD) / 2; // use second if needed

                    // if it hits within projectile range, return dir & time
                    if (tHit >= 0 && tHit <= proj.range) {
                        const time = tHit / proj.speed - (pingTime+(addedTime));
                        return { dir, time:Math.max(0,time) };
                    }
                    return false;
                }
                addedTime=1000
                class AiManager {

                    // AI MANAGER:
                    constructor(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {

                        // AI TYPES:
                        this.aiTypes =[
                            {
                                id: 0,
                                src: "cow_1",
                                killScore: 150,
                                health: 500,
                                weightM: .8,
                                speed: 95e-5,
                                turnSpeed: .001,
                                scale: 72,
                                drop: ["food", 50]
                            }, {
                                id: 1,
                                src: "pig_1",
                                killScore: 200,
                                health: 800,
                                weightM: .6,
                                speed: 85e-5,
                                turnSpeed: .001,
                                scale: 72,
                                drop: ["food", 80]
                            }, {
                                id: 2,
                                name: "Bull",
                                src: "bull_2",
                                hostile: !0,
                                dmg: 20,
                                killScore: 1e3,
                                health: 1800,
                                weightM: .5,
                                speed: 94e-5,
                                turnSpeed: 74e-5,
                                scale: 78,
                                viewRange: 800,
                                chargePlayer: !0,
                                drop: ["food", 100]
                            }, {
                                id: 3,
                                name: "Bully",
                                src: "bull_1",
                                hostile: !0,
                                dmg: 20,
                                killScore: 2e3,
                                health: 2800,
                                weightM: .45,
                                speed: .001,
                                turnSpeed: 8e-4,
                                scale: 90,
                                viewRange: 900,
                                chargePlayer: !0,
                                drop: ["food", 400]
                            }, {
                                id: 4,
                                name: "Wolf",
                                src: "wolf_1",
                                hostile: !0,
                                dmg: 8,
                                killScore: 500,
                                health: 300,
                                weightM: .45,
                                speed: .001,
                                turnSpeed: .002,
                                scale: 84,
                                viewRange: 800,
                                chargePlayer: !0,
                                drop: ["food", 200]
                            }, {
                                id: 5,
                                name: "Quack",
                                src: "chicken_1",
                                dmg: 8,
                                killScore: 2e3,
                                noTrap: !0,
                                health: 300,
                                weightM: .2,
                                speed: .0018,
                                turnSpeed: .006,
                                scale: 70,
                                drop: ["food", 100]
                            }, {
                                id: 6,
                                name: "MOOSTAFA",
                                nameScale: 50,
                                src: "enemy",
                                hostile: !0,
                                dontRun: !0,
                                fixedSpawn: !0,
                                spawnDelay: 6e4,
                                noTrap: !0,
                                colDmg: 100,
                                dmg: 40,
                                killScore: 8e3,
                                health: 18e3,
                                weightM: .4,
                                speed: 7e-4,
                                turnSpeed: .01,
                                scale: 80,
                                spriteMlt: 1.8,
                                leapForce: .9,
                                viewRange: 1e3,
                                hitRange: 210,
                                hitDelay: 1e3,
                                chargePlayer: !0,
                                drop: ["food", 100]
                            }, {
                                id: 7,
                                name: "Treasure",
                                hostile: !0,
                                nameScale: 35,
                                src: "crate_1",
                                fixedSpawn: !0,
                                spawnDelay: 12e4,
                                colDmg: 200,
                                killScore: 5e3,
                                health: 2e4,
                                weightM: .1,
                                speed: 0,
                                turnSpeed: 0,
                                scale: 70,
                                spriteMlt: 1
                            }, {
                                id: 8,
                                name: "MOOFIE",
                                src: "wolf_2",
                                hostile: !0,
                                fixedSpawn: !0,
                                dontRun: !0,
                                hitScare: 4,
                                spawnDelay: 3e4,
                                noTrap: !0,
                                nameScale: 35,
                                dmg: 10,
                                colDmg: 100,
                                killScore: 3e3,
                                health: 7e3,
                                weightM: .45,
                                speed: .0015,
                                turnSpeed: .002,
                                scale: 90,
                                viewRange: 800,
                                chargePlayer: !0,
                                drop: ["food", 1e3]
                            }, {
                                id: 9,
                                name: "ðŸ’€MOOFIE",
                                src: "wolf_2",
                                hostile: !0,
                                fixedSpawn: !0,
                                dontRun: !0,
                                hitScare: 50,
                                spawnDelay: 6e4,
                                noTrap: !0,
                                nameScale: 35,
                                dmg: 12,
                                colDmg: 100,
                                killScore: 3e3,
                                health: 9e3,
                                weightM: .45,
                                speed: .0015,
                                turnSpeed: .0025,
                                scale: 94,
                                viewRange: 1440,
                                chargePlayer: !0,
                                drop: ["food", 3e3],
                                minSpawnRange: .85,
                                maxSpawnRange: .9
                            }, {
                                id: 10,
                                name: "ðŸ’€Wolf",
                                src: "wolf_1",
                                hostile: !0,
                                fixedSpawn: !0,
                                dontRun: !0,
                                hitScare: 50,
                                spawnDelay: 3e4,
                                dmg: 10,
                                killScore: 700,
                                health: 500,
                                weightM: .45,
                                speed: .00115,
                                turnSpeed: .0025,
                                scale: 88,
                                viewRange: 1440,
                                chargePlayer: !0,
                                drop: ["food", 400],
                                minSpawnRange: .85,
                                maxSpawnRange: .9
                            }, {
                                id: 11,
                                name: "ðŸ’€Bully",
                                src: "bull_1",
                                hostile: !0,
                                fixedSpawn: !0,
                                dontRun: !0,
                                hitScare: 50,
                                dmg: 20,
                                killScore: 5e3,
                                health: 5e3,
                                spawnDelay: 1e5,
                                weightM: .45,
                                speed: .00115,
                                turnSpeed: .0025,
                                scale: 94,
                                viewRange: 1440,
                                chargePlayer: !0,
                                drop: ["food", 800],
                                minSpawnRange: .85,
                                maxSpawnRange: .9
                            }]

                        // SPAWN AI:
                        this.spawn = function (x, y, dir, index) {
                            let tmpObj = ais.find((tmp) => !tmp.active);
                            if (!tmpObj) {
                                tmpObj = new AI(ais.length, objectManager, players, items, UTILS, config, scoreCallback, server);
                                ais.push(tmpObj);
                            }
                            tmpObj.init(x, y, dir, index, this.aiTypes[index]);
                            return tmpObj;
                        };
                    }

                };
                class AI {
                    constructor(sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
                        this.sid = sid;
                        this.isAI = true;
                        this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1);

                        // INIT:
                        this.init = function (x, y, dir, index, data) {
                            this.x = x;
                            this.y = y;
                            this.startX = data.fixedSpawn ? x : null;
                            this.startY = data.fixedSpawn ? y : null;
                            this.xVel = 0;
                            this.yVel = 0;
                            this.zIndex = 0;
                            this.dir = dir;
                            this.dirPlus = 0;
                            this.index = index;
                            this.src = data.src;
                            if (data.name) this.name = data.name;
                            this.weightM = data.weightM;
                            this.speed = data.speed;
                            this.killScore = data.killScore;
                            this.turnSpeed = data.turnSpeed;
                            this.scale = data.scale;
                            this.maxHealth = data.health;
                            this.leapForce = data.leapForce;
                            this.health = this.maxHealth;
                            this.chargePlayer = data.chargePlayer;
                            this.viewRange = data.viewRange;
                            this.drop = data.drop;
                            this.dmg = data.dmg;
                            this.hostile = data.hostile;
                            this.dontRun = data.dontRun;
                            this.hitRange = data.hitRange;
                            this.hitDelay = data.hitDelay;
                            this.hitScare = data.hitScare;
                            this.spriteMlt = data.spriteMlt;
                            this.nameScale = data.nameScale;
                            this.colDmg = data.colDmg;
                            this.noTrap = data.noTrap;
                            this.spawnDelay = data.spawnDelay;
                            this.hitWait = 0;
                            this.waitCount = 1000;
                            this.moveCount = 0;
                            this.targetDir = 0;
                            this.active = true;
                            this.alive = true;
                            this.runFrom = null;
                            this.chargeTarget = null;
                            this.dmgOverTime = {};
                        };

                        let tmpRatio = 0;
                        let animIndex = 0;
                        this.animate = function (delta) {
                            if (this.animTime > 0) {
                                this.animTime -= delta;
                                if (this.animTime <= 0) {
                                    this.animTime = 0;
                                    this.dirPlus = 0;
                                    tmpRatio = 0;
                                    animIndex = 0;
                                } else {
                                    if (animIndex == 0) {
                                        tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                        if (tmpRatio >= 1) {
                                            tmpRatio = 1;
                                            animIndex = 1;
                                        }
                                    } else {
                                        tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                                    }
                                }
                            }
                        };

                        // ANIMATION:
                        this.startAnim = function () {
                            this.animTime = this.animSpeed = 600;
                            this.targetAngle = Math.PI * 0.8;
                            tmpRatio = 0;
                            animIndex = 0;
                        };

                    };

                };
                class Petal {
                    constructor(x, y) {
                        this.x = x;
                        this.y = y;
                        this.damage = 10;
                        this.health = 10;
                        this.maxHealth = this.health;
                        this.active = false;
                        this.alive = false;
                        this.timer = 1500;
                        this.time = 0;
                        this.damaged = 0;
                        this.alpha = 1;
                        this.scale = 9;
                        this.visScale = this.scale;
                    }
                };
                class addCh {
                    constructor(x, y, chat, tmpObj) {
                        this.x = x;
                        this.y = y;
                        this.alpha = 0;
                        this.active = true;
                        this.alive = false;
                        this.chat = chat;
                        this.owner = tmpObj;
                    };
                };
                class DeadPlayer {
                    constructor(x, y, dir, buildIndex, weaponIndex, weaponVariant, skinColor, scale, name) {
                        this.x = x;
                        this.y = y;
                        this.lastDir = dir;
                        this.dir = dir + Math.PI;
                        this.buildIndex = buildIndex;
                        this.weaponIndex = weaponIndex;
                        this.weaponVariant = weaponVariant;
                        this.skinColor = skinColor;
                        this.scale = scale;
                        this.visScale = 0;
                        this.name = name;
                        this.alpha = 1;
                        this.active = true;
                        this.animate = function(delta) {
                            let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
                            if (d2 > 0.01) {
                                this.dir += d2 / 20;
                            } else {
                                this.dir = this.lastDir;
                            }
                            if (this.visScale < this.scale) {
                                this.visScale += delta / (this.scale / 2);
                                if (this.visScale >= this.scale) {
                                    this.visScale = this.scale;
                                }
                            }
                            this.alpha -= delta / 30000;
                            if (this.alpha <= 0) {
                                this.alpha = 0;
                                this.active = false;
                            }
                        }
                    }
                };
                setInterval(()=>{if(autoGo&&_things.player&&inGame)_things.player.resetMoveDir()},1000)
                class Player {
                    constructor(id, sid, config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
                        this.id = id;
                        this.sid = sid;
                        this.tmpScore = 0;
                        this.team = null;
                        this.latestSkin = 0;
                        this.oldSkinIndex = 0;
                        this.skinIndex = 0;
                        this.latestTail = 0;
                        this.oldTailIndex = 0;
                        this.tailIndex = 0;
                        this.hitTime = 0;
                        this.lastHit = 0;
                        this.tails = {};
                        for (let i = 0; i < accessories.length; ++i) {
                            if (accessories[i].price <= 0)
                                this.tails[accessories[i].id] = 1;
                        }
                        this.skins = {};
                        for (let i = 0; i < hats.length; ++i) {
                            if (hats[i].price <= 0)
                                this.skins[hats[i].id] = 1;
                        }
                        this.points = 0;
                        this.dt = 0;
                        this.hidden = false;
                        this.itemCounts = {};
                        this.isPlayer = true;
                        this.pps = 0;
                        this.moveDir = undefined;
                        this.skinRot = 0;
                        this.lastPing = 0;
                        this.iconIndex = 0;
                        this.skinColor = 0;
                        this.dist2 = 0;
                        this.aim2 = 0;
                        this.maxSpeed = 1;
                        this.chat = {
                            message: null,
                            count: 0
                        };
                        this.backupNobull = true;
                        this.circle = false;
                        this.circleRad = 200;
                        this.circleRadSpd = 0.1;
                        this.cAngle = 0;

                        // SPAWN:
                        this.spawn = function (moofoll) {
                            this.attacked = false;
                            this.death = false;
                            this.spinDir = 0;
                            this.sync = false;
                            this.antiBull = 0;
                            this.bullTimer = 0;
                            this.poisonTimer = 0;
                            this.active = true;
                            this.alive = true;
                            this.lockMove = false;
                            this.lockDir = false;
                            this.minimapCounter = 0;
                            this.chatCountdown = 0;
                            this.shameCount = 0;
                            this.shameTimer = 0;
                            this.sentTo = {};
                            this.gathering = 0;
                            this.gatherIndex = 0;
                            this.shooting = {};
                            this.shootIndex = 9;
                            this.autoGather = 0;
                            this.animTime = 0;
                            this.animSpeed = 0;
                            this.mouseState = 0;
                            this.buildIndex = -1;
                            this.weaponIndex = 0;
                            this.weaponCode = 0;
                            this.weaponVariant = 0;
                            this.primaryIndex = undefined;
                            this.secondaryIndex = undefined;
                            this.dmgOverTime = {};
                            this.noMovTimer = 0;
                            this.maxXP = 300;
                            this.XP = 0;
                            this.age = 1;
                            this.kills = 0;
                            this.upgrAge = 2;
                            this.upgradePoints = 0;
                            this.x = 0;
                            this.y = 0;
                            this.oldXY = {
                                x: 0,
                                y: 0
                            };
                            this.zIndex = 0;
                            this.xVel = 0;
                            this.yVel = 0;
                            this.slowMult = 1;
                            this.dir = 0;
                            this.dirPlus = 0;
                            this.targetDir = 0;
                            this.targetAngle = 0;
                            this.maxHealth = 100;
                            this.health = this.maxHealth;
                            this.oldHealth = this.maxHealth;
                            this.damaged = 0;
                            this.scale = config.playerScale;
                            this.speed = config.playerSpeed;
                            this.resetMoveDir();
                            this.resetResources(moofoll);
                            this.items = [0, 3, 6, 10];
                            this.weapons = [0];
                            this.shootCount = 0;
                            this.weaponXP = [];
                            this.reloads = {
                                0: 0,
                                1: 0,
                                2: 0,
                                3: 0,
                                4: 0,
                                5: 0,
                                6: 0,
                                7: 0,
                                8: 0,
                                9: 0,
                                10: 0,
                                11: 0,
                                12: 0,
                                13: 0,
                                14: 0,
                                15: 0,
                                53: 0,
                            };
                            this.bowThreat = {
                                9: 0,
                                12: 0,
                                13: 0,
                                15: 0,
                            };
                            this.damageThreat = 0;
                            this.inTrap = false;
                            this.canEmpAnti = false;
                            this.empAnti = false;
                            this.soldierAnti = false;
                            this.poisonTick = 0;
                            this.bullTick = 0;
                            this.setPoisonTick = false;
                            this.setBullTick = false;
                            this.antiTimer = 2;
                        };

                        // RESET MOVE DIR:
                        this.resetMoveDir = function () {
                            this.moveDir = undefined;
                        };

                        // RESET RESOURCES:
                        this.resetResources = function (moofoll) {
                            for (let i = 0; i < config.resourceTypes.length; ++i) {
                                this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                            }
                        };

                        // ADD ITEM:
                        this.getItemType = function(id) {
                            let findindx = this.items.findIndex((ids) => ids == id);
                            if (findindx != -1) {
                                return findindx;
                            } else {
                                return items.checkItem.index(id, this.items);
                            }
                        };

                        // SET DATA:
                        this.setData = function (data) {
                            this.id = data[0];
                            this.sid = data[1];
                            this.name = data[2];
                            this.x = data[3];
                            this.y = data[4];
                            this.dir = data[5];
                            this.health = data[6];
                            this.maxHealth = data[7];
                            this.scale = data[8];
                            this.skinColor = data[9];
                        };

                        // UPDATE POISON TICK:
                        this.updateTimer = function() {

                            this.bullTimer -= 1;
                            if (this.bullTimer <= 0) {
                                this.setBullTick = false;
                                this.bullTick = game.tick - 1;
                                this.bullTimer = config.serverUpdateRate;
                            }
                            this.poisonTimer -= 1;
                            if (this.poisonTimer <= 0) {
                                this.setPoisonTick = false;
                                this.poisonTick = game.tick - 1;
                                this.poisonTimer = config.serverUpdateRate;
                            }

                        };
                        this.update = function(delta) {
                            if (this.sid == playerSID) {
                                this.circleRad = parseInt(getEl("circleRad").value)||0;
                                this.circleRadSpd = parseFloat(getEl("radSpeed").value)||0;
                                this.cAngle += this.circleRadSpd;
                            }
                            if (this.active) {

                                // MOVE:
                                let gear = {
                                    skin: findID(hats, this.skinIndex),
                                    tail: findID(accessories, this.tailIndex)
                                }
                                let spdMult = ((this.buildIndex >= 0) ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (gear.skin ? (gear.skin.spdMult || 1) : 1) * (gear.tail ? (gear.tail.spdMult || 1) : 1) * (this.y <= config.snowBiomeTop ? ((gear.skin && gear.skin.coldM) ? 1 : config.snowSpeed) : 1) * this.slowMult;
                                this.maxSpeed = spdMult;

                            }
                        };

                        let tmpRatio = 0;
                        let animIndex = 0;
                        this.animate = function(delta) {
                            if (this.animTime > 0) {
                                this.animTime -= delta;
                                if (this.animTime <= 0) {
                                    this.animTime = 0;
                                    this.dirPlus = 0;
                                    tmpRatio = 0;
                                    animIndex = 0;
                                } else {
                                    if (animIndex == 0) {
                                        tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                        if (tmpRatio >= 1) {
                                            tmpRatio = 1;
                                            animIndex = 1;
                                        }
                                    } else {
                                        tmpRatio -= delta / (this.animSpeed * (1-config.hitReturnRatio));
                                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                                    }
                                }
                            }
                        };

                        // GATHER ANIMATION:
                        this.startAnim = function (didHit, index) {
                            this.animTime = this.animSpeed = items.weapons[index].speed;
                            this.targetAngle = (didHit ? -config.hitAngle : -Math.PI);
                            tmpRatio = 0;
                            animIndex = 0;
                        };

                        // CAN SEE:
                        this.canSee = function(other) {
                            if (!other) return false;
                            let dx = Math.abs(other.x - this.x) - other.scale;
                            let dy = Math.abs(other.y - this.y) - other.scale;
                            return dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3;
                        };

                        // SHAME SYSTEM:
                        this.judgeShame = function () {
                            if (this.oldHealth < this.health) {
                                if (this.hitTime) {
                                    let timeSinceHit = game.tick - this.hitTime;
                                    this.lastHit = game.tick;
                                    this.hitTime = 0;
                                    if (timeSinceHit < 2) {
                                        this.shameCount++;
                                    } else {
                                        this.shameCount = Math.max(0, this.shameCount - 2);
                                    }
                                }
                            } else if (this.oldHealth > this.health) {
                                this.hitTime = game.tick;
                            }
                        };
                        this.addShameTimer = function () {
                            this.shameCount = 0;
                            this.shameTimer = 30;
                            let interval = setInterval(() => {
                                this.shameTimer--;
                                if (this.shameTimer <= 0) {
                                    clearInterval(interval);
                                }
                            }, 1000);
                        };

                        // CHECK TEAM:
                        this.isTeam = function (tmpObj) {
                            return (this == tmpObj || (this.team && this.team == tmpObj.team));
                        };

                        // FOR THE PLAYER:
                        this.findAllianceBySid = function (sid) {
                            return this.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
                        };
                        this.checkCanInsta = function (nobull) {
                            let totally = 0;
                            if (this.alive && inGame) {
                                let primary = {
                                    weapon: this.weapons[0],
                                    variant: this.primaryVariant,
                                    dmg: this.weapons[0] == undefined ? 0 : items.weapons[this.weapons[0]].dmg,
                                };
                                let secondary = {
                                    weapon: this.weapons[1],
                                    variant: this.secondaryVariant,
                                    dmg: this.weapons[1] == undefined ? 0 : items.weapons[this.weapons[1]].Pdmg,
                                };
                                let bull = this.skins[7] && !nobull ? 1.5 : 1;
                                let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1;
                                if (primary.weapon != undefined && this.reloads[primary.weapon] == 0) {
                                    totally += primary.dmg * pV * bull;
                                }
                                if (secondary.weapon != undefined && this.reloads[secondary.weapon] == 0) {
                                    totally += secondary.dmg;
                                }
                                if (this.skins[53] && this.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate) && near.skinIndex != 22) {
                                    totally += 25;
                                }
                                totally *= near.skinIndex == 6 ? 0.75 : 1;
                                return totally;
                            }
                            return 0;
                        };

                        // UPDATE WEAPON RELOAD:
                        this.manageReload = function () {
                            if (this.shooting[53]) {
                                this.shooting[53] = 0;
                                this.reloads[53] = (2500 - game.tickRate);
                            } else {
                                if (this.reloads[53] > 0) {
                                    this.reloads[53] = Math.max(0, this.reloads[53] - game.tickRate);
                                }
                            }
                            if (this.gathering || this.shooting[1]) {
                                if (this.gathering) {
                                    this.gathering = 0;
                                    this.reloads[this.gatherIndex] = (items.weapons[this.gatherIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                                    this.attacked = true;
                                }
                                if (this.shooting[1]) {
                                    this.shooting[1] = 0;
                                    this.reloads[this.shootIndex] = (items.weapons[this.shootIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                                    this.attacked = true;
                                }
                            } else {
                                this.attacked = false;
                                if (this.buildIndex < 0) {
                                    if (this.reloads[this.weaponIndex] > 0) {
                                        this.reloads[this.weaponIndex] = Math.max(0, this.reloads[this.weaponIndex] - game.tickRate);
                                        if (this == player) {
                                            const usingTP = _things.player.items.includes(22);
                                            const stopped = usingTP
                                            ? (autoGo && _things.player.x2 === _things.player.x && _things.player.y2 === _things.player.y)
                                            : true;
                                            function getCircleAngles(placements) {
                                                // Returns an array of evenly spaced angles (radians) for a circle
                                                let out = [];
                                                for (let i = 0; i < placements; i++) {
                                                    out.push((Math.PI * 2) * (i / placements));
                                                }
                                                return out;
                                            }

                                            // only grind when checkbox’s lit AND (botmode off OR we’ve teleported & stopped)
                                            if (getEl("weaponGrind").checked && (!autoGo || stopped)) {
                                                const itemType = player.getItemType(22);
                                                // angles: top, right, bottom, left
                                                var placements =2,angles = usingTP?[-1.33, 0]:getCircleAngles(8)

                                                angles.forEach(angle => checkPlace(itemType, angle));
                                            }
                                        }
                                        if (this.reloads[this.primaryIndex] == 0 && this.reloads[this.weaponIndex] == 0) {
                                            this.antiBull++;
                                            game.tickBase(() => {
                                                this.antiBull = 0;
                                            }, 1);
                                        }
                                    }
                                }
                            }
                        };
                        this.validateBuilding=(e)=>{
                            if (UTILS.getDistance(player, e) > 100 + e.scale * 2) {
                                return false;
                            }
                            if (!e.currentHealth) {
                                return;
                            }
                            let t = 0;
                            for (let i = 0; i < players.length; i++) {
                                let s = players[i];
                                if (s.visible && UTILS.getDistance(s, e) <= 100 + e.scale * 2) {
                                    let n = s.secondaryWeapon == 10 ? 10 : s.primaryWeapon;
                                    let a = config.weaponVariants[n == 10 ? s.secondaryVariant : s.primaryVariant].val;
                                    let l = items.weapons[n];
                                    let o = l.dmg * (l.sDmg || 1) * (a || 1);
                                    if (playerSID == s.sid) {
                                        if (s.skins[40]) {
                                            o *= 3.3;
                                        }
                                    } else {
                                        o *= 3.3;
                                    }
                                    if (!!(UTILS.getDistance(s, e) - e.scale < l.range) && healer.reloadPercent(s, n) == 1 && (!e.trap || !e.hideFromEnemy)) {
                                        t += o;
                                    }
                                }
                            }
                            return e.currentHealth <= t;
                        }
                        this.findOpenAngles=function(e){
                            let t = Math.PI / parseInt(16);
                            let i = [0, Math.PI];
                            let s = player.items[2];
                            let n = items.list[s];
                            let a = items.list[15];
                            let l = [];
                            let o = Math.max(n.scale, a.scale);
                            let r = game.closeObjects.filter(e => e.active && UTILS.getDistance(e, player) <= 35 + o + e.scale);
                            for (let c = 0; c <= Math.PI; c += t) {
                                for (let d = 0; d < i.length; d++) {
                                    let p = c + i[d];
                                    this.validateOpenAngle(p, l, e, r);
                                }
                            }
                            if (false){//scriptMenu.toggles.dualAngleFinder) {
                                for (let h = 0; h < r.length; h++) {
                                    let g = r[h];
                                    let $ = r[(h + 1) % r.length];
                                    if (g && $) {
                                        let m = UTILS.getDirection(g, player);
                                        let u = UTILS.getDirection($, player);
                                        if (m < 0) {
                                            m += Math.PI * 2;
                                        }
                                        if (u < 0) {
                                            u += Math.PI * 2;
                                        }
                                        let f = (m + u) / 2;
                                        if (Math.abs(m - u) > Math.PI && (f += Math.PI) > Math.PI * 2) {
                                            f -= Math.PI * 2;
                                        }
                                        this.validateOpenAngle(f, l, e, r);
                                    }
                                }
                            }
                            return l.sort((e, t) => e.enemyDist - t.enemyDist).sort((e, t) => e.brokenDist - t.brokenDist).sort((e, t) => t.prioritization - e.prioritization);
                        }
                        this.preplacer_=function(){
                            if (getEl("weaponGrind").checked) {
                                for (let i = 0; i < Math.PI * 2; i+= Math.PI / 2) {
                                    checkPlace(player.getItemType(22), i);
                                }
                            }
                            let e = liztobj.filter(e => e.active && this.validateBuilding(e));
                            if (!e.length) {
                                return;
                            }

                            e = this.validateClashWithEnemy(e);
                            let t = this.findOpenAngles(e);
                            let i = liztobj.filter(e => e.active && e.trap && e.isTeamObject(player) && UTILS.getDistance(e, player) <= 300);

                            for (let s = 0; s < t.length; s++) {
                                let n = t[s];
                                let a = n.enemy;
                                let l = a.trap;
                                let o = UTILS.getDistance(a, player);

                                if (l && n.spike) {
                                    if (UTILS.getDistance(n.pos.spike, l) <= 130) {
                                        this.checkPlace(player.items[2], n.angle, undefined, a);
                                        if (this.preplacements > 2) break;
                                    } else if (n.trap && this.checkPlace(player.items[4], n.angle, undefined, a)) {
                                        if (this.preplacements > 2) break;
                                    }
                                } else if (o <= 200) {
                                    if (n.spike) {
                                        let r = n.pos.spike;
                                        if (UTILS.getDistance(r, a) <= 100) {
                                            let c = kbSimulator.spikeKB({
                                                x: a.x2,
                                                y: a.y2,
                                                scale: 35,
                                                tmpObj: a
                                            }, r, true);

                                            let d = () => this.checkPlace(player.items[2], n.angle, undefined, a);
                                            if (c.data.some(e => e.id == "trap")) {
                                                d();
                                                if (this.preplacements > 2) break;
                                            } else if (c.data.some(e => e.id == "spiek")) {
                                                let totalDamage = c.data.filter(e => e.id == "spiek").reduce((sum, t) => sum + t.dmg, 0) + r.dmg;
                                                if (totalDamage >= 100) {
                                                    d();
                                                    if (this.preplacements > 2) break;
                                                } else if (n.trap && this.checkPlace(player.items[4], n.angle, undefined, a)) {
                                                    if (this.preplacements > 2) break;
                                                }
                                            } else if (n.trap && this.checkPlace(player.items[4], n.angle, undefined, a)) {
                                                if (this.preplacements > 2) break;
                                            }
                                        } else if (UTILS.getAngleDist(game.enemies.angle, n.angle) <= 0.75 && i.find(e => UTILS.getDistance(r, e) <= 135)) {
                                            this.checkPlace(player.items[2], n.angle, undefined, a);
                                            if (this.preplacements > 2) break;
                                        } else if (n.trap && this.checkPlace(player.items[4], n.angle, undefined, a)) {
                                            if (this.preplacements > 2) break;
                                        }
                                    } else if (n.trap && this.checkPlace(player.items[4], n.angle, undefined, a)) {
                                        if (this.preplacements > 2) break;
                                    }
                                } else if (n.trap && this.checkPlace(player.items[4], n.angle, undefined, a)) {
                                    if (this.preplacements > 2) break;
                                }
                            }
                            this.preplacements = 0;
                        }
                        this.preplacer = function () {
                            if (traps.inTrap) return;
                            if (!configs.autoPrePlace) return;

                            const weaponRange = items.weapons[player.weaponIndex].range + 70;
                            const rangeSquared = weaponRange ** 2;
                            const { x2: playerX, y2: playerY } = player;

                            const lowHealthGameObjects = gameObjects.filter(gameObject => {
                                const { x2, y2, buildHealth } = gameObject;
                                const distSquared = (x2 - playerX) ** 2 + (y2 - playerY) ** 2;
                                return near && buildHealth <= 272.58 && distSquared <= rangeSquared;
                            });

                            if (lowHealthGameObjects.length > 0) {
                                const { x2, y2 } = lowHealthGameObjects[0];
                                const objAim = UTILS.getDirect({ x2, y2 }, player, 0, 2);
                                const trapPlacementRadius = 70;

                                let enemyVelocity = Math.sqrt(near.xVel * near.xVel + near.yVel * near.yVel);
                                let enemyDirection = Math.atan2(near.yVel, near.xVel);

                                let bestAngle = null;
                                let bestDistance = Infinity;

                                for (let i = 0; i < 360; i += 30) {
                                    let simulatedAngle = UTILS.deg2rad(i);
                                    let distance =
                                        UTILS.getDist(near, player, 0, 2) +
                                        enemyVelocity * Math.sin(enemyDirection) +
                                        trapPlacementRadius;

                                    if (distance < bestDistance) {
                                        bestDistance = distance;
                                        bestAngle = simulatedAngle;
                                    }
                                }

                                const trapPlacementTime = 5;
                                const timeToBreak = (lowHealthGameObjects[0].buildHealth - player.damage) / (player.damagePerShot - lowHealthGameObjects[0].absorb);
                                const enemyTimeToMoveOut = bestDistance / enemyVelocity;

                                if (timeToBreak + trapPlacementTime <= enemyTimeToMoveOut) {
                                    this.testCanPlace(4, bestAngle, bestAngle + Math.PI * 2, Math.PI / 24, objAim, trapPlacementRadius);
                                }
                            }
                        };

                        // FOR ANTI INSTA:
                        this.addDamageThreat = function (tmpObj) {
                            let primary = {
                                weapon: this.primaryIndex,
                                variant: this.primaryVariant
                            };
                            primary.dmg = primary.weapon == undefined ? 45 : items.weapons[primary.weapon].dmg;
                            let secondary = {
                                weapon: this.secondaryIndex,
                                variant: this.secondaryVariant
                            };
                            secondary.dmg = secondary.weapon == undefined ? 50 : items.weapons[secondary.weapon].Pdmg;
                            let bull = 1.5;
                            let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
                            let sV = secondary.variant != undefined ? [9, 12, 13, 15].includes(secondary.weapon) ? 1 : config.weaponVariants[secondary.variant].val : 1.18;
                            if (primary.weapon == undefined ? true : this.reloads[primary.weapon] == 0) {
                                this.damageThreat += primary.dmg * pV * bull;
                            }
                            if (secondary.weapon == undefined ? true : this.reloads[secondary.weapon] == 0) {
                                this.damageThreat += secondary.dmg * sV;
                            }
                            if (this.reloads[53] <= game.tickRate) {
                                this.damageThreat += 25;
                            }
                            this.damageThreat *= tmpObj.skinIndex == 6 ? 0.75 : 1;
                            if (!this.isTeam(tmpObj)) {
                                if (this.dist2 <= 300) {
                                    tmpObj.damageThreat += this.damageThreat;
                                }
                            }
                        };

                    }
                };
                function getDistance(x1, y1, x2, y2) {
                    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                }
                unsafeWindow.accessories = [
                    {
                        id: 12,
                        name: "Snowball",
                        price: 1000,
                        scale: 105,
                        xOff: 18,
                        desc: "no effect"
                    }, {
                        id: 9,
                        name: "Tree Cape",
                        price: 1000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 10,
                        name: "Stone Cape",
                        price: 1000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 3,
                        name: "Cookie Cape",
                        price: 1500,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 8,
                        name: "Cow Cape",
                        price: 2000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 11,
                        name: "Monkey Tail",
                        price: 2000,
                        scale: 97,
                        xOff: 25,
                        desc: "Super speed but reduced damage",
                        spdMult: 1.35,
                        dmgMultO: 0.2
                    }, {
                        id: 17,
                        name: "Apple Basket",
                        price: 3000,
                        scale: 80,
                        xOff: 12,
                        desc: "slowly regenerates health over time",
                        healthRegen: 1
                    }, {
                        id: 6,
                        name: "Winter Cape",
                        price: 3000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 4,
                        name: "Skull Cape",
                        price: 4000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 5,
                        name: "Dash Cape",
                        price: 5000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 2,
                        name: "Dragon Cape",
                        price: 6000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 1,
                        name: "Super Cape",
                        price: 8000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 7,
                        name: "Troll Cape",
                        price: 8000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 14,
                        name: "Thorns",
                        price: 10000,
                        scale: 115,
                        xOff: 20,
                        desc: "no effect"
                    }, {
                        id: 15,
                        name: "Blockades",
                        price: 10000,
                        scale: 95,
                        xOff: 15,
                        desc: "no effect"
                    }, {
                        id: 20,
                        name: "Devils Tail",
                        price: 10000,
                        scale: 95,
                        xOff: 20,
                        desc: "no effect"
                    }, {
                        id: 16,
                        name: "Sawblade",
                        price: 12000,
                        scale: 90,
                        spin: true,
                        xOff: 0,
                        desc: "deal damage to players that damage you",
                        dmg: 0.15
                    }, {
                        id: 13,
                        name: "Angel Wings",
                        price: 15000,
                        scale: 138,
                        xOff: 22,
                        desc: "slowly regenerates health over time",
                        healthRegen: 3
                    }, {
                        id: 19,
                        name: "Shadow Wings",
                        price: 15000,
                        scale: 138,
                        xOff: 22,
                        desc: "increased movement speed",
                        spdMult: 1.1
                    }, {
                        id: 18,
                        name: "Blood Wings",
                        price: 20000,
                        scale: 178,
                        xOff: 26,
                        desc: "restores health when you deal damage",
                        healD: 0.2
                    }, {
                        id: 21,
                        name: "Corrupt X Wings",
                        price: 20000,
                        scale: 178,
                        xOff: 26,
                        desc: "deal damage to players that damage you",
                        dmg: 0.25
                    }];
                unsafeWindow.weapons = [
                    { id: 0, type: 0, name: "tool hammer", desc: "tool for gathering all resources", src: "hammer_1", length: 140, width: 140, xeOff: -3, yOff: 18, dmg: 25, range: 65, gather: 1, speed: 300 }, { id: 1, type: 0, age: 2, name: "hand axe", desc: "gathers resources at a higher rate", src: "axe_1", length: 140, width: 140, xOff: 3, yOff: 24, dmg: 30, spdMult: 1, range: 70, gather: 2, speed: 400 }, { id: 2, type: 0, age: 8, pre: 1, name: "great axe", desc: "deal more damage and gather more resources", src: "great_axe_1", length: 140, width: 140, xOff: -8, yOff: 25, dmg: 35, spdMult: 1, range: 75, gather: 4, speed: 400 }, { id: 3, type: 0, age: 2, name: "short sword", desc: "increased attack power but slower move speed", src: "sword_1", iPad: 1.3, length: 130, width: 210, xOff: -8, yOff: 46, dmg: 35, spdMult: .85, range: 110, gather: 1, speed: 300 }, { id: 4, type: 0, age: 8, pre: 3, name: "katana", desc: "greater range and damage", src: "samurai_1", iPad: 1.3, length: 130, width: 210, xOff: -8, yOff: 59, dmg: 40, spdMult: .8, range: 118, gather: 1, speed: 300 }, { id: 5, type: 0, age: 2, name: "polearm", desc: "long range melee weapon", src: "spear_1", iPad: 1.3, length: 130, width: 210, xOff: -8, yOff: 53, dmg: 45, knock: .2, spdMult: .82, range: 142, gather: 1, speed: 700 }, { id: 6, type: 0, age: 2, name: "bat", desc: "fast long range melee weapon", src: "bat_1", iPad: 1.3, length: 110, width: 180, xOff: -8, yOff: 53, dmg: 20, knock: .7, range: 110, gather: 1, speed: 300 }, { id: 7, type: 0, age: 2, name: "daggers", desc: "really fast short range weapon", src: "dagger_1", iPad: .8, length: 110, width: 110, xOff: 18, yOff: 0, dmg: 20, knock: .1, range: 65, gather: 1, hitSlow: .1, spdMult: 1.13, speed: 100 }, { id: 8, type: 0, age: 2, name: "stick", desc: "great for gathering but very weak", src: "stick_1", length: 140, width: 140, xOff: 3, yOff: 24, dmg: 1, spdMult: 1, range: 70, gather: 7, speed: 400 }, { id: 9, type: 1, age: 6, name: "hunting bow", desc: "bow used for ranged combat and hunting", src: "bow_1", req: ["wood", 4], length: 120, width: 120, xOff: -6, yOff: 0, projectile: 0, spdMult: .75, speed: 600 }, { id: 10, type: 1, age: 6, name: "great hammer", desc: "hammer used for destroying structures", src: "great_hammer_1", length: 140, width: 140, xOff: -9, yOff: 25, dmg: 10, spdMult: .88, range: 75, sDmg: 7.5, gather: 1, speed: 400, hatid: 40 }, { id: 11, type: 1, age: 6, name: "wooden shield", desc: "blocks projectiles and reduces melee damage", src: "shield_1", length: 120, width: 120, shield: .2, xOff: 6, yOff: 0, spdMult: .7, speed: 0 }, { id: 12, type: 1, age: 8, pre: 9, name: "crossbow", desc: "deals more damage and has greater range", src: "crossbow_1", req: ["wood", 5], aboveHand: !0, armS: .75, length: 120, width: 120, xOff: -4, yOff: 0, projectile: 2, spdMult: .7, speed: 700, hatid: 20 }, { id: 13, type: 1, age: 9, pre: 12, name: "repeater crossbow", desc: "high firerate crossbow with reduced damage", src: "crossbow_2", req: ["wood", 10], aboveHand: !0, armS: .75, length: 120, width: 120, xOff: -4, yOff: 0, projectile: 3, spdMult: .7, speed: 300, hatid: 20 }, { id: 14, type: 1, age: 6, name: "mc grabby", desc: "steals resources from enemies", src: "grab_1", length: 130, width: 210, xOff: -8, yOff: 53, dmg: 0, steal: 250, knock: .2, spdMult: 1.05, range: 125, gather: 0, speed: 700 }, { id: 15, type: 1, age: 9, pre: 12, name: "musket", desc: "slow firerate but high damage and range", src: "musket_1", req: ["stone", 10], aboveHand: !0, rec: .35, armS: .6, hndS: .3, hndD: 1.6, length: 205, width: 205, xOff: 25, yOff: 0, projectile: 5, hideProjectile: !0, spdMult: .6, speed: 1500, hatid: 20 }],unsafeWindow.activeObjects = [{ name: "apple", desc: "restores 20 health when consumed", req: ["food", 10], consume: function (e) { return e.changeHealth(20, e) }, scale: 22, holdOffset: 15 }, { age: 3, name: "cookie", desc: "restores 40 health when consumed", req: ["food", 15], consume: function (e) { return e.changeHealth(40, e) }, scale: 27, holdOffset: 15 }, { age: 7, name: "pizza", desc: "restores 30 health and another 50 over 5 seconds", req: ["food", 30], consume: function (e) { return !!(e.changeHealth(30, e) || e.health < 100) && (e.dmgOverTime.dmg = -10, e.dmgOverTime.doer = e, e.dmgOverTime.time = 5, !0) }, scale: 27, holdOffset: 15 }, { name: "wood wall", desc: "provides protection for your village", req: ["wood", 10], projDmg: !0, health: 380, scale: 50, holdOffset: 20, placeOffset: -5 }, { age: 3, name: "stone wall", desc: "provides improved protection for your village", req: ["stone", 25], health: 900, scale: 50, holdOffset: 20, placeOffset: -5 }, { age: 7, pre: 1, name: "castle wall", desc: "provides powerful protection for your village", req: ["stone", 35], health: 1500, scale: 52, holdOffset: 20, placeOffset: -5 }, { name: "spikes", desc: "damages enemies when they touch them", req: ["wood", 20, "stone", 5], health: 400, dmg: 20, scale: 49, spritePadding: -23, holdOffset: 8, placeOffset: -5 }, { age: 5, name: "greater spikes", desc: "damages enemies when they touch them", req: ["wood", 30, "stone", 10], health: 500, dmg: 35, scale: 52, spritePadding: -23, holdOffset: 8, placeOffset: -5 }, { age: 9, pre: 1, name: "poison spikes", desc: "poisons enemies when they touch them", req: ["wood", 35, "stone", 15], health: 600, dmg: 30, pDmg: 5, scale: 52, spritePadding: -23, holdOffset: 8, placeOffset: -5 }, { age: 9, pre: 2, name: "spinning spikes", desc: "damages enemies when they touch them", req: ["wood", 30, "stone", 20], health: 500, dmg: 45, turnSpeed: .003, scale: 52, spritePadding: -23, holdOffset: 8, placeOffset: -5 }, { name: "windmill", desc: "generates gold over time", req: ["wood", 50, "stone", 10], health: 400, pps: 1, turnSpeed: .0016, spritePadding: 25, iconLineMult: 12, scale: 45, holdOffset: 20, placeOffset: 5 }, { age: 5, pre: 1, name: "faster windmill", desc: "generates more gold over time", req: ["wood", 60, "stone", 20], health: 500, pps: 1.5, turnSpeed: .0025, spritePadding: 25, iconLineMult: 12, scale: 47, holdOffset: 20, placeOffset: 5 }, { age: 8, pre: 1, name: "power mill", desc: "generates more gold over time", req: ["wood", 100, "stone", 50], health: 800, pps: 2, turnSpeed: .005, spritePadding: 25, iconLineMult: 12, scale: 47, holdOffset: 20, placeOffset: 5 }, { age: 5, type: 2, name: "mine", desc: "allows you to mine stone", req: ["wood", 20, "stone", 100], iconLineMult: 12, scale: 65, holdOffset: 20, placeOffset: 0 }, { age: 5, type: 0, name: "sapling", desc: "allows you to farm wood", req: ["wood", 150], iconLineMult: 12, colDiv: .5, scale: 110, holdOffset: 50, placeOffset: -15 }, { age: 4, name: "pit trap", desc: "pit that traps enemies if they walk over it", req: ["wood", 30, "stone", 30], trap: !0, ignoreCollision: !0, hideFromEnemy: !0, health: 500, colDiv: .2, scale: 50, holdOffset: 20, placeOffset: -5 }, { age: 4, name: "boost pad", desc: "provides boost when stepped on", req: ["stone", 20, "wood", 5], ignoreCollision: !0, boostSpeed: 1.5, health: 150, colDiv: .7, scale: 45, holdOffset: 20, placeOffset: -5 }, { age: 7, doUpdate: !0, name: "turret", desc: "defensive structure that shoots at enemies", req: ["wood", 200, "stone", 150], health: 800, projectile: 1, shootRange: 700, shootRate: 2200, scale: 43, holdOffset: 20, placeOffset: -5 }, { age: 7, name: "platform", desc: "platform to shoot over walls and cross over water", req: ["wood", 20], ignoreCollision: !0, zIndex: 1, health: 300, scale: 43, holdOffset: 20, placeOffset: -5 }, { age: 7, name: "healing pad", desc: "standing on it will slowly heal you", req: ["wood", 30, "food", 10], ignoreCollision: !0, healCol: 15, health: 400, colDiv: .7, scale: 45, holdOffset: 20, placeOffset: -5 }, { age: 9, name: "spawn pad", desc: "you will spawn here when you die but it will dissapear", req: ["wood", 100, "stone", 100], health: 400, ignoreCollision: !0, spawnPoint: !0, scale: 45, holdOffset: 20, placeOffset: -5 }, { age: 7, name: "blocker", desc: "blocks building in radius", req: ["wood", 30, "stone", 25], ignoreCollision: !0, blocker: 300, health: 400, colDiv: .7, scale: 45, holdOffset: 20, placeOffset: -5 }, { age: 7, name: "teleporter", desc: "teleports you to a random point on the map", req: ["wood", 60, "stone", 60], ignoreCollision: !0, teleport: !0, health: 200, colDiv: .7, scale: 45, holdOffset: 20, placeOffset: -5 }];


                function findClosestList(playerX, playerY, aiList) {
                    let closestAI = null;
                    let closestDistance = Infinity;

                    aiList.forEach(ai => {
                        if (true) {
                            const distance = getDistance(playerX, playerY, ai.x, ai.y);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestAI = ai;
                            }
                        }
                    });

                    return closestAI;
                }
                const rangedWeapons = unsafeWindow.weapons.filter(weapon => weapon.projectile !== undefined);
                function hasRangedWeapon(equippedWeapons) {
                    return equippedWeapons.some(weaponId =>
                                                rangedWeapons.some(rangedWeapon => rangedWeapon.id === weaponId)
                                               );
                }

                function isAIInRange(player, ai) {
                    const playerWeapons = player.weapons; // [primaryWeaponId, secondaryWeaponId]
                    const primaryWeapon = weapons.find(w => w.id === playerWeapons[0]);
                    const secondaryWeapon = weapons.find(w => w.id === playerWeapons[1]);

                    // Calculate distance between player and AI
                    const distanceToAI = getDistance(player.x, player.y, ai.x, ai.y);

                    // Check if AI is within range of either weapon
                    const isInPrimaryRange = distanceToAI <= (primaryWeapon.range + 100);
                    const isInSecondaryRange = secondaryWeapon && (distanceToAI <= secondaryWeapon.range) || false;

                    return isInPrimaryRange || isInSecondaryRange;
                }

                function getDirection(player, target) {
                    // Calculate the difference in x and y coordinates
                    const dx = target.x - player.x;
                    const dy = target.y - player.y;

                    // Calculate the angle in radians
                    const angleRad = Math.atan2(dy, dx);

                    // Ensure the angle is in the range [0, 2*PI)
                    const direction = (angleRad + 2 * Math.PI) % (2 * Math.PI);

                    return direction;
                }

                unsafeWindow.allowChats=true
                function sendChat(msg){

                    unsafeWindow.allowChats&&packet("6", msg)
                }

                // SOME CODES:
                function sendUpgrade(index) {
                    player.reloads[index] = 0;
                    packet("H", index);
                }

                function storeEquip(id, index) {
                    packet("c", 0, id, index);
                }

                function storeBuy(id, index) {
                    packet("c", 1, id, index);
                }

                function buyEquip(id, index) {
                    let nID = player.skins[6] ? 6 : 0;
                    if (player.alive && inGame) {
                        if (index == 0) {
                            if (player.skins[id]) {
                                if (player.latestSkin != id) {
                                    packet("c", 0, id, 0);
                                }
                            } else {
                                if (configs.autoBuyEquip) {
                                    let find = findID(hats, id);
                                    if (find) {
                                        if (player.points >= find.price) {
                                            //setTimeout(()=>{
                                            packet("c", 1, id, 0);
                                            //setTimeout(()=>{
                                            packet("c", 0, id, 0);
                                            //}, 120);
                                            //}, 120);
                                        } else {
                                            if (player.latestSkin != nID) {
                                                packet("c", 0, nID, 0);
                                            }
                                        }
                                    } else {
                                        if (player.latestSkin != nID) {
                                            packet("c", 0, nID, 0);
                                        }
                                    }
                                } else {
                                    if (player.latestSkin != nID) {
                                        packet("c", 0, nID, 0);
                                    }
                                }
                            }
                        } else if (index == 1) {
                            if (useWasd && (id != 11 && id != 0)) {
                                if (player.latestTail != 0) {
                                    packet("c", 0, 0, 1);
                                }
                                return;
                            }
                            if (player.tails[id]) {
                                if (player.latestTail != id) {
                                    packet("c", 0, id, 1);
                                }
                            } else {
                                if (configs.autoBuyEquip) {
                                    let find = findID(accessories, id);
                                    if (find) {
                                        if (player.points >= find.price) {
                                            packet("c", 1, id, 1);
                                            // setTimeout(()=>{
                                            packet("c", 0, id, 1);
                                            //}, 120);
                                        } else {
                                            if (player.latestTail != 0) {
                                                packet("c", 0, 0, 1);
                                            }
                                        }
                                    } else {
                                        if (player.latestTail != 0) {
                                            packet("c", 0, 0, 1);
                                        }
                                    }
                                } else {
                                    if (player.latestTail != 0) {
                                        packet("c", 0, 0, 1);
                                    }
                                }
                            }
                        }
                    }
                }
                function selectToBuild(index, wpn) {
                    packet("z", index, wpn);
                }
                function selectWeapon(index, isPlace) {
                    if (!isPlace) {
                        player.weaponCode = index;
                    }
                    packet("z", index, 1);
                }
                function sendAutoGather() {
                    packet("K", 1, 1);
                }
                function sendAtck(id, angle) {
                    packet("F", id, angle, 1);
                }
                let phantom = [];
                function FastPlace(id, rad) {
                    try {
                        const Render = true ? 1 : 0;
                        place(id, rad, Render);
                    } catch (e) {}
                }
                liztobj
                // PLACER:
                function place(id, rad, rmd) {
                    try {
                        if (id == undefined) return;
                        let item = items.list[player.items[id]];
                        let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                        let tmpX = player.x2 + tmpS * Math.cos(rad);
                        let tmpY = player.y2 + tmpS * Math.sin(rad);
                        if ((player.alive && inGame && player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? 299 : item.group.limit ? item.group.limit : 99))) {
                            selectToBuild(player.items[id]);
                            sendAtck(1, rad);
                            selectWeapon(player.weaponCode, 1);
                            if (rmd && getEl("placeVis").checked || preplacing) {
                                placeVisible.push({
                                    x: tmpX,
                                    y: tmpY,
                                    name: item.name,
                                    scale: item.scale,
                                    dir: rad
                                });
                                game.tickBase(() => {
                                    placeVisible.shift();
                                }, 1)
                            }
                        }
                    } catch (e) {}
                }

                function checkPlace(id, rad) {
                    try {
                        if (id == undefined) return;
                        let item = items.list[player.items[id]];
                        let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                        let tmpX = player.x2 + tmpS * Math.cos(rad);
                        let tmpY = player.y2 + tmpS * Math.sin(rad);
                        if (objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player)) {
                            place(id, rad, 1);
                        }
                    } catch (e) {}
                }
                //made angles:
                function inBetween(angle, arra) {
                    let array = [undefined, undefined]
                    if (Math.sin(angle) > 0 && Math.cos(angle) > 0) {
                        array[0] = arra[0]
                        array[1] = arra[1]
                    } else if (Math.sin(angle) > 0 && Math.cos(angle) < 0) {
                        angle = angle - (Math.PI / 2)
                        array[0] = arra[0] - (Math.PI / 2)
                        array[1] = arra[1] - (Math.PI / 2)
                    } else if (Math.sin(angle) < 0 && Math.cos(angle) < 0) {
                        angle = angle - Math.PI
                        array[0] = arra[0] - Math.PI
                        array[1] = arra[1] - Math.PI
                    } else if (Math.sin(angle) < 0 && Math.cos(angle) > 0) {
                        angle = angle - ((3 * Math.PI) / 2)
                        array[0] = arra[0] - ((3 * Math.PI) / 2)
                        array[1] = arra[1] - ((3 * Math.PI) / 2)
                    }
                    let array1q, array2q;
                    if (Math.sin(array[0]) > 0 && Math.cos(array[0]) > 0) {
                        array1q = 1
                    } else if (Math.sin(array[0]) > 0 && Math.cos(array[0]) < 0) {
                        array1q = 2
                    } else if (Math.sin(array[0]) < 0 && Math.cos(array[0]) < 0) {
                        array1q = 3
                    } else if (Math.sin(array[0]) < 0 && Math.cos(array[0]) > 0) {
                        array1q = 4
                    }
                    if (Math.sin(array[1]) > 0 && Math.cos(array[1]) > 0) {
                        array2q = 1
                    } else if (Math.sin(array[1]) > 0 && Math.cos(array[1]) < 0) {
                        array2q = 2
                    } else if (Math.sin(array[1]) < 0 && Math.cos(array[1]) < 0) {
                        array2q = 3
                    } else if (Math.sin(array[1]) < 0 && Math.cos(array[1]) > 0) {
                        array2q = 4
                    }

                    let angleQ;
                    if (Math.sin(angle) > 0 && Math.cos(angle) > 0) {
                        angleQ = 1
                    } else if (Math.sin(angle) > 0 && Math.cos(angle) < 0) {
                        angleQ = 2
                    } else if (Math.sin(angle) < 0 && Math.cos(angle) < 0) {
                        angleQ = 3
                    } else if (Math.sin(angle) < 0 && Math.cos(angle) > 0) {
                        angleQ = 4
                    }

                    if (array1q == angleQ) {
                        if (array[0] < angle && angle < array[1]) {
                            return true
                        } else {
                            return false
                        }
                    } else if (array1q < angleQ) {
                        if (array[0] < angle || angle < array[1]) {
                            return true
                        } else {
                            return false
                        }
                    } else {
                        if (array[0] > angle && angle > array[1]) {
                            return true
                        } else {
                            return false
                        }
                    }
                }

                function manageAngles(angles) {
                    let allAngles = []
                    for (let i = 0; i < angles.length; i++) {
                        if (angles[i].length) {
                            if (!allAngles.length) {
                                allAngles.push(angles[i])
                            } else {
                                let used = false
                                for (let j = 0; j < allAngles.length; j++) {

                                    if (inBetween(angles[i][0], allAngles[j])) {
                                        used = true
                                        if (inBetween(angles[i][1], allAngles[j])) {
                                            allAngles[j].push(angles[i][2])
                                        } else {
                                            allAngles[j][1] = angles[i][1]
                                            allAngles[j].push(angles[i][2])
                                        }
                                    } else if (inBetween(angles[i][1], allAngles[j])) {
                                        used = true
                                        allAngles[j][0] = angles[i][0]
                                        allAngles[j].push(angles[i][2])
                                    }
                                }
                                if (!used) {
                                    allAngles.push(angles[i])
                                }
                            }
                        }
                    }

                    return allAngles

                }

                function makeAng(build, id) {
                    let fullAng = [];
                    let buildings = gameObjects.filter(obj => fgdo(player, obj) < 250 && obj.active)
                    let item = items.list[id < items.list.length ? id : player.items[2]]
                    let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                    for (let scale, i = 0; i < buildings.length; i++) {
                        if (!buildings[i].isItem) {
                            if ((buildings[i].scale != 80 && buildings[i].scale != 85 && buildings[i].scale != 90 || buildings[i].type == 1)) {
                                scale = buildings[i].scale * 0.40

                            } else {
                                scale = buildings[i].scale
                            }
                        } else {
                            scale = buildings[i].scale
                        }
                        let angles = []
                        let dist = (item + scale + 1)
                        let dPTB = fgdo(player, buildings[i])
                        let cosLaw
                        if (dPTB > dist + tmpS) {
                            cosLaw = Math.acos(((Math.pow(tmpS, 2) + Math.pow(dist, 2)) - Math.pow(dPTB, 2)) / (2 * dist * tmpS))
                            cosLaw = Math.asin((dist * Math.sin(cosLaw)) / dPTB)
                        } else {
                            cosLaw = Math.acos(((Math.pow(tmpS, 2) + Math.pow(dPTB, 2)) - Math.pow(dist, 2)) / (2 * dPTB * tmpS))
                        }
                        let aPTB = Math.atan2(buildings[i].y - player.y2, buildings[i].x - player.x2)
                        let ang1 = (aPTB - cosLaw)
                        let ang2 = (aPTB + cosLaw)
                        if (!isNaN(cosLaw)) {
                            angles.push(ang1)
                            angles.push(ang2)
                            angles.push(buildings[i])
                        }
                        fullAng.push(angles)
                    }
                    for (let i = 0; i < fullAng.length * 3; i++) {
                        fullAng = controlAng(fullAng)
                    }
                    if (!fullAng.length) {
                        fullAng = [0, 0.0001]
                    }
                    for (let i = 0; i < fullAng.length; i++) {
                        if (fullAng != false) {
                            if (!checkPlace(id, fullAng[i][0]) || !checkPlace(id, fullAng[i][1])) {
                                fullAng = false
                            }
                        }
                    }
                    //console.log(tracker.draw)
                    return fullAng
                }
                let controlAng = (ang) => {
                    let allAngles = []
                    //console.log(angles)
                    for (let i = 0; i < ang.length; i++) {
                        if (ang[i].length) {
                            if (!allAngles.length) {
                                allAngles.push(ang[i])
                            } else {
                                let used = false
                                for (let j = 0; j < allAngles.length; j++) {

                                    if (inBetween(ang[i][0], allAngles[j])) {
                                        used = true
                                        if (inBetween(ang[i][1], allAngles[j])) {
                                            allAngles[j].push(ang[i][2])
                                        } else {
                                            allAngles[j][1] = ang[i][1]
                                            allAngles[j].push(ang[i][2])
                                        }
                                    } else if (inBetween(ang[i][1], allAngles[j])) {
                                        used = true
                                        allAngles[j][0] = ang[i][0]
                                        allAngles[j].push(ang[i][2])
                                    }
                                }
                                if (!used) {
                                    allAngles.push(ang[i])
                                }
                            }
                        }
                    }
                    return allAngles
                }

                function makeAngles(building, type) {
                    let buildings = building.filter(obj => fgdo(player, obj) < player.scale + items.list[type].scale + obj.scale + 50 && obj.active)
                    let allAngles = []
                    let scale
                    let offset = player.scale + items.list[type].scale + (items.list[type].placeOffset || 0)
                    for (let i = 0; i < buildings.length; i++) {

                        let scale
                        if (!buildings[i].isItem) {
                            if ((buildings[i].scale != 80 && buildings[i].scale != 85 && buildings[i].scale != 90 || buildings[i].type == 1)) {
                                scale = buildings[i].scale * 0.40

                            } else {
                                scale = buildings[i].scale
                            }
                        } else {
                            scale = buildings[i].scale
                        }
                        let angles = []
                        let dist = (items.list[type].scale + scale + 1)
                        let dPTB = fgdo(player, buildings[i])
                        let cosLaw
                        if (dPTB > dist + offset) {
                            cosLaw = Math.acos(((Math.pow(offset, 2) + Math.pow(dist, 2)) - Math.pow(dPTB, 2)) / (2 * dist * offset))
                            cosLaw = Math.asin((dist * Math.sin(cosLaw)) / dPTB)
                        } else {
                            cosLaw = Math.acos(((Math.pow(offset, 2) + Math.pow(dPTB, 2)) - Math.pow(dist, 2)) / (2 * dPTB * offset))
                        }
                        let aPTB = Math.atan2(buildings[i].y - player.y2, buildings[i].x - player.x2)
                        let ang1 = (aPTB - cosLaw)
                        let ang2 = (aPTB + cosLaw)
                        if (!isNaN(cosLaw)) {
                            angles.push(ang1)
                            angles.push(ang2)
                            angles.push(buildings[i])
                        }
                        allAngles.push(angles)
                    }

                    for (let i = 0; i < allAngles.length * 3; i++) {
                        allAngles = manageAngles(allAngles)

                    }
                    if (!allAngles.length) {
                        allAngles = [0, 0.0001]
                    }
                    for (let i = 0; i < allAngles.length; i++) {
                        if (allAngles != false) {
                            if (!checkPlace(type, allAngles[i][0]) || !checkPlace(type, allAngles[i][1])) {
                                allAngles = false
                            }
                        }
                    }
                    //console.log(tracker.draw)
                    return allAngles
                }
                // HEALING:
                function soldierMult() {
                    return player.latestSkin == 6 ? 0.75 : 1;
                }

                function healthBased() {
                    if (player.health == 100)
                        return 0;
                    if ((player.skinIndex != 45 && player.skinIndex != 56)) {
                        return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
                    }
                    return 0;
                }

                function getAttacker(damaged) {
                    let attackers = enemy.filter(tmp => {
                        //let damages = new Damages(items);
                        //let dmg = damages.weapons[tmp.weaponIndex];
                        //let by = tmp.weaponIndex < 9 ? [dmg[0], dmg[1], dmg[2], dmg[3]] : [dmg[0], dmg[1]];
                        let rule = {
                            //one: tmp.dist2 <= 300,
                            //two: by.includes(damaged),
                            three: tmp.attacked
                        }
                        return /*rule.one && rule.two && */rule.three;
                    });
                    return attackers;
                }

                function healer() {
                    for (let i = 0; i < healthBased(); i++) {
                        place(0, getAttackDir());
                    }
                }
                function healer1() {

                    place(0, getAttackDir());
                    return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);

                }

                function antiSyncHealing(timearg) {
                    my.antiSync = true;
                    let healAnti = setInterval(() => {
                        if (player.shameCount < 5) {
                            place(0, getAttackDir());
                        }
                    }, 75);
                    setTimeout(() => {
                        clearInterval(healAnti);
                        setTimeout(() => {
                            my.antiSync = false;
                        }, game.tickRate);
                    }, game.tickRate);
                }

                function biomeGear(mover, returns) {
                    //console.trace()
                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                        if (returns) return 31;
                        buyEquip(31, 0);
                    } else {
                        if (player.y2 <= config.snowBiomeTop) {
                            //console.log('SNow',mover && !(_things.player.moveDir!=undefined||isMovingAuto) ? 22 : 15,mover ,(_things.player.moveDir!=undefined||isMovingAuto),{mover,moving:(_things.player.moveDir!=undefined||isMovingAuto),dir:_things.player.moveDir||player.moveDir})
                            if (returns) return mover && !(_things.player.moveDir!=undefined||isMovingAuto) ? 22 : 15;
                            buyEquip(mover && !(_things.player.moveDir!=undefined||isMovingAuto) ? 22 : 15, 0);
                        } else {
                            // console.log('else',mover && !(_things.player.moveDir!=undefined||isMovingAuto) ? 22 : 15,mover ,(_things.player.moveDir!=undefined||isMovingAuto),{mover,moving:(_things.player.moveDir!=undefined||isMovingAuto),dir:_things.player.moveDir||player.moveDir})
                            if (returns) return mover && !(_things.player.moveDir!=undefined||isMovingAuto) ? 22 : 12;
                            buyEquip(mover && !(_things.player.moveDir!=undefined||isMovingAuto) ? 22 : 12, 0);

                        }
                    }
                    if (returns) return 0;
                }

                function woah(mover) {
                    buyEquip(mover && player.moveDir == undefined ? 0 : 11, 1);
                }
                function cdf (e, t){
                    try {
                        return Math.hypot((t.y2||t.y)-(e.y2||e.y), (t.x2||t.x)-(e.x2||e.x));
                    } catch(e){
                        return Infinity;
                    }
                }
                function adxtick() {
                    let neIT = false;
                    let nearTrapped = gameObjects.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= (near.scale + tmp.getScale() + 15))
                    .sort(function(a, b) {
                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                    })[0];

                    if (nearTrapped) {
                        neIT = true;
                    }

                    if (configs.adxtick) {
                        if (neIT && near.dist2 <= 75 && nearTrapped.health <= 272.58 && !traps.inTrap && !my.autoPush) {
                            if ((player.weapons[0] === 4 || player.weapons[0] === 5) && player.weapons[1] === 10 && player.reloads[player.weapons[0]] === 0 && player.reloads[player.weapons[1]] === 0) {
                                doAdxtick();
                                addMenuChText("[Game]", "adxTick", "lightBlue");
                            }
                        }
                    }

                    function doAdxtick() {//good enugh
                        my.autoAim = true;
                        selectWeapon(player.weapons[1]);
                        buyEquip(40, 0);
                        sendAutoGather();
                        game.tickBase(() => {
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            game.tickBase(() => {
                                buyEquip(53, 0);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    my.autoAim = false;
                                }, 1);
                            }, 1);
                        }, 1);
                    }
                }
                function doOneFrame() {
                    my.autoAim = true;
                    buyEquip(53, 0);
                    selectWeapon(player.weapons[0]);
                    game.tickBase(() => {
                        buyEquip(7, 0);
                        sendAutoGather();
                        game.tickBase(() => {
                            selectWeapon(player.weapons[0]);
                            sendAutoGather();
                            my.autoAim = false;
                        }, 1);
                    }, 1);
                }

                function autoOneFrame() {
                    let neIT = false;
                    let nearTrapped = gameObjects.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= (near.scale + tmp.getScale() + 15))
                    .sort(function(a, b) {
                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                    })[0];

                    if (nearTrapped) {
                        neIT = true;
                    }

                    if (configs.autoOneFrame) {
                        let ping = unsafeWindow.pingTime;
                        let range = (ping > 140) ? 230 : (ping > 110) ? 210 : (ping > 85) ? 190 : 170;
                        if (near.dist2 > range && near.dist2 <= 245 && !traps.inTrap && player.reloads[player.weapons[0]] == 0 && player.reloads[53] == 0 && player.weapons[0] == 5 && ((!neIT && near.skinIndex != 6) || neIT)) {
                            /*let rng=Math.random() < 0.5&&_things.player.weapons[1]!=10&&(_things.player.weapons[1]&&_things.player.reloads[_things.player.weapons[1]]==0);
                        if(rng){
                            sendChat('Me insta now:'+instaType.value)
                        }*/

                            addMenuChText("Dev", "Auto One Tick", "lightblue");
                            io.send("6", near.dist2.toString())
                            packet("9", undefined, 1);
                            game.tickBase(() => {
                                packet("9", near.aim2, 1);
                            }, 1);
                            false?instaC.changeType(instaType.value):doOneFrame();
                        }
                    }
                }

                function HKH () {
                    my.autoAim = true;
                    sendAutoGather();
                    buyEquip(53, 0);
                    selectWeapon(player.weapons[1]);
                    game.tickBase(() => {
                        buyEquip(7, 0);
                        selectWeapon(player.weapons[0]);
                        game.tickBase(() => {
                            sendAutoGather();
                            my.autoAim = false;
                        }, 1);
                    }, 1);
                }


                let preplacing = false;
                function preplacer() {
                    return player.preplacer();
                    let nearestObj = null;
                    if (secPacket >= 90 || traps.antiTrapped) return;
                    let range = items.weapons[player.weaponIndex].range + 150;
                    gameObjects.forEach(tmpObj => {
                        if (enemy.length) {
                            let objDst = UTILS.getDist(tmpObj, player, 0, 2);
                            let objAim = UTILS.getDirect(tmpObj, player, 0, 2);
                            if (tmpObj.health < 272.58 && objDst <= 120) {
                                nearestObj = tmpObj;
                            }
                        }
                    });
                    let nearTrap = liztobj.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && cdf(tmp, player) <= tmp.getScale() + 5);
                    let spike = gameObjects.find(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && cdf(tmp, player) < 87 && !nearTrap.length);
                    if (nearestObj) {
                        let angle = UTILS.getDirect(nearestObj, player, 0, 2);
                        let FindTrap = gameObjects.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= near.scale + tmp.getScale() + 5).sort(function (a, b) {
                            return UTILS.getDist(a, near, 0, 5) - UTILS.getDist(b, near, 0, 5);
                        })[0];
                        game.tickBase(() => {
                            try{
                                let condition = near.dist2 <= range && tmpObj.health <= 272.58 && fgdo(tmpObj, player) <= range || (near && near.reloads[near.weaponIndex] <= config.tickRate * (unsafeWindow.pingTime >= 200 ? 2 : 1)) || player.reloads[player.weaponIndex] * 1000 <= config.tickRate * (unsafeWindow.pingTime >= 200 ? 2 : 1);
                                if (condition) {
                                    if (!retrappable || traps.inTrap) {
                                        place(2, angle);
                                        preplacing = true;
                                    } else {
                                        place(4, angle);
                                        preplacing = true;
                                    }
                                }
                            }catch{}
                        }, 1);
                    }
                }
                let advHeal = [];
                var isnerf=false
                class Traps {
                    constructor(UTILS, items) {
                        this.dist = 0;
                        this.aim = 0;
                        this.inTrap = false;
                        this.replaced = false;
                        this.antiTrapped = false;
                        this.info = {};
                        this.notFast = function() {
                            return player.weapons[1] == 10 && ((this.info.health > items.weapons[player.weapons[0]].dmg) || player.weapons[0] == 5);
                        }
                        this.testCanPlace = function (id, first = -(Math.PI / 2), repeat = (Math.PI / 2), plus = (Math.PI / 18), radian, replacer, yaboi) {
                            try {
                                let item = items.list[player.items[id]];
                                let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                                let counts = {
                                    attempts: 0,
                                    placed: 0
                                };
                                let tmpObjects = [];
                                gameObjects.forEach((p) => {
                                    tmpObjects.push({
                                        x: p.x,
                                        y: p.y,
                                        active: p.active,
                                        blocker: p.blocker,
                                        scale: p.scale,
                                        isItem: p.isItem,
                                        type: p.type,
                                        colDiv: p.colDiv,
                                        getScale: function(sM, ig) {
                                            sM = sM||1;
                                            return this.scale * ((this.isItem||this.type==2||this.type==3||this.type==4)
                                                                 ?1:(0.6*sM)) * (ig?1:this.colDiv);
                                        },
                                    });
                                });
                                for (let i = first; i < repeat; i += plus) {
                                    counts.attempts++;
                                    let relAim = radian + i;
                                    let tmpX = player.x2 + tmpS * Math.cos(relAim);
                                    let tmpY = player.y2 + tmpS * Math.sin(relAim);
                                    let cantPlace = tmpObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                    if (cantPlace) continue;
                                    if (item.id != 18 && tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                    if ((!replacer && yaboi) || useWasd) {
                                        if (useWasd ? false : yaboi.inTrap) {
                                            if (UTILS.getAngleDist(near.aim2 + Math.PI, relAim + Math.PI) <= Math.PI) {
                                                place(2, relAim, 1);
                                            } else {
                                                player.items[4] == 15 && place(4, relAim, 1);
                                            }
                                        } else {
                                            if (UTILS.getAngleDist(near.aim2, relAim) <= config.gatherAngle / 1.5) {
                                                place(2, relAim, 1);
                                            } else {
                                                player.items[4] == 15 && place(4, relAim, 1);
                                            }
                                        }
                                    } else {
                                        place(id, relAim, 1);
                                    }
                                    tmpObjects.push({
                                        x: tmpX,
                                        y: tmpY,
                                        active: true,
                                        blocker: item.blocker,
                                        scale: item.scale,
                                        isItem: true,
                                        type: null,
                                        colDiv: item.colDiv,
                                        getScale: function() {
                                            return this.scale;
                                        },
                                    });
                                    if (UTILS.getAngleDist(near.aim2, relAim) <= 1) {
                                        counts.placed++;
                                    }
                                }
                                if (counts.placed > 0 && replacer && item.dmg) {
                                    if (near.dist2 <= items.weapons[player.weapons[0]].range + (player.scale * 1.8) && configs.spikeTick) {
                                        instaC.canSpikeTick = true;
                                    }
                                }
                            } catch (err) {
                            }
                        };
                        this.checkSpikeTick = function() {
                            try {
                                if (![3, 4, 5].includes(near.primaryIndex)) return false;
                                if ((getEl("safeAntiSpikeTick").checked || my.autoPush) ? false : near.primaryIndex == undefined ? true : (near.reloads[near.primaryIndex] > game.tickRate)) return false;
                                // more range for safe. also testing near.primaryIndex || 5
                                if (near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                    let item = items.list[9];
                                    let tmpS = near.scale + item.scale + (item.placeOffset || 0);
                                    let danger = 0;
                                    let counts = {
                                        attempts: 0,
                                        block: `unblocked`
                                    };
                                    for (let i = -1; i <= 1; i += 1/10) {
                                        counts.attempts++;
                                        let relAim = UTILS.getDirect(player, near, 2, 2) + i;
                                        let tmpX = near.x2 + tmpS * Math.cos(relAim);
                                        let tmpY = near.y2 + tmpS * Math.sin(relAim);
                                        let cantPlace = gameObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                        if (cantPlace) continue;
                                        if (tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                        danger++;
                                        counts.block = `blocked`;
                                        break;
                                    }
                                    if (danger) {
                                        my.anti0Tick = 1;
                                        player.chat.message = "Anti " + near.sid;
                                        player.chat.count = 2000;
                                        return true;
                                    }
                                }
                            } catch (err) {
                                return null;
                            }
                            return false;
                        }
                        this.protect = function (aim) {
                            if (!configs.antiTrap) return;
                            if (player.items[4]) {
                                this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), aim + Math.PI);
                                this.antiTrapped = true;
                            }
                        };
                        let placedSpikePositions = new Set();
                        let placedTrapPositions = new Set();

                        function isBroken() {

                        }
                        this.testPrePlace = function () {

                        }
                        function isPositionValid(x, y, objectRadius, gameObjects, walls) {
                            const isInsideWall = checkCollisionWithWalls(x, y, objectRadius, walls);

                            if (isInsideWall) {
                                return false;
                            }

                            const isOverlapping = checkOverlapWithObjects(x, y, objectRadius, gameObjects);

                            if (isOverlapping) {
                                return false;
                            }

                            return true;
                        }

                        function checkCollisionWithWalls(x, y, radius, walls) {
                            for (let i = 0; i < walls.length; i++) {
                                const wall = walls[i];
                                const dx = x - wall.x;
                                const dy = y - wall.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance <= radius + wall.width / 2) {
                                    return true;
                                }
                            }

                            return false;
                        }

                        function checkOverlapWithObjects(x, y, radius, gameObjects) {
                            for (let i = 0; i < gameObjects.length; i++) {
                                const obj = gameObjects[i];
                                if (obj.x - obj.radius <= x && x <= obj.x + obj.radius &&
                                    obj.y - obj.radius <= y && y <= obj.y + obj.radius) {
                                    return true;
                                }
                            }

                            return false;
                        }
                        function calculatePossibleTrapPositions(x, y, numPositions, objectRadius, gameObjects, walls) {
                            const possiblePositions = [];

                            const angleIncrement = (2 * Math.PI) / numPositions;

                            for (let i = 0; i < numPositions; i++) {
                                const angle = i * angleIncrement;
                                const dx = x + objectRadius * Math.cos(angle);
                                const dy = y + objectRadius * Math.sin(angle);

                                if (isPositionValid(dx, dy, objectRadius, gameObjects, walls)) {
                                    possiblePositions.push({ x: dx, y: dy });
                                }
                            }

                            return possiblePositions;
                        }
                        this.autoPlace = function () {
                            if (configs.autoPlace && game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                try {
                                    const trap1 = gameObjects
                                    .filter((e) => e.trap && e.active)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                    .find((trap) => {
                                        const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                        return (
                                            trap !== player &&
                                            (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                            trapDist <= 50
                                        );
                                    });
                                    if (this.inTrap) {
                                        let antiTrapAngles = Math.PI / Math.floor(Math.random() * (20 - 10 + 1)) + 10;
                                        this.testCanPlace(4, -(Math.PI / 2), (Math.PI / 2), antiTrapAngles, near.aim2);
                                    } else {
                                        if (trap1 && near.dist2 <= 180) {
                                            const trapX = trap1.x;
                                            const trapY = trap1.y;
                                            const circleRadius = 102;
                                            const numPositions = 64;
                                            for (let i = 0; i < numPositions; i++) {
                                                const angle = (2 * Math.PI * i) / numPositions;
                                                const offsetX = trapX + circleRadius * Math.cos(angle);
                                                const offsetY = trapY + circleRadius * Math.sin(angle);
                                                const position = [offsetX, offsetY];
                                                const distToPlayer = Math.hypot(position[0] - player.x2, position[1] - player.y2);
                                                if (
                                                    isPositionValid(position) &&
                                                    distToPlayer <= 87
                                                ) {
                                                    const angleToPlace = Math.atan2(position[1] - player.y2, position[0] - player.x2);
                                                    checkPlace(2, angleToPlace);
                                                }
                                            }
                                        } else if (!trap1 && near.dist2 <= 206) {
                                            const maxTrapsToPlace = 3;
                                            const trapRadius = 50;
                                            const trapPositions = calculatePossibleTrapPositions(player.x2, player.y2, trapRadius);
                                            let trapsPlaced = 0;
                                            for (const position of trapPositions) {
                                                if (
                                                    trapsPlaced < maxTrapsToPlace &&
                                                    isPositionValid(position)
                                                ) {
                                                    checkPlace(4, ...position);
                                                    trapsPlaced++;
                                                }
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.log(e);
                                }
                            }
                        };
                        this.autoPlace = function () {
                            if (getEl("autoPlacetype").value === "spamtrap2") {
                                if (game.tick % 0.5 === 0)
                                    try {
                                        if (configs.autoPlace) {
                                            const dist = near.dist2;
                                            const trap = gameObjects
                                            .filter((e) => e.trap && e.active)
                                            .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                            .find((trap) => {
                                                const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                                return (
                                                    trap !== player &&
                                                    (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                                    trapDist <= near.scale * 1.8
                                                );
                                            });
                                            if (trap && dist <= 250) {
                                                checkPlace(2, Math.atan2(player.y - trap.y, player.x - trap.x) + Math.PI);
                                            } else if (!trap && dist <= 400) {
                                                const angles = dist < 200 ? [0, 55, 110, 165, -55, -110, -165] : [0, 90, 180, 270];
                                                for (let i = 0; i < angles.length; i++) {
                                                    checkPlace(2, near.aim2 + toR(angles[i]));
                                                }
                                            }
                                        }
                                    } catch (e) {}
                            }
                            else if (enemy.length && configs.autoPlace && !instaC.ticking) {
                                if (getEl("autoPlacetype").value === "spamtrap") {
                                    if (game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                        if (gameObjects.length) {
                                            let near2 = {
                                                inTrap: false,
                                            };
                                            let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                                return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                            })[0];
                                            if (nearTrap) {
                                                near2.inTrap = true;
                                            } else {
                                                near2.inTrap = false;
                                            }
                                            if (testMode ? enemy.length : (near.dist2 <= 300)) {
                                                const numTries = near.dist2 <= 200 ? 12 : 4;
                                                for (let i = 0; i < numTries; i++) {
                                                    this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2, i / numTries, {inTrap: near2.inTrap});
                                                }
                                            }
                                        } else {
                                            if (testMode ? enemy.length : (near.dist2 <= 300)) {
                                                this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                            }
                                        }
                                    }
                                }
                            }
                        };


                        this.autoPlace = function () {
                            if (getEl("autoPlacetype").value == "ramdomplc") {
                                try {
                                    const dist = near.dist2;
                                    const trap = gameObjects
                                    .filter((e) => e.trap && e.active)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                    .find((trap) => {
                                        const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                        return (
                                            trap !== player &&
                                            (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                            trapDist <= near.scale * 1.8
                                        );
                                    });

                                    if (trap && near.dist2 <= 250) {
                                        const angleToTrap = Math.atan2(player.y - trap.y, player.x - trap.x);
                                        checkPlace(2, angleToTrap + Math.PI);
                                    } else if (!trap && dist <= 300) {
                                        if (dist < 200) {
                                            const maxAngle = Math.PI / 6;
                                            const angleMultiplier = Math.min(1, Math.max(0, (dist - 150) / 130));
                                            const adjustedAngle = maxAngle * angleMultiplier;

                                            for (let i = -55; i < 55; i += 55) {
                                                const perfectAngle = calculatePerfectAngle(near.x2, near.y2, player.x2, player.y2);
                                                checkPlace(2, perfectAngle + adjustedAngle + toR(i));
                                            }
                                        }
                                        if (dist >= 200) {
                                            const maxAngle = Math.PI / 6;
                                            const angleMultiplier = Math.min(1, Math.max(0, (dist - 150) / 130));
                                            const adjustedAngle = maxAngle * angleMultiplier;

                                            for (let i = -90; i < 270; i += 90) {
                                                const perfectAngle = calculatePerfectAngle(near.x2, near.y2, player.x2, player.y2);
                                                checkPlace(4, perfectAngle + adjustedAngle + toR(i));
                                            }
                                        }
                                    }
                                } catch (e) {}
                            };
                        }

                        this.autoPlace = function () {
                            if (configs.autoPlace && game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                if (getEl("autoPlacetype").value == "aiplace") {
                                    try {
                                        const trap1 = gameObjects
                                        .filter((e) => e.trap && e.active)
                                        .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                        .find((trap) => {
                                            const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                            return (
                                                trap !== player &&
                                                (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                                trapDist <= 50
                                            );
                                        });
                                        if (this.inTrap) {
                                            let antiTrapAngles = Math.PI / Math.floor(Math.random() * (20 - 10 + 1)) + 10;
                                            this.testCanPlace(4, -(Math.PI / 2), (Math.PI / 2), antiTrapAngles, near.aim2);
                                        } else {
                                            if (trap1 && near.dist2 <= 180) {
                                                const trapX = trap1.x;
                                                const trapY = trap1.y;
                                                const circleRadius = 102;
                                                const numPositions = 64;
                                                for (let i = 0; i < numPositions; i++) {
                                                    const angle = (2 * Math.PI * i) / numPositions;
                                                    const offsetX = trapX + circleRadius * Math.cos(angle);
                                                    const offsetY = trapY + circleRadius * Math.sin(angle);
                                                    const position = [offsetX, offsetY];
                                                    const distToPlayer = Math.hypot(position[0] - player.x2, position[1] - player.y2);
                                                    if (
                                                        isPositionValid(position) &&
                                                        distToPlayer <= 87
                                                    ) {
                                                        const angleToPlace = Math.atan2(position[1] - player.y2, position[0] - player.x2);
                                                        checkPlace(2, angleToPlace);
                                                    }
                                                }
                                            } else if (!trap1 && near.dist2 <= 206) {
                                                const maxTrapsToPlace = 3;
                                                const trapRadius = 50;
                                                const trapPositions = calculatePossibleTrapPositions(player.x2, player.y2, trapRadius);
                                                let trapsPlaced = 0;
                                                for (const position of trapPositions) {
                                                    if (
                                                        trapsPlaced < maxTrapsToPlace &&
                                                        isPositionValid(position)
                                                    ) {
                                                        checkPlace(4, ...position);
                                                        trapsPlaced++;
                                                    }
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        console.log(e);
                                    }
                                }
                            };
                        }

                        this.autoPlace = function() {
                            if (!configs.autoPlace) return;
                            if (enemy.length && configs.autoPlace && !instaC.ticking&&game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                if (game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                    if (gameObjects.length) {
                                        let near2 = {
                                            inTrap: false,
                                        };
                                        let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function(a, b) {
                                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                        })[0];
                                        if (nearTrap) {
                                            near2.inTrap = true;
                                        } else {
                                            near2.inTrap = false;
                                        }
                                        if (near.dist3 <= 450) {
                                            if (near.dist3 <= 200) {
                                                this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2, 0, {
                                                    inTrap: near2.inTrap
                                                });
                                            } else {
                                                player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                            }
                                        }
                                    } else {
                                        if (near.dist3 <= 450) {
                                            player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                        }
                                    }
                                }
                            }
                        };

                        function autoPlace() { // bug place
                            let nearObj = [];
                            if (gameObjects.length && enemy.length) {
                                let inTrap = false;
                                nearObj = gameObjects.filter((e)=>e.trap).sort(function(a, b) {
                                    return (UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2));
                                })[0];
                                if (nearObj) {
                                    if (!(player.sid != nearObj.owner.sid && !findAllianceBySid(nearObj.owner.sid)) && UTILS.getDist(nearObj, near, 0, 2) <= 70 && nearObj.active) {
                                        inTrap = true;
                                    } else {
                                        inTrap = false;
                                    }
                                    if (near.dist2 <= 350) {
                                        if (inTrap && near.dist2 <= 200) {
                                            if (near.dist2 <= player.scale + near.scale + Math.PI * 2) {
                                                checkPlace(2, near.aim2 - UTILS.getDirect(nearObj, near, 0, 2));
                                                checkPlace(2, near.aim2 + UTILS.getDirect(nearObj, near, 0, 2));
                                            }
                                        }
                                        if (near.dist2 <= near.scale + player.scale) {
                                            checkPlace(2, near.aim2);
                                        } else {
                                            if (near.dist2 <= 200 && !instaC.canSpikeTick && !traps.in && !inTrap) {
                                                checkPlace(2, near.aim2 + UTILS.toRad(90));
                                                checkPlace(2, near.aim2 - UTILS.toRad(90));
                                            } else {
                                                if (near.dist2 <= 250) {
                                                    checkPlace(2, near.aim2 + Math.PI);
                                                } else {
                                                    for (let i = 0; i < 360; i += 90) {
                                                        checkPlace(4, UTILS.toRad(i));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }





                        this.autoplace = function () {
                            let oldXY = {
                                x: undefined,
                                y: undefined,
                            };
                            if(!getEl("autoPlacetype"))throw "#autoPlacetype not found"
                            let can=enemy.length && configs.autoPlace && !instaC.ticking&&game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0
                            if(!can)return `Cant place L tick`
                            let placers={
                                magiplacer(){
                                    let nearObj = [];
                                    let randomDir = Math.random() * Math.PI * 2;
                                    if (gameObjects.length && enemy.length) {
                                        let nearsa = {
                                            inTrap: false,
                                        };
                                        nearObj = gameObjects.filter((e)=>e.trap).sort(function(a, b) {
                                            return (UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2));
                                        })[0];
                                        let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                        })[0];
                                        let near2 = {
                                            inTrap: false,
                                        };
                                        if (nearTrap) {
                                            near2.inTrap = true;
                                        } else {
                                            near2.inTrap = false;
                                        }
                                        if (nearObj) {
                                            if (!(player.sid != nearObj.owner.sid && !findAllianceBySid(nearObj.owner.sid)) && UTILS.getDist(nearObj, near, 0, 2) <= 70 && nearObj.active) {
                                                nearsa.inTrap = true;
                                            } else {
                                                nearsa.inTrap = false;
                                            }
                                            if (near.dist2 <= 600) {
                                                if (nearsa.inTrap || near.dist2 <= 60 + near.scale) {
                                                    if (near.dist2 <= 250) {
                                                        for (let i = 0; i < Math.PI * 2; i += Math.PI / 1.5) {
                                                            checkPlace(2, near.aim2 + i);
                                                        }
                                                    } else {
                                                        for (let i = Math.PI / 1.5; i < Math.PI * 2; i += Math.PI / 1.5) {
                                                            checkPlace(2, near.aim2 + i);
                                                        }
                                                    }
                                                } else {
                                                    if (player.items[4] == 15) {
                                                        if (near.dist2 <= 200) {
                                                            for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                                                checkPlace(4, randomDir + i);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if (near.dist2 <= 400) {
                                                if (player.items[4] == 15) {
                                                    checkPlace(4, near.aim2);
                                                }
                                            }
                                        }
                                    }

                                },
                                aiplace(){
                                    const trap1 = gameObjects
                                    .filter((e) => e.trap && e.active)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                    .find((trap) => {
                                        const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                        return (
                                            trap !== player &&
                                            (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                            trapDist <= 50
                                        );
                                    });
                                    if (this.inTrap) {
                                        let antiTrapAngles = Math.PI / Math.floor(Math.random() * (20 - 10 + 1)) + 10;
                                        this.testCanPlace(4, -(Math.PI / 2), (Math.PI / 2), antiTrapAngles, near.aim2);
                                    } else {
                                        if (trap1 && near.dist2 <= 180) {
                                            const trapX = trap1.x;
                                            const trapY = trap1.y;
                                            const circleRadius = 102;
                                            const numPositions = 64;
                                            for (let i = 0; i < numPositions; i++) {
                                                const angle = (2 * Math.PI * i) / numPositions;
                                                const offsetX = trapX + circleRadius * Math.cos(angle);
                                                const offsetY = trapY + circleRadius * Math.sin(angle);
                                                const position = [offsetX, offsetY];
                                                const distToPlayer = Math.hypot(position[0] - player.x2, position[1] - player.y2);
                                                if (
                                                    isPositionValid(position) &&
                                                    distToPlayer <= 87
                                                ) {
                                                    const angleToPlace = Math.atan2(position[1] - player.y2, position[0] - player.x2);
                                                    checkPlace(2, angleToPlace);
                                                }
                                            }
                                        } else if (!trap1 && near.dist2 <= 206) {
                                            const maxTrapsToPlace = 3;
                                            const trapRadius = 50;
                                            const trapPositions = calculatePossibleTrapPositions(player.x2, player.y2, trapRadius);
                                            let trapsPlaced = 0;
                                            for (const position of trapPositions) {
                                                if (
                                                    trapsPlaced < maxTrapsToPlace &&
                                                    isPositionValid(position)
                                                ) {
                                                    checkPlace(4, ...position);
                                                    trapsPlaced++;
                                                }
                                            }
                                        }
                                    }
                                },
                                ramdomplc(){
                                    const dist = near.dist2;
                                    const trap = gameObjects
                                    .filter((e) => e.trap && e.active)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                    .find((trap) => {
                                        const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                        return (
                                            trap !== player &&
                                            (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                            trapDist <= near.scale * 1.8
                                        );
                                    });

                                    if (trap && near.dist2 <= 250) {
                                        const angleToTrap = Math.atan2(player.y - trap.y, player.x - trap.x);
                                        checkPlace(2, angleToTrap + Math.PI);
                                    } else if (!trap && dist <= 300) {
                                        if (dist < 200) {
                                            const maxAngle = Math.PI / 6;
                                            const angleMultiplier = Math.min(1, Math.max(0, (dist - 150) / 130));
                                            const adjustedAngle = maxAngle * angleMultiplier;

                                            for (let i = -55; i < 55; i += 55) {
                                                const perfectAngle = calculatePerfectAngle(near.x2, near.y2, player.x2, player.y2);
                                                checkPlace(2, perfectAngle + adjustedAngle + toR(i));
                                            }
                                        }
                                        if (dist >= 200) {
                                            const maxAngle = Math.PI / 6;
                                            const angleMultiplier = Math.min(1, Math.max(0, (dist - 150) / 130));
                                            const adjustedAngle = maxAngle * angleMultiplier;

                                            for (let i = -90; i < 270; i += 90) {
                                                const perfectAngle = calculatePerfectAngle(near.x2, near.y2, player.x2, player.y2);
                                                checkPlace(4, perfectAngle + adjustedAngle + toR(i));
                                            }
                                        }
                                    }
                                },
                                spamtrap(){

                                    const trap1 = gameObjects
                                    .filter((e) => e.trap && e.active)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                    .find((trap) => {
                                        const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                        return (
                                            trap !== player &&
                                            (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                            trapDist <= 50
                                        );
                                    });
                                    if (this.inTrap) {
                                        let antiTrapAngles = Math.PI / Math.floor(Math.random() * (20 - 10 + 1)) + 10;
                                        this.testCanPlace(4, -(Math.PI / 2), (Math.PI / 2), antiTrapAngles, near.aim2);
                                    } else {
                                        if (trap1 && near.dist2 <= 180) {
                                            const trapX = trap1.x;
                                            const trapY = trap1.y;
                                            const circleRadius = 102;
                                            const numPositions = 64;
                                            for (let i = 0; i < numPositions; i++) {
                                                const angle = (2 * Math.PI * i) / numPositions;
                                                const offsetX = trapX + circleRadius * Math.cos(angle);
                                                const offsetY = trapY + circleRadius * Math.sin(angle);
                                                const position = [offsetX, offsetY];
                                                const distToPlayer = Math.hypot(position[0] - player.x2, position[1] - player.y2);
                                                if (
                                                    isPositionValid(position) &&
                                                    distToPlayer <= 87
                                                ) {
                                                    const angleToPlace = Math.atan2(position[1] - player.y2, position[0] - player.x2);
                                                    checkPlace(2, angleToPlace);
                                                }
                                            }
                                        } else if (!trap1 && near.dist2 <= 206) {
                                            const maxTrapsToPlace = 3;
                                            const trapRadius = 50;
                                            const trapPositions = calculatePossibleTrapPositions(player.x2, player.y2, trapRadius);
                                            let trapsPlaced = 0;
                                            for (const position of trapPositions) {
                                                if (
                                                    trapsPlaced < maxTrapsToPlace &&
                                                    isPositionValid(position)
                                                ) {
                                                    checkPlace(4, ...position);
                                                    trapsPlaced++;
                                                }
                                            }
                                        }
                                    }

                                }
                            }
                            if(placers[getEl("autoPlacetype").value])try{placers[getEl("autoPlacetype").value]()}catch(r){console.warn(getEl("autoPlacetype").value,'error',r)}
                        }



                        this.replacer1 = function(findObj) {
                            if (!findObj || !configs.autoReplace) return;
                            if (!inGame) return;
                            if (this.antiTrapped) return;
                            game.tickBase(() => {
                                let objAim = UTILS.getDirect(findObj, player, 0, 2);
                                let objDst = UTILS.getDist(findObj, player, 0, 2);
                                if (configs.autoGrind && objDst <= items.weapons[player.weaponIndex].range + player.scale) return;
                                if (objDst <= 400 && near.dist2 <= 400) {
                                    let danger = this.checkSpikeTick();
                                    if (!danger && near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                        //this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), objAim, 1);
                                        this.testCanPlace(2, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    } else {
                                        player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    }
                                    this.replaced = true;
                                }
                            }, 1);
                        }
                        function calculatePerfectAngle(x1, y1, x2, y2) {
                            return Math.atan2(y2 - y1, x2 - x1);
                        }
                        let spikePlaced = false;
                        let spikSync = false;



                        this.replacer = function(findObj) {
                            if (!findObj || !configs.autoReplace) return;
                            if (!inGame) return;
                            if (this.antiTrapped) return;
                            game.tickBase(() => {
                                let objAim = UTILS.getDirect(findObj, player, 0, 2);
                                let objDst = UTILS.getDist(findObj, player, 0, 2);
                                if (getEl("weaponGrind").checked && objDst <= items.weapons[player.weaponIndex].range + player.scale) return;

                                if(spikePlaced){
                                    player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    spikePlaced = false;
                                }
                                if (near.dist2 <= 250 && !spikSync) {
                                    for (let i = 0; i < 24; i++) {
                                        let angle = (Math.PI * 2) * i / 24;
                                        this.testCanPlace(2, angle, angle + (Math.PI / 24), (Math.PI / 24), objAim, 1);
                                        spikePlaced = true;
                                    }
                                }
                                if (objDst <= 250 && near.dist2 <= 250) {
                                    let danger = this.checkSpikeTick();
                                    if (!danger && near.dist3 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {

                                        this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), objAim, 1)
                                        for (let i = 0; i < 24; i++) {
                                            let angle = (Math.PI * 2) * i / 24;
                                            this.testCanPlace(2, angle, angle + (Math.PI / 24), (Math.PI / 24), objAim, 1);
                                            this.testCanPlace(2, (Math.PI / 2), (Math.PI / 2), (Math.PI / 2), near, objAim, 1)
                                            spikSync = true;

                                        }
                                    } else {
                                        player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    }

                                    this.replaced = true;
                                }
                            }, 1);
                        };
                    }
                };

                class TrapsBetter {
                    constructor(UTILS, items) {
                        this.dist = 0;
                        this.aim = 0;
                        this.inTrap = false;
                        this.replaced = false;
                        this.antiTrapped = false;
                        this.info = {};
                        this.notFast = function () {
                            return player.weapons[1] == 10 && ((this.info.health > items.weapons[player.weapons[0]].dmg) || player.weapons[0] == 5);
                        }
                        this.testCanPlace = function (id, first = -(Math.PI / 2), repeat = (Math.PI / 2), plus = (Math.PI / 18), radian, replacer, yaboi) {
                            try {
                                let item = items.list[player.items[id]];
                                let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                                let counts = {
                                    attempts: 0,
                                    placed: 0
                                };
                                let tmpObjects = [];
                                gameObjects.forEach((p) => {
                                    tmpObjects.push({
                                        x: p.x,
                                        y: p.y,
                                        active: p.active,
                                        blocker: p.blocker,
                                        scale: p.scale,
                                        isItem: p.isItem,
                                        type: p.type,
                                        colDiv: p.colDiv,
                                        getScale: function (sM, ig) {
                                            sM = sM || 1;
                                            return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4)
                                                                 ? 1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
                                        },
                                    });
                                });
                                for (let i = first; i < repeat; i += plus) {
                                    counts.attempts++;
                                    let relAim = radian + i;
                                    let tmpX = player.x2 + tmpS * Math.cos(relAim);
                                    let tmpY = player.y2 + tmpS * Math.sin(relAim);
                                    let cantPlace = tmpObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                    if (cantPlace) continue;
                                    if (item.id != 18 && tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                    if ((!replacer && yaboi) || useWasd) {
                                        if (useWasd ? false : yaboi.inTrap) {
                                            if (UTILS.getAngleDist(near.aim2 + Math.PI, relAim + Math.PI) <= Math.PI) {
                                                place(2, relAim, 1);
                                            } else {
                                                player.items[4] == 15 && place(4, relAim, 1);
                                            }
                                        } else {
                                            if (UTILS.getAngleDist(near.aim2, relAim) <= config.gatherAngle / 1.5) {
                                                place(2, relAim, 1);
                                            } else {
                                                player.items[4] == 15 && place(4, relAim, 1);
                                            }
                                        }
                                    } else {
                                        place(id, relAim, 1);
                                    }
                                    tmpObjects.push({
                                        x: tmpX,
                                        y: tmpY,
                                        active: true,
                                        blocker: item.blocker,
                                        scale: item.scale,
                                        isItem: true,
                                        type: null,
                                        colDiv: item.colDiv,
                                        getScale: function () {
                                            return this.scale;
                                        },
                                    });
                                    if (UTILS.getAngleDist(near.aim2, relAim) <= 1) {
                                        counts.placed++;
                                    }
                                }
                                if (counts.placed > 0 && replacer && item.dmg) {
                                    if (near.dist2 <= items.weapons[player.weapons[0]].range + (player.scale * 1.8) && configs.spikeTick) {
                                        instaC.canSpikeTick = true;
                                    }
                                }
                            } catch (err) {
                            }
                        };
                        this.checkSpikeTick = function () {
                            try {
                                if (![3, 4, 5].includes(near.primaryIndex)) return false;
                                if ((getEl("safeAntiSpikeTick").checked || my.autoPush) ? false : near.primaryIndex == undefined ? true : (near.reloads[near.primaryIndex] > game.tickRate)) return false;
                                // more range for safe. also testing near.primaryIndex || 5
                                if (near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                    let item = items.list[9];
                                    let tmpS = near.scale + item.scale + (item.placeOffset || 0);
                                    let danger = 0;
                                    let counts = {
                                        attempts: 0,
                                        block: `unblocked`
                                    };
                                    for (let i = -1; i <= 1; i += 1 / 10) {
                                        counts.attempts++;
                                        let relAim = UTILS.getDirect(player, near, 2, 2) + i;
                                        let tmpX = near.x2 + tmpS * Math.cos(relAim);
                                        let tmpY = near.y2 + tmpS * Math.sin(relAim);
                                        let cantPlace = gameObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                        if (cantPlace) continue;
                                        if (tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                        danger++;
                                        counts.block = `blocked`;
                                        break;
                                    }
                                    if (danger) {
                                        my.anti0Tick = 1;
                                        player.chat.message = "";
                                        return true;
                                    }
                                }
                            } catch (err) {
                                return null;
                            }
                            return false;
                        }
                        this.protect = function (aim) {
                            if (!configs.antiTrap) return;
                            if (player.items[4]) {
                                this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), aim + Math.PI);
                                this.antiTrapped = true;
                            }
                        };
                        let placedSpikePositions = new Set();
                        let placedTrapPositions = new Set();

                        function isBroken() {

                        }
                        this.testPrePlace = function () {
                            if (enemy.length) {
                                let prePlaceObj = gameObjects.find(U => (getDist(player, U) <= 250) && (100*U.buildHealth/U.health) <= Math.max(getPossibleObjDmg(player), getPossibleObjDmg(enemy)) + 10);
                                if (enemy.length && prePlaceObj && !player.inTrap && ((getDist(player, prePlaceObj) <= items.weapons[player.weapons[0]].range) && (getDist(enemy, prePlaceObj) <= items.weapons[player.weapons[0]].range))) {
                                    let position = player.buildItemPosition(items.list[player.items[2]], getDir(player, prePlaceObj));
                                    let tmpObjPredict = {
                                        x: position.x,
                                        y: position.y,
                                        scale: items.list[player.items[2]].scale,
                                    };
                                    if (enemy.length) {
                                        placeVisible.add(position, 1, prePlaceObj, tmpObjPredict.scale, true);
                                    }
                                    setTickout(() => {
                                        spikeTickPlace(2, getDir(player, prePlaceObj));
                                        placeableSpikes.filter((i)=>UTILS.getAngleDist(i, getDir(player, prePlaceObj)) <= Math.PI/2).forEach(function(i){
                                            spikeTickPlace(2, i)
                                        })
                                    }, 1);
                                }
                            }
                        }
                        function getPossibleObjDmg(user) {
                            return (items.weapons[player.weapons[player.weapons[1] ? Number(player.weapons[1] == 10) : 0]].dmg / 4) * (player.skins[40] ? 3.3 : 1) * (items.weapons[player.weapons[Number(player.weapons[1] == 10)]].sDmg || 1);
                        }
                        function spikeTickPlace(id, radian) {
                            var item = items.list[player.items[id]];
                            if (checkPlace(id, radian) && item.dmg) {
                                if (enemies.length && enemies.find(e => e.skinIndex != 6 && getDist(player.buildItemPosition(items.list[player.items[2]], radian), e) <= 35 + items.list[player.items[2]].scale)) {
                                    placerSpikeTick = true;
                                }
                            }
                        }
                        this.autoPlace = function () {
                            if (configs.autoPlace && game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                try {
                                    const trap1 = gameObjects
                                    .filter((e) => e.trap && e.active)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                    .find((trap) => {
                                        const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                        return (
                                            trap !== player &&
                                            (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                            trapDist <= 50
                                        );
                                    });
                                    if (this.inTrap) {
                                        let antiTrapAngles = Math.PI / Math.floor(Math.random() * (20 - 10 + 1)) + 10;
                                        this.testCanPlace(4, -(Math.PI / 2), (Math.PI / 2), antiTrapAngles, near.aim2);
                                    } else {
                                        if (trap1 && near.dist2 <= 180) {
                                            const trapX = trap1.x;
                                            const trapY = trap1.y;
                                            const circleRadius = 102;
                                            const numPositions = 64;
                                            for (let i = 0; i < numPositions; i++) {
                                                const angle = (2 * Math.PI * i) / numPositions;
                                                const offsetX = trapX + circleRadius * Math.cos(angle);
                                                const offsetY = trapY + circleRadius * Math.sin(angle);
                                                const position = [offsetX, offsetY];
                                                const distToPlayer = Math.hypot(position[0] - player.x2, position[1] - player.y2);
                                                if (
                                                    isPositionValid(position) &&
                                                    distToPlayer <= 87
                                                ) {
                                                    const angleToPlace = Math.atan2(position[1] - player.y2, position[0] - player.x2);
                                                    checkPlace(2, angleToPlace);
                                                }
                                            }
                                        } else if (!trap1 && near.dist2 <= 206) {
                                            const maxTrapsToPlace = 3;
                                            const trapRadius = 50;
                                            const trapPositions = calculatePossibleTrapPositions(player.x2, player.y2, trapRadius);
                                            let trapsPlaced = 0;
                                            for (const position of trapPositions) {
                                                if (
                                                    trapsPlaced < maxTrapsToPlace &&
                                                    isPositionValid(position)
                                                ) {
                                                    checkPlace(4, ...position);
                                                    trapsPlaced++;
                                                }
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.log(e);
                                }
                            }
                        };
                        this.autoPlace = function () { //speed place poor
                            if (getEl("autoPlacetype").value == "spamtrap2") {
                                if (game.tick % 0.5 === 0)
                                    try {
                                        if (configs.autoPlace) {
                                            const dist = near.dist2;
                                            const trap = gameObjects
                                            .filter((e) => e.trap && e.active)
                                            .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                            .find((trap) => {
                                                const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                                return (
                                                    trap !== player &&
                                                    (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                                    trapDist <= near.scale * 1.8
                                                );
                                            });
                                            if (trap && near.dist2 <= 250) {
                                                checkPlace(2, Math.atan2(player.y - trap.y, player.x - trap.x) + Math.PI);
                                            } else if (!trap && dist <= 400) {
                                                if (dist < 200) {
                                                    for (let i = (-55); i < 55; i += 55) {
                                                        checkPlace(2, near.aim2 + toR(i));
                                                    }
                                                }
                                                if (dist >= 200) {
                                                    for (let i = (-90); i < 270; i += 90) {
                                                        checkPlace(4, near.aim2 + toR(i));
                                                    }
                                                }
                                            }
                                        }
                                    } catch (e) { }
                            }
                        };

                        this.autoPlace = function () {

                            if (enemy.length && configs.autoPlace && !instaC.ticking) {
                                if (getEl("autoPlacetype").value == "spamtrap") {
                                    if (game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                        if (gameObjects.length) {
                                            let near2 = {
                                                inTrap: false,
                                            };
                                            let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                                return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                            })[0];
                                            if (nearTrap) {
                                                near2.inTrap = true;
                                            } else {
                                                near2.inTrap = false;
                                            }
                                            if (testMode ? enemy.length : (near.dist2 <= 300)) {
                                                if (near.dist2 <= 200) {
                                                    this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2, 0, { inTrap: near2.inTrap });
                                                } else {
                                                    player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                                }
                                            }
                                        } else {
                                            if (testMode ? enemy.length : (near.dist2 <= 300)) {
                                                player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                            }
                                        }
                                    }
                                }
                            }
                        };


                        this.autoPlace = function () { //HaThu best perfect place antikick
                            if (getEl("autoPlacetype").value == "ramdomplc") {
                                try {
                                    const dist = near.dist2;
                                    const trap = gameObjects
                                    .filter((e) => e.trap && e.active)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                    .find((trap) => {
                                        const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                        return (
                                            trap !== player &&
                                            (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                            trapDist <= near.scale * 1.8
                                        );
                                    });

                                    if (trap && near.dist2 <= 250) {
                                        const angleToTrap = Math.atan2(player.y - trap.y, player.x - trap.x);
                                        checkPlace(2, angleToTrap + Math.PI);
                                    } else if (!trap && dist <= 300) {
                                        if (dist < 200) {
                                            const maxAngle = Math.PI / 6;
                                            const angleMultiplier = Math.min(1, Math.max(0, (dist - 150) / 130));
                                            const adjustedAngle = maxAngle * angleMultiplier;

                                            for (let i = -55; i < 55; i += 55) {
                                                const perfectAngle = calculatePerfectAngle(near.x2, near.y2, player.x2, player.y2);
                                                checkPlace(2, perfectAngle + adjustedAngle + toR(i));
                                            }
                                        }
                                        if (dist >= 200) {
                                            const maxAngle = Math.PI / 6;
                                            const angleMultiplier = Math.min(1, Math.max(0, (dist - 150) / 130));
                                            const adjustedAngle = maxAngle * angleMultiplier;

                                            for (let i = -90; i < 270; i += 90) {
                                                const perfectAngle = calculatePerfectAngle(near.x2, near.y2, player.x2, player.y2);
                                                checkPlace(4, perfectAngle + adjustedAngle + toR(i));
                                            }
                                        }
                                    }
                                } catch (e) { }
                            };
                        }
                        this.autoPlace = function () {
                            if (configs.autoPlace && game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                if (getEl("autoPlacetype").value == "chimken") {
                                    let near2 = {
                                        inTrap: true,
                                    };
                                    let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                    })[0];
                                    if (nearTrap) {
                                        near2.inTrap = true;
                                    } else {
                                        near2.inTrap = true;
                                    }
                                    if ((near.dist2 <= 375)) {
                                        if (near.dist2 <= 200) {
                                            this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2, 0, {inTrap: near2.inTrap});
                                        } else {
                                            player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                        }
                                    }
                                } else {
                                    if ((near.dist2 <= 1000)) {
                                        player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                    }
                                }
                            }
                        };
                        this.autoPlace = function () {
                            if (configs.autoPlace && game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                if (getEl("autoPlacetype").value == "aiplace") {
                                    try {
                                        const trap1 = gameObjects
                                        .filter((e) => e.trap && e.active)
                                        .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                        .find((trap) => {
                                            const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                            return (
                                                trap !== player &&
                                                (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                                trapDist <= 50
                                            );
                                        });
                                        if (this.inTrap) {
                                            let antiTrapAngles = Math.PI / Math.floor(Math.random() * (20 - 10 + 1)) + 10;
                                            this.testCanPlace(4, -(Math.PI / 2), (Math.PI / 2), antiTrapAngles, near.aim2);
                                        } else {
                                            if (trap1 && near.dist2 <= 180) {
                                                const trapX = trap1.x;
                                                const trapY = trap1.y;
                                                const circleRadius = 102;
                                                const numPositions = 64;
                                                for (let i = 0; i < numPositions; i++) {
                                                    const angle = (2 * Math.PI * i) / numPositions;
                                                    const offsetX = trapX + circleRadius * Math.cos(angle);
                                                    const offsetY = trapY + circleRadius * Math.sin(angle);
                                                    const position = [offsetX, offsetY];
                                                    const distToPlayer = Math.hypot(position[0] - player.x2, position[1] - player.y2);
                                                    if (
                                                        isPositionValid(position) &&
                                                        distToPlayer <= 87
                                                    ) {
                                                        const angleToPlace = Math.atan2(position[1] - player.y2, position[0] - player.x2);
                                                        checkPlace(2, angleToPlace);
                                                    }
                                                }
                                            } else if (!trap1 && near.dist2 <= 206) {
                                                const maxTrapsToPlace = 3;
                                                const trapRadius = 50;
                                                const trapPositions = calculatePossibleTrapPositions(player.x2, player.y2, trapRadius);
                                                let trapsPlaced = 0;
                                                for (const position of trapPositions) {
                                                    if (
                                                        trapsPlaced < maxTrapsToPlace &&
                                                        isPositionValid(position)
                                                    ) {
                                                        checkPlace(4, ...position);
                                                        trapsPlaced++;
                                                    }
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        console.log(e);
                                    }
                                }
                            };
                        }

                        this.autoPlace = function () {
                            //    if (!configs.autoplacer) return;
                            if (enemy.length && configs.autoPlace && !instaC.ticking) {
                                if (game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0) {
                                    if (gameObjects.length) {
                                        let near2 = {
                                            inTrap: false,
                                        };
                                        let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                        })[0];
                                        if (nearTrap) {
                                            near2.inTrap = true;
                                        } else {
                                            near2.inTrap = false;
                                        }
                                        if (near.dist3 <= 450) {
                                            if (near.dist3 <= 200) {
                                                this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2, 0, {
                                                    inTrap: near2.inTrap
                                                });
                                            } else {
                                                player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                            }
                                        }
                                    } else {
                                        if (near.dist3 <= 450) {
                                            player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                        }
                                    }
                                }
                            }
                        };

                        /* function autoPlace() { // bug place
 let nearObj = [];
 if (gameObjects.length && enemy.length) {
     let inTrap = false;
     nearObj = gameObjects.filter((e)=>e.trap).sort(function(a, b) {
         return (UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2));
     })[0];
     if (nearObj) {
         if (!(player.sid != nearObj.owner.sid && !findAllianceBySid(nearObj.owner.sid)) && UTILS.getDist(nearObj, near, 0, 2) <= 70 && nearObj.active) {
             inTrap = true;
         } else {
             inTrap = false;
         }
         if (near.dist2 <= 350) {
             if (inTrap && near.dist2 <= 200) {
                 if (near.dist2 <= player.scale + near.scale + Math.PI * 2) {
                     checkPlace(2, near.aim2 - UTILS.getDirect(nearObj, near, 0, 2));
                     checkPlace(2, near.aim2 + UTILS.getDirect(nearObj, near, 0, 2));
                 }
             }
             if (near.dist2 <= near.scale + player.scale) {
                 checkPlace(2, near.aim2);
             } else {
                 if (near.dist2 <= 200 && !instaC.canSpikeTick && !traps.in && !inTrap) {
                     checkPlace(2, near.aim2 + UTILS.toRad(90));
                     checkPlace(2, near.aim2 - UTILS.toRad(90));
                 } else {
                     if (near.dist2 <= 250) {
                         checkPlace(2, near.aim2 + Math.PI);
                     } else {
                         for (let i = 0; i < 360; i += 90) {
                             checkPlace(4, UTILS.toRad(i));
                         }
                     }
                 }
             }
         }
     }
 }
}*/





                        this.autoplace = function () {
                            let oldXY = {
                                x: undefined,
                                y: undefined,
                            };
                            if (getEl("autoPlacetype").value == "magicplace") {



                                let nearObj = [];
                                let randomDir = Math.random() * Math.PI * 2;
                                if (gameObjects.length && enemy.length) {
                                    let nearsa = {
                                        inTrap: false,
                                    };
                                    nearObj = gameObjects.filter((e) => e.trap).sort(function (a, b) {
                                        return (UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2));
                                    })[0];
                                    let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                    })[0];
                                    let near2 = {
                                        inTrap: false,
                                    };
                                    if (nearTrap) {
                                        near2.inTrap = true;
                                    } else {
                                        near2.inTrap = false;
                                    }
                                    if (nearObj) {
                                        if (!(player.sid != nearObj.owner.sid && !findAllianceBySid(nearObj.owner.sid)) && UTILS.getDist(nearObj, near, 0, 2) <= 70 && nearObj.active) {
                                            nearsa.inTrap = true;
                                        } else {
                                            nearsa.inTrap = false;
                                        }
                                        if (near.dist2 <= 600) {
                                            if (nearsa.inTrap || near.dist2 <= 60 + near.scale) {
                                                if (near.dist2 <= 250) {
                                                    for (let i = 0; i < Math.PI * 2; i += Math.PI / 1.5) {
                                                        checkPlace(2, near.aim2 + i);
                                                    }
                                                } else {
                                                    for (let i = Math.PI / 1.5; i < Math.PI * 2; i += Math.PI / 1.5) {
                                                        checkPlace(2, near.aim2 + i);
                                                    }
                                                }
                                            } else {
                                                if (player.items[4] == 15) {
                                                    if (near.dist2 <= 200) {
                                                        for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                                            checkPlace(4, randomDir + i);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if (near.dist2 <= 400) {
                                            if (player.items[4] == 15) {
                                                checkPlace(4, near.aim2);
                                            }
                                        }
                                    }
                                }
                            }
                        }



                        /*    this.replacer = function(findObj) {
                       if (!findObj || !configs.autoReplace) return;
                       if (!inGame) return;
                       if (this.antiTrapped) return;
                       game.tickBase(() => {
                           let objAim = UTILS.getDirect(findObj, player, 0, 2);
                           let objDst = UTILS.getDist(findObj, player, 0, 2);
                           if (configs.autoGrind && objDst <= items.weapons[player.weaponIndex].range + player.scale) return;
                           if (objDst <= 400 && near.dist2 <= 400) {
                               let danger = this.checkSpikeTick();
                               if (!danger && near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                   //this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), objAim, 1);
                                   this.testCanPlace(2, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                               } else {
                                   player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                               }
                               this.replaced = true;
               }
           }, 1);
       };
   }
};*/
                        function calculatePerfectAngle(x1, y1, x2, y2) {
                            return Math.atan2(y2 - y1, x2 - x1);
                        }
                        this.replacer = function (findObj) {
                            if (!findObj || !configs.autoReplace || !inGame || this.antiTrapped) return;
                            game.tickBase(() => {
                                let objAim = UTILS.getDirect(findObj, player, 0, 2);
                                let objDst = UTILS.getDist(findObj, player, 0, 2);
                                const canPlaceCondition = [4, 5].includes(player.weapons[0]) && near.dist2 <= items.weapons[near.primaryIndex || 5].range + (player.scale * 1.5) && player.reloads[player.weapons[0]] == 0;
                                if (getEl("weaponGrind").checked && objDst <= items.weapons[player.weaponIndex].range + player.scale) return;
                                if (objDst <= 400 && near.dist2 <= 400) {
                                    if (canPlaceCondition) {
                                        if (getEl("replaceType").value == "trap") {
                                            this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                        } else if (getEl("replaceType").value == "spike") {
                                            this.testCanPlace(2, -Math.PI/4, Math.PI/4, (Math.PI / 20), near.aim2, 1);
                                            this.testCanPlace(2, objAim, 1);
                                            instaC.canSpikeTick = true;
                                        }
                                    } else {
                                        if (getEl("replaceType").value == "trap") {
                                            this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                        } else if (getEl("replaceType").value == "spike") {
                                            this.testCanPlace(2, -Math.PI/4, Math.PI/4, (Math.PI / 20), near.aim2, 1);
                                            this.testCanPlace(2, objAim, 1);
                                        }
                                    }
                                    this.replaced = true;
                                }
                            }, 1);
                        }
                        this.replacer = function (findObj) {
                            if (!findObj || !configs.autoReplace) return;
                            if (!inGame) return;
                            if (this.antiTrapped) return;
                            game.tickBase(() => {
                                let objAim = UTILS.getDirect(findObj, player, 0, 2);
                                let objDst = UTILS.getDist(findObj, player, 0, 2);
                                const canPlaceCondition = [4, 5].includes(player.weapons[0]) && near.dist2 <= items.weapons[near.primaryIndex || 5].range + (player.scale * 1.5) && player.reloads[player.weapons[0]] == 0;
                                if (getEl("weaponGrind").checked && objDst <= items.weapons[player.weaponIndex].range + player.scale) return;
                                if (objDst <= 400 && near.dist2 <= 400) {
                                    let danger = this.checkSpikeTick();
                                    if (!danger && near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                        //this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), objAim, 1);
                                        this.testCanPlace(2, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    } else {
                                        player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    }
                                    this.replaced = true;
                                }
                            }, 1);
                        };
                    }
                };
                class TrapsGood {
                    constructor(UTILS, items) {
                        this.dist = 0;
                        this.aim = 0;
                        this.inTrap = false;
                        this.replaced = false;
                        this.antiTrapped = false;
                        this.hasSpike = false;
                        this.info = {};
                        this.notFast = function() {
                            return player.weapons[1] == 10 && ((this.info.health > items.weapons[player.weapons[0]].dmg) || player.weapons[0] == 5);
                        }
                        this.notFast_ = function(object = this.info[0]) {
                            if (player.weapons[1] != 10) return false;

                            if ((object.health > items.weapons[player.weapons[0]].dmg) || [5].includes(player.weapons[0])) return true;

                            return false;
                        }

                        this.testCanPlace = function(id, first = -(Math.PI / 2), repeat = (Math.PI / 2), plus = (Math.PI / 18), radian, replacer, yaboi) {
                            try {
                                let item = items.list[player.items[id]];
                                let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                                let counts = {
                                    attempts: 0,
                                    placed: 0
                                };
                                let tmpObjects = [];
                                gameObjects.forEach((p) => {
                                    tmpObjects.push({
                                        x: p.x,
                                        y: p.y,
                                        active: p.active,
                                        blocker: p.blocker,
                                        scale: p.scale,
                                        isItem: p.isItem,
                                        type: p.type,
                                        colDiv: p.colDiv,
                                        getScale: function(sM, ig) {
                                            sM = sM || 1;
                                            return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4)
                                                                 ? 1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
                                        },
                                    });
                                });
                                for (let i = first; i < repeat; i += plus) {
                                    counts.attempts++;
                                    let relAim = radian + i;
                                    let tmpX = player.x2 + tmpS * Math.cos(relAim);
                                    let tmpY = player.y2 + tmpS * Math.sin(relAim);
                                    let cantPlace = tmpObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                    if (cantPlace) continue;
                                    if (item.id != 19 && tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                    if ((!replacer && yaboi) || useWasd) {
                                        if (useWasd ? false : yaboi.inTrap) {
                                            if (UTILS.getAngleDist(near.aim2 + Math.PI, relAim + Math.PI) <= Math.PI) {
                                                place(2, relAim, 1);
                                            } else {
                                                player.items[4] == 15 && place(4, relAim, 1);
                                            }
                                        } else {
                                            if (UTILS.getAngleDist(near.aim2, relAim) <= config.gatherAngle / 1.5) {
                                                place(2, relAim, 1);
                                            } else {
                                                player.items[4] == 15 && place(4, relAim, 1);
                                            }
                                        }
                                    } else {
                                        place(id, relAim, 1);
                                    }
                                    tmpObjects.push({
                                        x: tmpX,
                                        y: tmpY,
                                        active: true,
                                        blocker: item.blocker,
                                        scale: item.scale,
                                        isItem: true,
                                        type: null,
                                        colDiv: item.colDiv,
                                        getScale: function() {
                                            return this.scale;
                                        },
                                    });
                                    if (UTILS.getAngleDist(near.aim2, relAim) <= 1) {
                                        counts.placed++;
                                    }
                                }
                                if (counts.placed > 0 && replacer && item.dmg) {
                                    if (near.dist2 <= items.weapons[player.weapons[0]].range + (player.scale * 1.8)) {
                                        instaC.canSpikeTick = true;
                                    }
                                }
                            } catch (err) {
                            }
                        };
                        // ANTI SP TICK
                        this.checkSpikeTick = function () {
                            try {
                                if (![3, 4, 5].includes(near.primaryIndex)) return false;

                                if (((configs.SafeAntiSpikeTick ?? false) || my.autoPush) ? false : near.primaryIndex == undefined ? true : (near.reloads[near.primaryIndex] > game.tickRate)) return false;

                                if (near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                    let item = items.list[9];
                                    let tmpS = near.scale + item.scale + (item.placeOffset || 0);

                                    let spikeX = near.x2 + tmpS * Math.cos(near.aim2);
                                    let spikeY = near.y2 + tmpS * Math.sin(near.aim2);

                                    let cantPlace = closeObjects.find((tmp) => tmp.active &&
                                                                      UTILS.getDistance(spikeX, spikeY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem))
                                                                     );

                                    let danger = 0;
                                    let counts = {
                                        attempts: 0,
                                        block: `unblocked`
                                    };

                                    for (let i = -1; i <= 1; i += 1 / 10) {
                                        counts.attempts++;
                                        let relAim = UTILS.getDirect(player, near, 2, 2) + i;
                                        let tmpX = near.x2 + tmpS * Math.cos(relAim);
                                        let tmpY = near.y2 + tmpS * Math.sin(relAim);

                                        let cantPlace = gameObjects.find((tmp) => tmp.active &&
                                                                         UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem))
                                                                        );

                                        if (cantPlace) continue;
                                        if (tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;

                                        danger++;
                                        counts.block = `blocked`;
                                        break;
                                    }

                                    if (danger) {
                                        my.anti0Tick = 1;
                                        return true;
                                    }
                                }
                            } catch (err) {
                                return null;
                            }
                            return false;
                        };
                        function getDist(e, t) {
                            try {
                                return Math.hypot((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
                            } catch (e) {
                                return Infinity;
                            }
                        }

                        this.protect = function (aim, obj) {
                            if (!configs.antiTrap) return;

                            this.testCanPlace(4, -(Math.PI / 2), (Math.PI / 2), (Math.PI / (24 - 6)), aim + Math.PI);
                            this.antiTrapped = true;
                        };

                        let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function(a, b) {
                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                        })[0];

                        let testMode = window.location.hostname == "1";
                        let autoQ = false;
                        this.antiSpT = function () {
                            return this.antiSpikeTick();
                        }
                        function getEnemyVelocity(near) {
                            return Math.sqrt(near.xVel * near.xVel + near.yVel * near.yVel);
                        }

                        function getEnemyDirection(near) {
                            return Math.atan2(near.yVel, near.xVel);
                        }
                        function findAnglesToTest() {
                            let anglesToTest = [];

                            for (let i = 0; i < 360; i += 250) {
                                anglesToTest.push((Math.PI/180) * i);
                            }

                            return anglesToTest;
                        }
                        function findAnglesToTest2(obj, player) {
                            let perfectAngle = UTILS.getDirect(obj, player, 0, 2);
                            for (let i = 0; i < 360; i += 25) {
                                perfectAngle.push((Math.PI/180) * i);
                            }
                            return perfectAngle;
                        }
                        function findAnglesToTest1() {
                            let anglesToTest = [];

                            for (let i = 0; i < 360; i += 25) {
                                anglesToTest.push((Math.PI/180) * i);
                            }

                            return anglesToTest;
                        }
                        UTILS.deg2rad = function (degrees) {
                            return degrees * (Math.PI / 180);
                        }
                        let placedSpikePositions = new Set();
                        let placedTrapPositions = new Set();
                        var breakTrack = [];
                        const PLACE_SPEED = 100;
                        function calculatePerfectAngle(x1, y1, x2, y2) {
                            return Math.atan2(y2 - y1, x2 - x1);
                        }
                        function isObjectBroken(object) {
                            const healthThreshold = 20;
                            return object.health < healthThreshold;
                        }
                        function PlacementLocation(x, y, trapType) {
                            this.x = x;
                            this.y = y;
                            this.trapType = trapType;
                        }
                        function checkPlaceWithAngles1(angle1, angle2, x, y) {
                            checkPlace(4, x, y, angle1, angle2);
                        }
                        function checkPlaceWithAngles2(angle1, angle2, x, y) {
                            checkPlace(2, x, y, angle1, angle2);
                        }
                        this.autoPlace = function () {
                            let closeObjects=liztobj
                            let yes=game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0
                            if (!yes||!enemy.length || instaC.ticking || near.dist2 > 300) return;
                            //if(game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0)
                            if (secPacket <= 90) {
                                const autoPlaceTick = Math.max(1, parseInt()) || 1;
                                if (game.tick % autoPlaceTick !== 0) return;

                                if (!closeObjects.length) return;

                                const near2 = { inTrap: false };
                                const nearTrap = closeObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5))
                                .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))[0];

                                if (nearTrap) near2.inTrap = true;

                                function predictEnemyPosition(enemy) {
                                    const predictionTime = 0.5;
                                    const predictedX = enemy.x + enemy.xVel * predictionTime;
                                    const predictedY = enemy.y + enemy.yVel * predictionTime;

                                    return { x: predictedX, y: predictedY };
                                }

                                function isPositionValid(position) {
                                    const playerX = player.x2;
                                    const playerY = player.y2;
                                    const distToPosition = Math.hypot(position[0] - playerX, position[1] - playerY);

                                    return distToPosition > 35;
                                }

                                /*
                if (near.dist2 <= 385) {
                    const aimAngle = near.aim2;
                    const fullCircle = Math.PI * 2;
                    const smallStep = Math.PI / 36;

                    if (near.dist2 <= 200) {
                        this.testCanPlace(4, 0, fullCircle, smallStep, aimAngle, 0, { inTrap: near2.inTrap });
                    } else if (player.items[4] === 15) {
                        this.testCanPlace(4, 0, fullCircle, smallStep, aimAngle);
                    }
                }*/

                                let randomDir = Math.random() * Math.PI * 1.5;
                                if (closeObjects.length) {
                                    let tryTicked = [3, 4, 5].includes(near.primaryIndex);

                                    const id = nearTrap || near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 ? 2 : 4;
                                    this.testCanPlace(id, -(Math.PI * 1.5), randomDir, Math.PI / 48, near.aim2, tryTicked && id === 2);
                                } else {
                                    this.testCanPlace(4, 0, Math.PI * 2, Math.PI / 24, randomDir);
                                }

                                if (nearTrap && near.dist2 <= 160) {
                                    const trapX = nearTrap.x;
                                    const trapY = nearTrap.y;
                                    const circleRadius = 102;
                                    const numPositions = 72;

                                    for (let i = 0; i < numPositions; i++) {
                                        const angle = (2 * Math.PI * i) / numPositions;
                                        const offsetX = trapX + circleRadius * Math.cos(angle);
                                        const offsetY = trapY + circleRadius * Math.sin(angle);
                                        const position = [offsetX, offsetY];
                                        const distToPlayer = Math.hypot(position[0] - player.x2, position[1] - player.y2);

                                        const predictedEnemy = predictEnemyPosition(near);
                                        const predictedDist = Math.hypot(predictedEnemy.x - position[0], predictedEnemy.y - position[1]);

                                        if (!placedSpikePositions.has(JSON.stringify(position)) && isPositionValid(position) && distToPlayer <= 87 && predictedDist <= 50) {
                                            const angleToPlace = Math.atan2(position[1] - player.y2, position[0] - player.x2);
                                            checkPlace(2, angleToPlace);
                                            placedSpikePositions.add(JSON.stringify(position));
                                        }
                                    }
                                }
                            }
                        };
                    }

                    replacer(findObj) {
                        if (!findObj || !configs.autoReplace || !inGame || this.antiTrapped) return;

                        this.angles = this.angles || [];

                        let objAim = UTILS.getDirect(findObj, player, 0, 2);
                        let objDst = UTILS.getDist(findObj, player, 0, 2);
                        let weaponRange = items.weapons[player.weaponIndex].range + player.scale;

                        if (getEl("weaponGrind").checked && objDst <= weaponRange) return;

                        let danger = this.checkSpikeTick();
                        let canPlaceCondition = [4, 5].includes(player.weapons[0]) && !danger;

                        let spikSync = false;
                        game.tickBase(() => {
                            if (objDst <= 300 && near.dist2 <= 300) {
                                let inRange = near.dist3 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8);
                                let checkCanSpikeSync = !danger && (inRange || (traps.inTrap && objDst <= 150) || near.inTrap);

                                if (checkCanSpikeSync) {
                                    this.angles.push(objAim);

                                    if (this.angles.length > 5) {
                                        this.angles.shift();
                                    }

                                    let smoothedAngle = this.angles.reduce((a, b) => a + b, 0) / this.angles.length;

                                    smoothedAngle += Math.PI / 2;

                                    let timeAdjustment = (Math.PI / 24) * Math.sin(Date.now() / 1000);
                                    let placementAngle = smoothedAngle + timeAdjustment;

                                    this.testCanPlace(2, placementAngle, placementAngle + Math.PI * 2, Math.PI / 24, placementAngle - Math.PI, 1);
                                    this.testCanPlace(2, 0, Math.PI * 2, Math.PI / 24, objAim, 1);

                                    spikSync = true;
                                } else if (player.items[4] === 15 || near.dist2 <= 100) {
                                    spikSync = false;

                                    let trapPlacementAngle = objAim + Math.PI;

                                    player.items[4] == 15 &&
                                        this.testCanPlace(
                                        4,
                                        trapPlacementAngle,
                                        trapPlacementAngle + Math.PI * 2,
                                        Math.PI / 24,
                                        objAim, 1
                                    );
                                } else {
                                    spikSync = false;

                                    let startAngle = Math.random() * Math.PI * 1.5;
                                    let step = Math.PI / (32 + Math.random() * 12);

                                    this.testCanPlace(4, -startAngle, Math.PI * 1.5, step, objAim, 1);
                                    this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim , 1);
                                }

                                let checkAim = UTILS.getAngleDist(near.aim2, objAim) <= 1;
                                if (inRange && checkAim) {// if got aim to preobject can use him here for preSpikeSync
                                    if (checkCanSpikeSync) {
                                        if ([3, 4, 5, 8].includes(player.weapons[0]) && !instaC.isTrue) {
                                            instaC.canSpikeTick = true;
                                        }
                                    } else {
                                        checkPlace(4, objAim);
                                        //ShowSettingText(300, "reTrap test", "#00c", findObj);
                                    }
                                }

                                this.replaced = true;
                            }
                        }, 1);
                    }
                };

                class Traps_ {
                    get preferedWeaponIndex(){
                        return player.weaponIndex
                    }
                    constructor(UTILS, items) {
                        let spikePlaced = false;
                        let spikSync = false;
                        this.brokenObj=[];
                        this.dist = 0;
                        this.aim = 0;
                        this.inTrap = false;
                        this.replaced = false;
                        this.antiTrapped = false;
                        this.info = {};
                        this.angles = [];
                        this.markers = [];
                        this.antiTrapped = false;
                        this.replaced    = false;
                        this.preplacements = 0;
                        // spike sync flag
                        this.spikSync   = false;
                        this.notFast = function() {
                            return player.weapons[1] == 10 && ((this.info.health > items.weapons[player.weapons[0]].dmg) || player.weapons[0] == 5);
                        }

                        this.nearTrap = function () {
                            return gameObjects.filter(
                                (object) =>
                                object.trap &&
                                object.active &&
                                UTILS.getDist(object, player, 0, 2) <=
                                player.scale + object.getScale() + 5
                            );
                        };
                        this.isEnemyInTrap = function (enemy) {
                            let nearTraps = this.nearTrap();
                            return nearTraps.some(
                                (trap) =>
                                UTILS.getDist(trap, enemy, 0, 2) <= trap.getScale() + near.scale
                            );
                        };
                        let chicken=this;
                        this.addMarker = ({ x, y, name, id, angle, scale, differentVisual }) => {
                            // default angle to 0 if invalid
                            const ang = (typeof angle === "number" && !isNaN(angle)) ? angle : 0;

                            // push a new marker onto our list
                            this.markers.push({
                                x,
                                y,
                                id,
                                angle: ang,
                                name,
                                differentVisual: !!differentVisual,
                                owner: { sid: player.sid },
                                scale,
                                ticks: game.tick
                            });

                            // automatically remove it after 2 ticks
                            game.tickBase(() => {
                                this.markers.shift();
                            }, 2);
                        };
                        this.testCanPlace = function(id, first = -(Math.PI / 2), repeat = (Math.PI / 2), plus = (Math.PI / 18), radian, replacer, yaboi) {
                            try {
                                let item = items.list[player.items[id]];
                                let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                                let counts = {
                                    attempts: 0,
                                    placed: 0
                                };
                                let tmpObjects = [];
                                gameObjects.forEach((p) => {
                                    tmpObjects.push({
                                        x: p.x,
                                        y: p.y,
                                        active: p.active,
                                        blocker: p.blocker,
                                        scale: p.scale,
                                        isItem: p.isItem,
                                        type: p.type,
                                        colDiv: p.colDiv,
                                        getScale: function(sM, ig) {
                                            sM = sM || 1;
                                            return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4)
                                                                 ? 1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
                                        },
                                    });
                                });
                                for (let i = first; i < repeat; i += plus) {
                                    counts.attempts++;
                                    let relAim = radian + i;
                                    let tmpX = player.x2 + tmpS * Math.cos(relAim);
                                    let tmpY = player.y2 + tmpS * Math.sin(relAim);
                                    let cantPlace = tmpObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                    if (cantPlace) continue;
                                    if (item.id != 19 && tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                    if ((!replacer && yaboi) || useWasd) {
                                        if (useWasd ? false : yaboi.inTrap) {
                                            if (UTILS.getAngleDist(near.aim2 + Math.PI, relAim + Math.PI) <= Math.PI) {
                                                place(2, relAim, 1);
                                            } else {
                                                player.items[4] == 15 && place(4, relAim, 1);
                                            }
                                        } else {
                                            if (UTILS.getAngleDist(near.aim2, relAim) <= config.gatherAngle / 1.5) {
                                                place(2, relAim, 1);
                                            } else {
                                                player.items[4] == 15 && place(4, relAim, 1);
                                            }
                                        }
                                    } else {
                                        place(id, relAim, 1);
                                    }
                                    tmpObjects.push({
                                        x: tmpX,
                                        y: tmpY,
                                        active: true,
                                        blocker: item.blocker,
                                        scale: item.scale,
                                        isItem: true,
                                        type: null,
                                        colDiv: item.colDiv,
                                        getScale: function() {
                                            return this.scale;
                                        },
                                    });
                                    if (UTILS.getAngleDist(near.aim2, relAim) <= 1) {
                                        counts.placed++;
                                    }
                                }
                                if (counts.placed > 0 && replacer && item.dmg) {
                                    if (near.dist2 <= items.weapons[player.weapons[0]].range + (player.scale * 1.8) && configs.spikeTick) {
                                        instaC.canSpikeTick = true;
                                    }
                                }
                            } catch (err) {
                            }
                        };
                        this.checkSpikeTick = function() {
                            try {
                                if (![3, 4, 5].includes(near.primaryIndex)) return false;
                                if ((getEl("safeAntiSpikeTick").checked || my.autoPush) ? false : near.primaryIndex == undefined ? true : (near.reloads[near.primaryIndex] > game.tickRate)) return false;
                                // more range for safe. also testing near.primaryIndex || 5
                                if (near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                    let item = items.list[9];
                                    let tmpS = near.scale + item.scale + (item.placeOffset || 0);
                                    let danger = 0;
                                    let counts = {
                                        attempts: 0,
                                        block: `unblocked`
                                    };
                                    for (let i = -1; i <= 1; i += 1 / 10) {
                                        counts.attempts++;
                                        let relAim = UTILS.getDirect(player, near, 2, 2) + i;
                                        let tmpX = near.x2 + tmpS * Math.cos(relAim);
                                        let tmpY = near.y2 + tmpS * Math.sin(relAim);
                                        let cantPlace = gameObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                        if (cantPlace) continue;
                                        if (tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                        danger++;
                                        counts.block = `blocked`;
                                        break;
                                    }
                                    if (danger) {
                                        my.anti0Tick = 1;
                                        player.chat.count = 100000;
                                        return true;
                                    }
                                }
                            } catch (err) {
                                return null;
                            }
                            return false;
                        }
                        this.protect = function (aim) {
                            if (!configs.antiTrap) return;
                            if (player.items[4]) {
                                this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), aim + Math.PI);
                                this.antiTrapped = true;
                            }
                        };
                        UTILS.deg2rad = function (degrees) {
                            return degrees * (Math.PI / 180);
                        }
                        function calculatePerfectAngle(x1, y1, x2, y2) {
                            return Math.atan2(y2 - y1, x2 - x1);
                        }
                        function getEnemyVelocity(near) {
                            return Math.sqrt(near.xVel * near.xVel + near.yVel * near.yVel);
                        }

                        function getEnemyDirection(near) {
                            return Math.atan2(near.yVel, near.xVel);
                        }
                        function isPositionValid(position) {
                            const playerX = player.x2;
                            const playerY = player.y2;
                            const distToPosition = Math.hypot(position[0] - playerX, position[1] - playerY);
                            return distToPosition > 35;
                        }
                        this.unsafeGameObjects = {
                            near: [],
                            near350: [],
                            spikes: [],
                        };

                        function n(e) {
                            return e && e.isBuffer && e
                        }

                        function calculatePossibleTrapPositions(x, y, radius) {
                            const trapPositions = [];
                            const numPositions = 8;
                            for (let i = 0; i < numPositions; i++) {
                                const angle = (2 * Math.PI * i) / numPositions;
                                const offsetX = x + radius * Math.cos(angle);
                                const offsetY = y + radius * Math.sin(angle);
                                const position = [offsetX, offsetY];
                                if (!trapPositions.some((pos) => isPositionTooClose(position, pos))) {
                                    trapPositions.push(position);
                                }
                            }
                            return trapPositions;
                        }
                        function isPositionTooClose(position1, position2, minDistance = 50) {
                            const dist = Math.hypot(position1[0] - position2[0], position1[1] - position2[1]);
                            return dist < minDistance;
                        }

                        function dotProduct(vector1, vector2) {
                            return vector1.x * vector2.x + vector1.y * vector2.y;
                        }

                        function magnitude(vector) {
                            return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                        }

                        this.getItemPlaceLocation = function(obj, dir) {
                            let item = items.list[player.items[obj]];
                            let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                            let tmpX = player.x + tmpS * Math.cos(dir);
                            let tmpY = player.y + tmpS * Math.sin(dir);
                            return {
                                x: tmpX,
                                y: tmpY
                            };
                        };
                        function vectorDifference(point1, point2) {
                            return {
                                x: point2.x - point1.x,
                                y: point2.y - point1.y
                            };
                        }
                        function calculateAngleUsingDotProduct(point1, point2) {
                            let diffVector = vectorDifference(point1, point2);
                            let playerDirection = {
                                x: Math.cos(player.dir),
                                y: Math.sin(player.dir)
                            };
                            let dotProd = dotProduct(playerDirection, diffVector);
                            let magnitudeProd = magnitude(playerDirection) * magnitude(diffVector);
                            let cosTheta = dotProd / magnitudeProd;
                            let dynamicAngle = Math.acos(cosTheta);
                            dynamicAngle *= 180 / Math.PI;
                            if (dynamicAngle < 0) dynamicAngle += 360;
                            return dynamicAngle;
                        }
                        function caf(e, t) {
                            try {
                                return Math.atan2((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
                            } catch (e) {
                                return 0;
                            }
                        }
                        function toR(e) {
                            var n = (e * Math.PI / 180) % (2 * Math.PI);
                            return n > Math.PI ? Math.PI - n : n
                        }
                        function toD(e) {
                            var n = (e / Math.PI * 360) % 360;
                            return n >= 360 ? n - 360 : n;
                        }
                        this.selectToBuild=function(e){
                            packet("z", e)
                        }
                        this.sendHit=function(e, t){
                            packet('F',e, t)
                        }
                        this.checkMarkers = (x, y, scale, ticks) => {
                            let chicken=this;
                            for (let marker of this.markers) {
                                if (!marker) continue;
                                // distance between the candidate spot and an existing marker
                                const dist = UTILS.getDistance(marker, { x, y });
                                // if too close, and (unless it’s a differentVisual that requires matching ticks)…
                                if (
                                    dist <= marker.scale + scale &&
                                    (!marker.differentVisual || ticks === marker.ticks)
                                ) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        this.validateBuilding = entity => {
                            // 1) must be within 100 + double scale
                            if (UTILS.getDistance(player, entity) > 100 + entity.scale * 2) {
                                return false;
                            }

                            // 2) must have health
                            if (!entity.currentHealth) {
                                return false;
                            }

                            // 3) sum up potential damage from nearby players
                            let totalPotential = 0;
                            for (let p of players) {
                                if (p.visible && UTILS.getDistance(p, entity) <= 100 + entity.scale * 2) {
                                    // choose which weapon they’d use
                                    const wepId = p.secondaryWeapon === 10 ? 10 : p.primaryWeapon;
                                    // variant multiplier
                                    const variantVal =
                                          config.weaponVariants[
                                              wepId === 10 ? p.secondaryVariant : p.primaryVariant
                                          ].val || 1;
                                    const wepData = items.weapons[wepId];
                                    let damage = wepData.dmg * (wepData.sDmg || 1) * variantVal;

                                    // boost for skins or other players
                                    if (playerSID === p.sid) {
                                        if (p.skins[40]) damage *= 3.3;
                                    } else {
                                        damage *= 3.3;
                                    }

                                    // only count if in range, reloaded, and trap isn’t hiding
                                    if (
                                        UTILS.getDistance(p, entity) - entity.scale < wepData.range &&
                                        healer.reloadPercent(p, wepId) === 1 &&
                                        (!entity.trap || !entity.hideFromEnemy)
                                    ) {
                                        totalPotential += damage;
                                    }
                                }
                            }

                            // 4) rebuild if current health ≤ potential damage
                            return entity.currentHealth <= totalPotential;
                        };
                        this.calculatePosition = (entity, radius, angle) => {
                            const xBase = entity.x2 !== undefined ? entity.x2 : entity.x;
                            const yBase = entity.y2 !== undefined ? entity.y2 : entity.y;
                            return {
                                x: xBase + Math.cos(angle) * radius,
                                y: yBase + Math.sin(angle) * radius
                            };
                        };
                        this.place=function(e, t) {
                            let i = items.list[e];
                            if (i && (player.itemCounts[i.group.id] + 1 < (isSandbox ? i.group.sandboxLimit + 1 || 100 : i.group.limit) || !player.itemCounts[i.group.id]) && (chicken.selectToBuild(e), chicken.sendHit(1, t), chicken.selectToBuild(chicken.preferedWeaponIndex, true), e > 2)) {
                                let s = 35 + i.scale + (i.placeOffset || 0);
                                let n = {
                                    x: player.x2 + Math.cos(t) * s,
                                    y: player.y2 + Math.sin(t) * s
                                };
                                this.addMarker({
                                    x: n.x,
                                    y: n.y,
                                    scale: i.scale,
                                    name: i.name,
                                    angle: t,
                                    id: i.id
                                });
                            }
                        }
                        this.replacer = brokenObj => {
                            let chicken=this;
                            const near = _things.enemy.enemy;
                            const dist = UTILS.getDistance(near, player);

                            // only if in range, have a trap equipped, and autoReplace is on
                            if (
                                dist <= 400 &&
                                near &&
                                player.items[4] === 15 &&
                                configs.autoReplace
                            ) {
                                // remember broken spot, clear after 8 ticks
                                this.brokenObj.unshift({
                                    x: brokenObj.x,
                                    y: brokenObj.y,
                                    scale: brokenObj.scale
                                });
                                game.tickBase(() => this.brokenObj.pop(), 8);

                                const trapData = near.trapData;
                                const baseAng  = UTILS.getDirection(brokenObj, player);
                                const angles   = this.findAngles(baseAng);
                                let placed     = false;
                                const tickExtra = autoHit.addSpiekTickHit();

                                for (let c of angles) {
                                    // rebuild only on the exact broken trap
                                    if (
                                        trapData &&
                                        brokenObj.sid === trapData.sid &&
                                        c.trap &&
                                        UTILS.getDistance(c.pos.trap, near) <= 50
                                    ) {
                                        if (c.spike) {
                                            // spike-replace branch
                                            if (autoHit.reverseSpiketick) {
                                                this.checkPlace(player.items[2], c.angle, () => (placed = true));
                                            } else {
                                                // see if a friendly spike is already there
                                                const friendSpike = _things.liztobj.find(
                                                    o =>
                                                    o.active &&
                                                    o.dmg &&
                                                    game.isFriendly(o.owner.sid) &&
                                                    UTILS.getDistance(o, brokenObj) <= o.scale + 70
                                                );
                                                const pData = player.trapData;

                                                if (friendSpike && pData && chicken.replaceable(pData)) {
                                                    this.checkPlace(player.items[2], c.angle, () => (placed = true));
                                                } else {
                                                    // simulate to predict if a spike rebuild will knock back
                                                    const sim = kbSimulator.spikeKB(
                                                        { x: near.x2, y: near.y2, scale: 35, tmpObj: near },
                                                        c.pos.spike,
                                                        true
                                                    );

                                                    if (sim.data.find(x => x.id === "spiek")) {
                                                        const totalDmg = sim.data
                                                        .filter(x => x.id === "spiek")
                                                        .reduce((sum, x) => sum + x.dmg, 0)
                                                        + c.pos.spike.dmg
                                                        + tickExtra;

                                                        if (totalDmg >= 100) {
                                                            this.checkPlace(player.items[2], c.angle, () => {
                                                                placed = true;
                                                                sim.callback();
                                                            });
                                                        } else {
                                                            this.checkPlace(player.items[4], c.angle);
                                                        }
                                                    } else if (!friendSpike && sim.data.find(x => x.id === "trap")) {
                                                        this.checkPlace(player.items[2], c.angle, () => {
                                                            placed = true;
                                                            sim.callback();
                                                        });
                                                    } else if (tickExtra + c.pos.spike.dmg >= 100) {
                                                        // fallback to melee-knock simulation
                                                        const kbPos = kbSimulator.meleeKB(
                                                            near,
                                                            _things.enemy.enemy.angle,
                                                            player.weapons[0]
                                                        );
                                                        const blocked = _things.liztobj.find(
                                                            o =>
                                                            o.active &&
                                                            (o.dmg || o.trap) &&
                                                            game.isFriendly(o.owner.sid) &&
                                                            UTILS.getDistance(kbPos, o) <= 35 + o.scale
                                                        );
                                                        if (blocked) {
                                                            this.checkPlace(player.items[2], c.angle, () => (placed = true));
                                                        } else {
                                                            this.checkPlace(player.items[4], c.angle);
                                                        }
                                                    } else {
                                                        this.checkPlace(player.items[4], c.angle);
                                                    }
                                                }
                                            }
                                        } else {
                                            // trap-replace branch
                                            this.checkPlace(player.items[4], c.angle);
                                        }
                                    }
                                    // if it wasn’t the broken trap, but it is a spike spot
                                    else if (
                                        trapData &&
                                        c.spike &&
                                        UTILS.getDistance(c.pos.spike, trapData) <= 130
                                    ) {
                                        this.checkPlace(player.items[2], c.angle);
                                    }
                                    // or if we’re close enough to re-place
                                    else if (dist <= 200) {
                                        if (c.spike) {
                                            if (
                                                UTILS.getAngleDist(
                                                    _things.enemy.enemy.angle,
                                                    c.angle
                                                ) <= 0.75
                                            ) {
                                                this.checkPlace(player.items[2], c.angle);
                                            } else if (
                                                UTILS.getDistance(c.pos.spike, near) <= 100
                                            ) {
                                                const sim2 = kbSimulator.spikeKB(
                                                    { x: near.x2, y: near.y2, scale: 35, tmpObj: near },
                                                    c.pos.spike,
                                                    true
                                                );
                                                if (
                                                    sim2.data.find(x => x.id === "spiek" || x.id === "trap")
                                                ) {
                                                    this.checkPlace(player.items[2], c.angle, () => sim2.callback());
                                                }
                                            } else if (c.trap) {
                                                this.checkPlace(player.items[4], c.angle);
                                            }
                                        } else if (c.trap) {
                                            this.checkPlace(player.items[4], c.angle);
                                        }
                                    }
                                    // final fallback
                                    else if (c.trap) {
                                        this.checkPlace(player.items[4], c.angle);
                                    }
                                }

                                if (placed) {
                                    autoHit.spiekTick();
                                }
                            }
                        };
                        this.validateClashWithEnemy = entities => {
                            let chicken=this;
                            const clashes = [];

                            for (let obj of entities) {
                                // only consider if within rebuild range
                                if (UTILS.getDistance(player, obj) <= 100 + obj.scale * 2) {
                                    // look for any enemy overlapping this object
                                    for (let enemy of enemies) {
                                        if (UTILS.getDistance(enemy, obj) <= 100 + obj.scale * 2) {
                                            clashes.push({
                                                x: obj.x,
                                                y: obj.y,
                                                scale: obj.scale,
                                                enemy,
                                                sid: obj.sid
                                            });
                                            break; // only need one enemy to count
                                        }
                                    }
                                }
                            }

                            return clashes;
                        };
                        this.validateIfOverLap = (pos, radius, includeList, skipList) => {
                            // pos: {x, y}, radius: number, includeList: array of entities, skipList: array of sids to ignore
                            for (let ent of includeList) {
                                if (!ent.active) continue;
                                const blockerSize = ent.blocker ? ent.blocker : ent.getScale(0.6, ent.isItem);
                                const dist = UTILS.getDistance(pos, ent);
                                // if within blocking distance and not in skipList, overlap detected
                                if (dist < radius + blockerSize && !skipList.find(s => s.sid === ent.sid)) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        this.validateOpenAngle = (angle, resultsArray, preplacedList, objList) => {
                            const spikeId   = player.items[2];
                            const trapItem  = items.list[15];
                            const spikeItem = items.list[spikeId];

                            // placement radii
                            const spikeRadius = 35 + spikeItem.scale + (spikeItem.placeOffset || 0);
                            const trapRadius  = 35 + trapItem.scale  + (trapItem.placeOffset  || 0);

                            // nearest enemy
                            const nearEnemy = _things.enemy.enemy;

                            // candidate entry
                            const entry = { angle, trap: false, spike: false, pos: {}, prioritization: 0 };

                            // check trap spot
                            let pos = this.calculatePosition(player, trapRadius, angle);
                            let loc = objectManager.checkItemLocation(
                                pos.x, pos.y,
                                trapItem.scale, 0.6,
                                15, false,
                                undefined, true
                            );
                            let found = preplacedList.find(x => x.sid === loc.sid);
                            if (found && !this.validateIfOverLap(pos, trapItem.scale, preplacedList, objList)) {
                                entry.trap = true;
                                entry.pos.trap = { ...pos, scale: trapItem.scale };
                                entry.preplacedTo = UTILS.getDirection(found, player);
                                entry.enemy       = found.enemy;
                            }

                            // check spike spot
                            pos = this.calculatePosition(player, spikeRadius, angle);
                            loc = objectManager.checkItemLocation(
                                pos.x, pos.y,
                                spikeItem.scale, 0.6,
                                spikeId, false,
                                undefined, true
                            );
                            found = preplacedList.find(x => x.sid === loc.sid);
                            if (found && !this.validateIfOverLap(pos, trapItem.scale, preplacedList, objList)) {
                                entry.spike = true;
                                entry.prioritization++;
                                entry.pos.spike = { ...pos, dmg: spikeItem.dmg, scale: spikeItem.scale };
                                entry.preplacedTo = UTILS.getDirection(found, player);
                                entry.enemy       = found.enemy;
                            }

                            // if valid candidate, compute distances
                            if (entry.trap || entry.spike) {
                                const targetPos = entry.pos.spike || entry.pos.trap;
                                const closestBroken = this.brokenObj
                                .slice()
                                .sort((a, b) =>
                                      UTILS.getDistance(a, targetPos) - UTILS.getDistance(b, targetPos)
                                     )[0];

                                entry.brokenDist = closestBroken
                                    ? UTILS.getDistance(closestBroken, targetPos)
                                : Infinity;
                                entry.enemyDist = UTILS.getDistance(nearEnemy, targetPos);

                                if (entry.brokenDist <= entry.enemyDist) {
                                    entry.prioritization++;
                                }
                                resultsArray.push(entry);
                            }
                        };
                        this.findOpenAngles = preplacedList => {
                            const step        = Math.PI / parseInt(configs.placementDepth || 16);
                            const baseOffsets = [0, Math.PI];
                            const spikeId     = player.items[2];
                            const spikeItem   = items.list[spikeId];
                            const trapItem    = items.list[15];
                            const maxScale    = Math.max(spikeItem.scale, trapItem.scale);

                            // gather nearby friendly objects for overlap checks
                            const nearby = _things.liztobj.filter(
                                o => o.active && UTILS.getDistance(o, player) <= 35 + maxScale + o.scale
                            );

                            const results = [];

                            // primary sweep
                            for (let a = 0; a <= Math.PI; a += step) {
                                for (let offset of baseOffsets) {
                                    const angle = a + offset;
                                    this.validateOpenAngle(angle, results, preplacedList, nearby);
                                }
                            }

                            // dual sweep
                            if (configs.dualAngleFinder) {
                                for (let i = 0; i < nearby.length; i++) {
                                    const A = nearby[i];
                                    const B = nearby[(i + 1) % nearby.length];
                                    if (!A || !B) continue;

                                    let m = UTILS.getDirection(A, player);
                                    let u = UTILS.getDirection(B, player);
                                    if (m < 0) m += 2 * Math.PI;
                                    if (u < 0) u += 2 * Math.PI;
                                    let mid = (m + u) / 2;
                                    if (Math.abs(m - u) > Math.PI) {
                                        mid += Math.PI;
                                        if (mid > 2 * Math.PI) mid -= 2 * Math.PI;
                                    }
                                    this.validateOpenAngle(mid, results, preplacedList, nearby);
                                }
                            }

                            // sort by priority → brokenDist → enemyDist
                            return results
                                .sort((a, b) => a.enemyDist - b.enemyDist)
                                .sort((a, b) => a.brokenDist - b.brokenDist)
                                .sort((a, b) => b.prioritization - a.prioritization);
                        };
                        this.regCheckPlace = (id, angle) => {
                            const item = items.list[id];
                            if (!item) return;

                            // placement radius
                            const radius = 35 + item.scale + (item.placeOffset || 0);
                            const x      = player.x2 + Math.cos(angle) * radius;
                            const y      = player.y2 + Math.sin(angle) * radius;

                            // if spot is free (using your objectManager → leave other args unchanged)
                            if (objectManager.checkItemLocation(x, y, item.scale, 0.6, id, false)) {
                                this.place(id, angle);
                            }
                        };
                        this.findAngles = function(e = 0) {
                            let step = Math.PI / parseInt(configs.placementDepth||16);
                            let spikeId = player.items[2];
                            let trapItem = items.list[15];
                            let spikeItem = items.list[spikeId];
                            let baseOffsets = [0, Math.PI];
                            let angles = [];

                            // primary sweep
                            for (let o = 0; o <= Math.PI; o += step) {
                                for (let r of baseOffsets) {
                                    this.validateAngle(o + r + e, angles);
                                }
                            }

                            // dual-angle sweep
                            if (configs.dualAngleFinder||true) {
                                let maxScale = Math.max(spikeItem.scale, trapItem.scale);
                                let nearby = _things.liztobj.filter(obj =>
                                                                    obj.active && UTILS.getDistance(obj, player) <= 35 + maxScale + obj.scale
                                                                   );
                                for (let i = 0; i < nearby.length; i++) {
                                    let A = nearby[i];
                                    let B = nearby[(i + 1) % nearby.length];
                                    if (A && B) {
                                        let m = UTILS.getDirection(A, player);
                                        let u = UTILS.getDirection(B, player);
                                        if (m < 0) m += 2 * Math.PI;
                                        if (u < 0) u += 2 * Math.PI;
                                        let mid = (m + u) / 2;
                                        if (Math.abs(m - u) > Math.PI && (mid += Math.PI) > 2 * Math.PI) {
                                            mid -= 2 * Math.PI;
                                        }
                                        this.validateAngle(mid, angles);
                                    }
                                }
                            }

                            // sort by prioritization → brokenDist → enemyDist
                            return angles
                                .sort((a, b) => a.enemyDist - b.enemyDist)
                                .sort((a, b) => a.brokenDist - b.brokenDist)
                                .sort((a, b) => b.prioritization - a.prioritization);
                        };
                        this.validateAngle = (angle, resultsArray) => {
                            const spikeId   = player.items[2];
                            const trapItem  = items.list[15];
                            const spikeItem = items.list[spikeId];

                            // placement radii
                            const spikeRadius = 35 + spikeItem.scale + (spikeItem.placeOffset || 0);
                            const trapRadius  = 35 + trapItem.scale  + (trapItem.placeOffset  || 0);

                            // nearest enemy
                            const nearEnemy = _things.enemy.enemy;

                            // result object template
                            const entry = {
                                angle,
                                trap: false,
                                spike: false,
                                pos: {},
                                prioritization: 0
                            };

                            // test trap position
                            let pos = this.calculatePosition(player, trapRadius, angle);
                            if (
                                objectManager.checkItemLocation(
                                    pos.x,
                                    pos.y,
                                    trapItem.scale,
                                    0.6,
                                    15,
                                    false
                                )
                            ) {
                                entry.trap = true;
                                entry.pos.trap = { ...pos, scale: trapItem.scale };
                            }

                            // test spike position
                            pos = this.calculatePosition(player, spikeRadius, angle);
                            if (
                                objectManager.checkItemLocation(
                                    pos.x,
                                    pos.y,
                                    spikeItem.scale,
                                    0.6,
                                    spikeId,
                                    false
                                )
                            ) {
                                entry.spike = true;
                                entry.prioritization++;
                                entry.pos.spike = { ...pos, dmg: spikeItem.dmg, scale: spikeItem.scale };
                            }

                            // if either is placeable, compute distances and push
                            if (entry.trap || entry.spike) {
                                const targetPos    = entry.pos.spike || entry.pos.trap;
                                const closestBroken = this.brokenObj
                                .slice() // avoid mutating original
                                .sort((a, b) =>
                                      UTILS.getDistance(a, targetPos) - UTILS.getDistance(b, targetPos)
                                     )[0];

                                entry.brokenDist = closestBroken
                                    ? UTILS.getDistance(closestBroken, targetPos)
                                : Infinity;
                                entry.enemyDist  = UTILS.getDistance(nearEnemy, targetPos);

                                if (entry.brokenDist <= entry.enemyDist) {
                                    entry.prioritization++;
                                }

                                resultsArray.push(entry);
                            }
                        };
                        this.diffPlace = (id, angle, tick) => {
                            const item   = items.list[id];
                            const scale  = item.scale;
                            const radius = 35 + scale + (item.placeOffset || 0);

                            // world coords for placement
                            const x = player.x2 + Math.cos(angle) * radius;
                            const y = player.y2 + Math.sin(angle) * radius;

                            // only if no recent marker and within group limits
                            if (
                                this.checkMarkers(x, y, scale, tick) &&
                                item &&
                                (
                                    player.itemCounts[item.group.id] + 1 < (
                                        isSandbox
                                        ? (item.group.sandboxLimit + 1 || 100)
                                        : item.group.limit
                                    )
                                    || !player.itemCounts[item.group.id]
                                )
                            ) {
                                // build the item
                                chicken.selectToBuild(id);
                                chicken.sendHit(1, angle);
                                chicken.selectToBuild(chicken.preferedWeaponIndex, true);

                                // optional aim correction
                                const retDir = chicken.getAttackDir(true);
                                if (
                                    typeof retDir === "number" &&
                                    UTILS.getAngleDist(retDir, angle) >= Math.PI / 8
                                ) {
                                    chicken.sendAim(retDir);
                                }

                                // add a marker for visuals if it’s a trap/spike (id > 2)
                                if (id > 2) {
                                    this.addMarker({
                                        x,
                                        y,
                                        scale,
                                        name: item.name,
                                        angle,
                                        id,
                                        differentVisual: true
                                    });
                                }
                            }
                        };
                        this.autoPlace_ = () => {
                            if (
                                enemy.length &&
                                configs.autoPlace &&
                                !instaC.ticking &&
                                game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value)) || 1) === 0&&secPacket<100
                            ) {
                                const near = _things.enemy.enemy;
                                const dist = UTILS.getDistance(near, player);
                                if (dist > 400) return;

                                const trapData = near.trapData;
                                const angles   = this.findAngles(UTILS.getDirection(near, player));
                                const friends  = _things.liztobj.filter(o =>o.active &&o.trap &&o.isTeamObject(player) &&UTILS.getDistance(o, player) <= 300);

                                for (let a of angles) {
                                    // rebuild broken spike first
                                    if (trapData && a.spike) {
                                        if (UTILS.getDistance(a.pos.spike, trapData) <= 130) {
                                            this.checkPlace(player.items[2], a.angle);
                                        } else if (a.trap) {
                                            this.checkPlace(player.items[4], a.angle);
                                        }
                                    }
                                    // combat fallback
                                    else if (dist <= 200) {
                                        if (a.spike) {
                                            const pos = a.pos.spike;
                                            if (UTILS.getDistance(pos, near) <= 100) {
                                                const sim = kbSimulator.spikeKB(
                                                    { x: near.x2, y: near.y2, scale: 35, tmpObj: near },
                                                    pos,
                                                    true
                                                );
                                                const doPlace = () =>
                                                this.checkPlace(player.items[2], a.angle, () => sim.callback());
                                                if (sim.data.find(x => x.id === "trap")) {
                                                    doPlace();
                                                } else if (
                                                    sim.data.find(x => x.id === "spiek") &&
                                                    sim.data.filter(x => x.id === "spiek").reduce((s, x) => s + x.dmg, 0) + pos.dmg >= 100
                                                ) {
                                                    doPlace();
                                                } else if (a.trap) {
                                                    this.checkPlace(player.items[4], a.angle);
                                                }
                                            } else if (
                                                UTILS.getAngleDist(UTILS.getDirection(near, player), a.angle) <= 0.75 &&
                                                friends.some(o => UTILS.getDistance(pos, o) <= 135)
                                            ) {
                                                this.checkPlace(player.items[2], a.angle);
                                            } else if (a.trap) {
                                                this.checkPlace(player.items[4], a.angle);
                                            }
                                        } else if (a.trap) {
                                            this.checkPlace(player.items[4], a.angle);
                                        }
                                    }
                                    // out-of-range rebuild
                                    else if (a.trap) {
                                        this.checkPlace(player.items[4], a.angle);
                                    }
                                }
                            };
                        };
                        this.checkPlace = (id, angle = 0, callback, enemy) => {
                            const item = items.list[id];
                            if (!item) return;

                            // compute placement coordinates
                            const radius = 35 + item.scale + (item.placeOffset || 0);
                            const x      = player.x2 + Math.cos(angle) * radius;
                            const y      = player.y2 + Math.sin(angle) * radius;

                            // bail if a marker is blocking this spot
                            if (!this.checkMarkers(x, y, item.scale, game.tick)) return;

                            if (enemy) {
                                // count this as a preplacement and use the diff-based build
                                this.preplacements++;
                                this.diffPlace(id, angle, game.tick);
                            } else {
                                // direct placement
                                this.place(id, angle);
                            }

                            // invoke callback if provided
                            if (typeof callback === "function") {
                                callback();
                            }
                        };

                        //raven
                        this.autoPlace = function () {
                            if (enemy.length && configs.autoPlace && !instaC.ticking) {
                                if (game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value))||1) === 0) {
                                    if (gameObjects.length) {
                                        let near2 = {
                                            inTrap: true,
                                        };
                                        let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                        })[0];
                                        if (nearTrap) {
                                            near2.inTrap = true;
                                        } else {
                                            near2.inTrap = true;
                                        }
                                        if (testMode ? enemy.length : (near.dist2 <= 375)) {
                                            if (near.dist2 <= 200) {
                                                this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2, 0, {inTrap: near2.inTrap});
                                            } else {
                                                player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                            }
                                        }
                                    } else {
                                        if (testMode ? enemy.length : (near.dist2 <= 1000)) {
                                            player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                        }
                                    }
                                }
                            }
                        };
                        this.replacer = function (findObj) {
                            if (!findObj || !configs.autoReplace) return;
                            if (!inGame) return;
                            if (this.antiTrapped) return;
                            game.tickBase(() => {
                                let objAim = UTILS.getDirect(findObj, player, 0, 2);
                                let objDst = UTILS.getDist(findObj, player, 0, 2);
                                if (getEl("weaponGrind").checked && objDst <= items.weapons[player.weaponIndex].range + player.scale) return;
                                if (objDst <= 400 && near.dist2 <= 400) {
                                    let danger = this.checkSpikeTick();
                                    if (!danger && near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                        //this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), objAim, 1);
                                        this.testCanPlace(2, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    } else {
                                        player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    }
                                    this.replaced = true;
                                }
                            }, 1);
                        };

                        //divinity
                        this.autoPlace__ = function () {
                            if (enemy.length && configs.autoPlace && !instaC.ticking&&(game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick").value))||1) === 0)) {
                                if (inGame) {
                                    if (gameObjects.length) {
                                        let near2 = {
                                            inTrap: false,
                                        };
                                        let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                        })[0];
                                        if (nearTrap) {
                                            near2.inTrap = true;
                                        } else {
                                            near2.inTrap = false;
                                        }
                                        if ((near.dist2 <= 300)) {
                                            if (near.dist2 <= 150) {
                                                this.testCanPlace(2, 0, Math.PI * 2, Math.PI / 24, near.aim2);
                                            } else {
                                                player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                            }
                                        }
                                    } else {
                                        if ((near.dist2 <= 300)) {
                                            player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                        }
                                    }
                                }
                            }
                            if (secPacket >= 90) return;
                            const spikeRadius = 45;
                            const spikeAngle = Math.PI / 24;
                            if (enemy.length && game.tick % (Math.max(1, parseInt) || 1) === 0) {
                                let near2 = {
                                    inTrap: false,
                                };

                                let nearTrap = gameObjects.find(
                                    (e) =>
                                    e.trap &&
                                    e.active &&
                                    e.isTeamObject(player) &&
                                    UTILS.getDist(e, near, 0, 2) <= near.scale + e.getScale() + 5
                                );
                                near2.inTrap = !!nearTrap;

                                if (
                                    near.dist2 <= 300 &&
                                    ((near.dist2 > 250 && !near2.inTrap))
                                ) {
                                    if (near2.inTrap && near.dist2 <= 250) {
                                        checkPlace(2, near.aim2 + Math.PI);
                                    } else {
                                        player.items[4] == 15 && checkPlace(4, near.aim2);
                                    }
                                } else if (
                                    !near2.inTrap && near.dist2 <= 250) {
                                    let objAim = UTILS.getDirect(near, player, 0, 2);
                                    let trapPlacementRadius = 70;

                                    const enemyVelocity = getEnemyVelocity(near);
                                    const enemyDirection = getEnemyDirection(near);

                                    if (near.dist2 <= 250) {
                                        player.items[4] == 15 &&
                                            this.testCanPlace(
                                            4,
                                            UTILS.deg2rad(-90),
                                            UTILS.deg2rad(90),
                                            Math.PI / 24,
                                            objAim,
                                            trapPlacementRadius, {
                                                inTrap: true,
                                                enemyVelocity,
                                                enemyDirection
                                            }
                                        );
                                    }
                                } else if (near2.inTrap) {
                                    let objAim = UTILS.getDirect(nearTrap, player, 0, 2);
                                    let trapPlacementRadius = 70;

                                    const enemyVelocity = getEnemyVelocity(nearTrap);
                                    const enemyDirection = getEnemyDirection(nearTrap);

                                    if (near.dist2 <= 100) {
                                        let initialAngle = Math.random() * Math.PI * 2;

                                        this.testCanPlace(
                                            2,
                                            initialAngle,
                                            initialAngle + Math.PI * 2,
                                            spikeAngle,
                                            objAim,
                                            spikeRadius, {
                                                inTrap: false,
                                                enemyVelocity,
                                                enemyDirection
                                            }
                                        );
                                    }
                                }
                            }
                        }
                        this.replacer__ = function (findObj) {
                            if (!findObj || !configs.autoReplace) return;
                            if (!inGame) return;
                            if (this.antiTrapped) return;

                            this.angles = this.angles || [];

                            game.tickBase(() => {
                                let objAim = UTILS.getDirect(findObj, player, 0, 2);
                                let objDst = UTILS.getDist(findObj, player, 0, 2);
                                let weaponRange =
                                    items.weapons[player.weaponIndex].range + player.scale;
                                let preAngleAmount = Math.PI / 6;
                                if (
                                    getEl("weaponGrind").checked &&
                                    objDst <= items.weapons[player.weaponIndex].range + player.scale
                                )
                                    return;

                                if (objDst <= 300 && near.dist2 <= 300) {
                                    let danger = this.checkSpikeTick();

                                    let nearWeaponRange = items.weapons[near.primaryIndex || 5].range;

                                    if (
                                        !danger &&
                                        (near.dist2 <= nearWeaponRange ||
                                         (traps.inTrap && objDst <= 150) ||
                                         traps.isEnemyInTrap(near))
                                    ) {
                                        let angleToPlayer = Math.atan2(
                                            player.y - findObj.y,
                                            player.x - findObj.x
                                        );
                                        let distanceToPlayer = UTILS.getDist(findObj, player, 0, 2);
                                        let placementRadius = 80;

                                        let enemyVelocity = Math.sqrt(
                                            near.xVel * near.xVel + near.yVel * near.yVel
                                        );
                                        let enemyDirection = Math.atan2(near.yVel, near.xVel);

                                        let predictedAngle =
                                            angleToPlayer + enemyVelocity * Math.cos(enemyDirection);
                                        let predictedDistance =
                                            distanceToPlayer + enemyVelocity * Math.sin(enemyDirection);

                                        this.angles.push(predictedAngle);

                                        if (this.angles.length > 5) {
                                            this.angles.shift();
                                        }

                                        let smoothedAngle =
                                            this.angles.reduce((a, b) => a + b, 0) / this.angles.length;

                                        smoothedAngle += preAngleAmount;

                                        let timeAdjustment = (Math.PI / 24) * Math.sin(Date.now() / 1000);
                                        let placementAngle = smoothedAngle + timeAdjustment;

                                        this.testCanPlace(
                                            2,
                                            placementAngle,
                                            placementAngle + Math.PI * 2,
                                            Math.PI / 24,
                                            objAim,
                                            placementRadius
                                        );
                                    } else if (player.items[4] === 15 || near.dist2 <= 100) {
                                        let angleToPlayer = Math.atan2(
                                            player.y - findObj.y,
                                            player.x - findObj.x
                                        );
                                        let distanceToPlayer = UTILS.getDist(findObj, player, 0, 2);
                                        let trapPlacementRadius = 70;

                                        let enemyVelocity = Math.sqrt(
                                            near.xVel * near.xVel + near.yVel * near.yVel
                                        );
                                        let enemyDirection = Math.atan2(near.yVel, near.xVel);

                                        let predictedAngle =
                                            angleToPlayer + enemyVelocity * Math.cos(enemyDirection);
                                        let predictedDistance =
                                            distanceToPlayer + enemyVelocity * Math.sin(enemyDirection);

                                        this.angles.push(predictedAngle);

                                        if (this.angles.length > 5) {
                                            this.angles.shift();
                                        }

                                        let smoothedAngle =
                                            this.angles.reduce((a, b) => a + b, 0) / this.angles.length;

                                        smoothedAngle += preAngleAmount;

                                        let trapPlacementAngle = smoothedAngle + Math.PI;

                                        player.items[4] == 15 &&
                                            this.testCanPlace(
                                            4,
                                            trapPlacementAngle,
                                            trapPlacementAngle + Math.PI * 2,
                                            Math.PI / 24,
                                            objAim,
                                            trapPlacementRadius
                                        );
                                    }
                                }

                                let placedSpikes = [];

                                gameObjects.forEach((e) => {
                                    if (e.dmg === true && e.isTeamObj(player)) {
                                        placedSpikes.push(e);
                                    }
                                });

                                if (spikePlaced) {
                                    player.items[4] == 15 &&
                                        this.testCanPlace(4, 0, Math.PI * 2, Math.PI / 24, objAim, 1);
                                    spikePlaced = false;
                                }

                                let knockbackSuccess = false;

                                placedSpikes.forEach((spike) => {
                                    if (UTILS.getDist(spike, player, 0, 2) <= 200) {
                                        let spikeAngle = Math.atan2(
                                            spike.y2 - player.y2,
                                            spike.x2 - player.x2
                                        );
                                        let enemySpikeAngle = Math.atan2(
                                            near.y2 - spike.y2,
                                            near.x2 - spike.x2
                                        );
                                        let nearestAngle = UTILS.nearestAngle(spikeAngle, enemySpikeAngle);

                                        let knockbackDist = 87;

                                        let knockbackPosX =
                                            player.x2 + knockbackDist * Math.cos(nearestAngle);
                                        let knockbackPosY =
                                            player.y2 + knockbackDist * Math.sin(nearestAngle);

                                        let distToKnockbackPos = UTILS.getDist(
                                            near, {
                                                x2: knockbackPosX,
                                                y2: knockbackPosY
                                            },
                                            0,
                                            2
                                        );

                                        if (
                                            UTILS.getDist(findObj, near, 0, 2) <= 87 &&
                                            distToKnockbackPos > 1 + knockbackDist
                                        ) {
                                            place(2, nearestAngle);
                                            knockbackSuccess = true;
                                            textManager.showText(
                                                knockbackPosY,
                                                knockbackPosY,
                                                20,
                                                0.15,
                                                1850,
                                                "knockback",
                                                "#fff",
                                                2
                                            );
                                        }
                                    }
                                });

                                if (!knockbackSuccess) {
                                    if (near.dist2 <= 250 && !spikSync) {
                                        for (let i = 0; i < 24; i++) {
                                            let angle = (Math.PI * 2 * i) / 24;
                                            this.testCanPlace(
                                                2,
                                                angle,
                                                angle + Math.PI / 24,
                                                Math.PI / 24,
                                                objAim,
                                                1
                                            );
                                            spikePlaced = true;
                                            break;
                                        }
                                    }

                                    if (objDst <= 250 && near.dist2 <= 250) {
                                        let danger = this.checkSpikeTick();
                                        if (
                                            !danger &&
                                            near.dist3 <=
                                            items.weapons[near.primaryIndex || 5].range + near.scale * 1.8
                                        ) {
                                            for (let i = 0; i < 24; i++) {
                                                let angle = (Math.PI * 2 * i) / 24;
                                                this.testCanPlace(
                                                    2,
                                                    angle,
                                                    angle + Math.PI / 24,
                                                    Math.PI / 24,
                                                    objAim,
                                                    1
                                                );
                                                this.testCanPlace(
                                                    2,
                                                    Math.PI / 2,
                                                    Math.PI / 2,
                                                    Math.PI / 2,
                                                    near,
                                                    objAim,
                                                    1
                                                );
                                                spikSync = true;
                                                break;
                                            }
                                        } else {
                                            player.items[4] == 15 &&
                                                this.testCanPlace(4, 0, Math.PI * 2, Math.PI / 24, objAim, 1);
                                        }

                                        this.replaced = true;
                                    }
                                }
                            }, 1);
                        }
                        let e=UTILS
                        this.autoPlace_ = function() {
                            if (enemy.length && configs.autoPlace && !instaC.ticking && inGame)
                                if (gameObjects.length) {
                                    let t = {
                                        inTrap: !1
                                    },
                                        a = gameObjects.filter((t => t.trap && t.active && t.isTeamObject(player) && e.getDist(t, near, 0, 2) <= near.scale + t.getScale() + 5)).sort((function(t, a) {
                                            return e.getDist(t, near, 0, 2) - e.getDist(a, near, 0, 2)
                                        }))[0];
                                    t.inTrap = !!a, near.dist2 <= 300 && (near.dist2 <= 150 ? this.testCanPlace(2, 0, 2 * Math.PI, Math.PI / 24, near.aim2) : 15 == player.items[4] && this.testCanPlace(4, 0, 2 * Math.PI, Math.PI / 24, near.aim2))
                                } else near.dist2 <= 300 && 15 == player.items[4] && this.testCanPlace(4, 0, 2 * Math.PI, Math.PI / 24, near.aim2);
                            if (secPacket >= 90) return;
                            const t = Math.PI / 24;
                            if (enemy.length && game.tick % (Math.max(1, parseInt) || 1) == 0) {
                                let a = {
                                    inTrap: !1
                                },
                                    n = gameObjects.find((t => t.trap && t.active && t.isTeamObject(player) && e.getDist(t, near, 0, 2) <= near.scale + t.getScale() + 5));
                                if (a.inTrap = !!n, near.dist2 <= 300 && (near.dist2 > 250 && !a.inTrap)) a.inTrap && near.dist2 <= 250 ? checkPlace(2, near.aim2 + Math.PI) : 15 == player.items[4] && checkPlace(4, near.aim2);
                                else if (!a.inTrap && near.dist2 <= 250) {
                                    let t = e.getDirect(near, player, 0, 2),
                                        a = 70;
                                    const n = i(near),
                                          s = r(near);
                                    near.dist2 <= 250 && 15 == player.items[4] && this.testCanPlace(4, e.deg2rad(-90), e.deg2rad(90), Math.PI / 24, t, a, {
                                        inTrap: !0,
                                        enemyVelocity: n,
                                        enemyDirection: s
                                    })
                                } else if (a.inTrap) {
                                    let a = e.getDirect(n, player, 0, 2);
                                    const s = i(n),
                                          o = r(n);
                                    if (near.dist2 <= 100) {
                                        let e = Math.random() * Math.PI * 2;
                                        this.testCanPlace(2, e, e + 2 * Math.PI, t, a, 45, {
                                            inTrap: !1,
                                            enemyVelocity: s,
                                            enemyDirection: o
                                        })
                                    }
                                }
                            }
                        }
                        this.replacer_ = function(i) {
                            i && configs.autoReplace && inGame && (this.antiTrapped || (this.angles = this.angles || [], game.tickBase((() => {
                                let r = e.getDirect(i, player, 0, 2),
                                    s = e.getDist(i, player, 0, 2),
                                    o = (t.weapons[player.weaponIndex].range, player.scale, Math.PI / 6);
                                if (getEl("weaponGrind").checked && s <= t.weapons[player.weaponIndex].range + player.scale) return;
                                if (s <= 300 && near.dist2 <= 300) {
                                    let a = this.checkSpikeTick(),
                                        n = t.weapons[near.primaryIndex || 5].range;
                                    if (!a && (near.dist2 <= n || traps.inTrap && s <= 150 || traps.isEnemyInTrap(near))) {
                                        let t = Math.atan2(player.y - i.y, player.x - i.x),
                                            a = e.getDist(i, player, 0, 2),
                                            n = 80,
                                            s = Math.sqrt(near.xVel * near.xVel + near.yVel * near.yVel),
                                            l = Math.atan2(near.yVel, near.xVel),
                                            c = t + s * Math.cos(l);
                                        Math.sin(l);
                                        this.angles.push(c), this.angles.length > 5 && this.angles.shift();
                                        let p = this.angles.reduce(((e, t) => e + t), 0) / this.angles.length;
                                        p += o;
                                        let h = p + Math.PI / 24 * Math.sin(Date.now() / 1e3);
                                        this.testCanPlace(2, h, h + 2 * Math.PI, Math.PI / 24, r, n)
                                    } else if (15 === player.items[4] || near.dist2 <= 100) {
                                        let t = Math.atan2(player.y - i.y, player.x - i.x),
                                            a = e.getDist(i, player, 0, 2),
                                            n = 70,
                                            s = Math.sqrt(near.xVel * near.xVel + near.yVel * near.yVel),
                                            l = Math.atan2(near.yVel, near.xVel),
                                            c = t + s * Math.cos(l);
                                        Math.sin(l);
                                        this.angles.push(c), this.angles.length > 5 && this.angles.shift();
                                        let p = this.angles.reduce(((e, t) => e + t), 0) / this.angles.length;
                                        p += o;
                                        let h = p + Math.PI;
                                        15 == player.items[4] && this.testCanPlace(4, h, h + 2 * Math.PI, Math.PI / 24, r, n)
                                    }
                                }
                                let l = [];
                                gameObjects.forEach((e => {
                                    !0 === e.dmg && e.isTeamObj(player) && l.push(e)
                                })), a && (15 == player.items[4] && this.testCanPlace(4, 0, 2 * Math.PI, Math.PI / 24, r, 1), a = !1);
                                let c = !1;
                                if (l.forEach((t => {
                                    if (e.getDist(t, player, 0, 2) <= 200) {
                                        let a = Math.atan2(t.y2 - player.y2, t.x2 - player.x2),
                                            n = Math.atan2(near.y2 - t.y2, near.x2 - t.x2),
                                            r = e.nearestAngle(a, n),
                                            s = 87,
                                            o = player.x2 + s * Math.cos(r),
                                            l = player.y2 + s * Math.sin(r),
                                            p = e.getDist(near, {
                                                x2: o,
                                                y2: l
                                            }, 0, 2);
                                        e.getDist(i, near, 0, 2) <= 87 && p > 1 + s && (place(2, r), c = !0, textManager.showText(l, l, 20, .15, 1850, "knockback", "#fff", 2))
                                    }
                                })), !c) {
                                    if (near.dist2 <= 250 && !n)
                                        for (let e = 0; e < 24; e++) {
                                            let t = 2 * Math.PI * e / 24;
                                            this.testCanPlace(2, t, t + Math.PI / 24, Math.PI / 24, r, 1), a = !0;
                                            break
                                        }
                                    if (s <= 250 && near.dist2 <= 250) {
                                        if (!this.checkSpikeTick() && near.dist3 <= t.weapons[near.primaryIndex || 5].range + 1.8 * near.scale)
                                            for (let e = 0; e < 24; e++) {
                                                let t = 2 * Math.PI * e / 24;
                                                this.testCanPlace(2, t, t + Math.PI / 24, Math.PI / 24, r, 1), this.testCanPlace(2, Math.PI / 2, Math.PI / 2, Math.PI / 2, near, r, 1), n = !0;
                                                break
                                            } else 15 == player.items[4] && this.testCanPlace(4, 0, 2 * Math.PI, Math.PI / 24, r, 1);
                                        this.replaced = !0
                                    }
                                }
                            }), 1)))
                        }
                    }
                };
                var kbSimulator = new class {
                    constructor() {
                        this.animations = [];
                    }
                    addAnimation(e, t) {
                        this.animations.push({
                            dir: e.dir,
                            dirPlus: e.dirPlus,
                            skinIndex: e.skinIndex,
                            pos: {
                                new: t,
                                old: {
                                    x: e.x2,
                                    y: e.y2
                                }
                            },
                            duration: 250,
                            maxDuration: 250,
                            tailIndex: e.tailIndex,
                            weaponIndex: e.weaponIndex,
                            buildIndex: -1,
                            skinColor: e.skinColor,
                            scale: 35,
                            weaponVariant: e.weaponVariant || 0
                        });
                    }
                    spikeKB(e = {
                        x: 0,
                        y: 0,
                        scale: 35
                    }, t = {
                        x: 0,
                        y: 0,
                        scale: 0
                    }, i) {
                        e.vel = {
                            x: 0,
                            y: 0
                        };
                        let s = e.vel;
                        let n = true;
                        let a = game.tickSpeed;
                        let l = false;
                        let o = [];
                        let r = 0;
                        while ((s.x != 0 || s.y != 0) && !isNaN(s.x) && !isNaN(s.y) || !l) {
                            let c = Math.min(4, Math.max(1, Math.round(UTILS.getDistance({
                                x: 0,
                                y: 0
                            }, {
                                x: s.x * a,
                                y: s.y * a
                            }) / 40)));
                            let d = 1 / c;
                            for (let p = 0; p < c; p++) {
                                if (s.x) {
                                    e.x += s.x * a * d;
                                }
                                if (s.y) {
                                    e.y += s.y * a * d;
                                }
                                game.closeObjects.filter(t => t.active && (t.type == 1 && t.y >= 12000 || t.teleport || t.trap || !t.ignoreCollision) && UTILS.getDistance(e, t) <= 35 + (t.getScale ? t.getScale() : t.scale)).forEach(t => {
                                    let i = (t.getScale ? t.getScale() : t.scale) + 35;
                                    let n = UTILS.getDirection(e, t);
                                    e.x = t.x + i * Math.cos(n);
                                    e.y = t.y + i * Math.sin(n);
                                    s.x *= 0.75;
                                    s.y *= 0.75;
                                    if (t.dmg || t.trap) {
                                        let a = players.find(e => e.sid == t.owner.sid);
                                        if (!a || !a.team || a.team != e.tmpObj.team) {
                                            if (t.trap) {
                                                s.x = 0;
                                                s.y = 0;
                                                o.push({
                                                    id: "trap",
                                                    x: t.x,
                                                    y: t.y,
                                                    owner: t.owner.sid
                                                });
                                            } else {
                                                s.x += Math.cos(n) * 1.5;
                                                s.y += Math.sin(n) * 1.5;
                                                o.push({
                                                    id: "spiek",
                                                    dmg: t.dmg
                                                });
                                            }
                                        }
                                    } else if (t.type == 1 && t.y >= 12000) {
                                        s.x += Math.cos(n) * 1.5;
                                        s.y += Math.sin(n) * 1.5;
                                        o.push({
                                            id: "spiek",
                                            dmg: 35
                                        });
                                    } else if (t.teleport) {
                                        o.push({
                                            id: "tp"
                                        });
                                        s.x = 0;
                                        s.y = 0;
                                    }
                                });
                                if (UTILS.getDistance(t, e) <= 35 + t.scale) {
                                    let h = t.scale + 35;
                                    let g = UTILS.getDirection(e, t);
                                    e.x = t.x + h * Math.cos(g);
                                    e.y = t.y + h * Math.sin(g);
                                    s.x *= 0.75;
                                    s.y *= 0.75;
                                    s.x += Math.cos(g) * 1.5;
                                    s.y += Math.sin(g) * 1.5;
                                    if (!n) {
                                        o.push({
                                            id: "spiek",
                                            dmg: t.dmg
                                        });
                                    }
                                    n = false;
                                }
                                players.filter(t => t.visible && UTILS.getDistance(t, e) <= 70).forEach(t => {
                                    let i = UTILS.getDistance(t, e) - 70;
                                    let s = UTILS.getDirection(e, t);
                                    i = i * -1 / 2;
                                    e.x += i * Math.cos(s);
                                    e.y += i * Math.sin(s);
                                });
                            }
                            if (s.x) {
                                s.x *= Math.pow(config.playerDecel, a);
                                if (s.x <= 0.01 && s.x >= -0.01) {
                                    s.x = 0;
                                }
                            }
                            if (s.y) {
                                s.y *= Math.pow(config.playerDecel, a);
                                if (s.y <= 0.01 && s.y >= -0.01) {
                                    s.y = 0;
                                }
                            }
                            l = true;
                            if (++r > 30) {
                                break;
                            }
                        }
                        if (!i) {
                            this.addAnimation(e.tmpObj, e);
                        }
                        return {
                            vel: s,
                            pos: e,
                            data: o,
                            callback: () => {
                                this.addAnimation(e.tmpObj, e);
                            }
                        };
                    }
                    meleeKB(e, t, i, s) {
                        let n = ((items.weapons[i] || {}).knock || 0) + 0.3;
                        n *= game.tickSpeed;
                        if (s) {
                            let a = {
                                x: e.x2,
                                y: e.y2
                            };
                            for (let l = 0; l < s.length; l++) {
                                let o = s[l] * game.tickSpeed;
                                a.x += Math.cos(t) * o;
                                a.y += Math.sin(t) * o;
                            }
                            return a;
                        }
                        return {
                            x: e.x2 + Math.cos(t) * n,
                            y: e.y2 + Math.sin(t) * n
                        };
                    }
                }();
                let isSandbox=config.isSandbox

                class Instakill {
                    constructor() {
                        this.wait = false;
                        this.can = false;
                        this.isTrue = false;
                        this.nobull = false;
                        this.ticking = false;
                        this.canSpikeTick = false;
                        this.startTick = false;
                        this.readyTick = false;
                        this.canCounter = false;
                        this.revTick = false;
                        this.syncHit = true;
                        this.age1insta = false;
                        this.hammerCounterType = function() {
                            this.isTrue = true;
                            my.autoAim = true;
                            if (near.dist2 <= 70 && configs.secondaryOnCounter) {
                                buyEquip(19, 1);
                                selectWeapon(player.weapons[1]);
                                if (player.reloads[53] == 0 && getEl("turretCombat").checked) {
                                    buyEquip(53, 0)
                                    buyEquip(18, 1);
                                } else {
                                    buyEquip(7, 0)
                                    buyEquip(18, 1);
                                }
                                sendAutoGather();
                                game.tickBase(() => {
                                    buyEquip(18, 1);
                                    buyEquip(7, 0)
                                    selectWeapon(player.weapons[0])
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                }, 1);
                            } else {
                                buyEquip(18, 1);
                                selectWeapon(player.weapons[0])
                                buyEquip(7, 0)
                                sendAutoGather()
                                game.tickBase(() => {
                                    if (player.reloads[53] == 0 && getEl("turretCombat").checked) {
                                        buyEquip(53, 0)
                                    }
                                    game.tickBase(() => {
                                        sendAutoGather()
                                        this.isTrue = false
                                        my.autoAim = false
                                    }, 1)
                                }, 1)
                            }
                        };
                        this.hammerInsta=function(rev=true){
                            let maxdmg=(_things.items.weapons[_things.player.primaryIndex].dmg*
                                        config.weaponVariants[_things.player.primaryVariant].val*1.5)+((_things.items.weapons[_things.player.secondaryIndex].dmg*
                                                                                                        config.weaponVariants[_things.player.secondaryVariant].val*1.5))+25
                            if(maxdmg<=100){
                                return "no insta"
                            }
                            chat('hammer time')
                            this.wait=true
                            this.isTrue=true
                            let order=rev?[1,0]:[0,1]
                            selectWeapon(player.weapons[order[0]]);
                            buyEquip(7, 0);
                            sendAutoGather();
                            game.tickBase(() => {
                                selectWeapon(player.weapons[order[1]]);
                                game.tickBase(() => {
                                    buyEquip(player.reloads[53] == 0 ? 53 : 6, 0);
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            }, 1);
                        }
                        //forge
                        this.changeType1 = function(type) {
                            this.wait = false;
                            this.isTrue = true;
                            my.autoAim = true;
                            let instaLog = [type];
                            if (type == "rev") {
                                selectWeapon(player.weapons[1]);
                                buyEquip(53, 0);
                                sendAutoGather();
                                setTimeout(() => {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(7, 0);
                                    setTimeout(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 225);
                                }, 100);
                                return true
                            }
                            else if (type == "nobull") {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                sendAutoGather();
                                setTimeout(() => {
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(player.reloads[53] == 0 ? 53 : 6, 0);
                                    setTimeout(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 255);
                                }, 105);
                                return true
                            }
                            else if (type == "normal") {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                sendAutoGather();
                                setTimeout(() => {
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(player.reloads[53] == 0 ? 53 : 6, 0);
                                    setTimeout(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 170);
                                }, 80);
                                return true
                            }
                            else {
                                return false
                                this.isTrue = false;
                                my.autoAim = false;
                            }
                        };
                        this.changeType = function(type) {
                            if(_random([0,1]))return console.log('Used bonus',this.changeType1(type))
                            this.wait = false;
                            this.isTrue = true;
                            my.autoAim = true;
                            buyEquip(0, 1);
                            let instaLog = [type];
                            let backupNobull = near.backupNobull;
                            near.backupNobull = false;
                            game.tickBase(() => {
                                instaLog.push(player.skinIndex);
                                game.tickBase(() => {
                                    if (near.skinIndex == 22 && getEl("backupNobull").checked) {
                                        near.backupNobull = true;
                                    }
                                    instaLog.push(player.skinIndex);
                                }, 1);
                            }, 1);
                            if (type == "rev") {
                                selectWeapon(player.weapons[1]);
                                buyEquip(53, 0);
                                sendAutoGather();
                                game.tickBase(() => {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(7, 0);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                }, 1);
                            }
                            else if (type == "nobull") {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                sendAutoGather();
                                game.tickBase(() => {
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(player.reloads[53] == 0 ? 53 : 6, 0);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                }, 1);
                            }
                            else if (type == "Normal"||type == "normal") {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                sendAutoGather();
                                game.tickBase(() => {
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(player.reloads[53] == 0 ? 53 : 6, 0);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                }, 1);
                            }
                            else if (type == "oneTickType"){
                                this.oneTickType()
                            }
                            else if (type == "threeOneTickType"){
                                this.threeOneTickType()
                            }
                            else{
                                setTimeout(() => {
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 50);
                            }
                        };
                        this.spikeTickType = function () {
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(21, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                if (player.reloads[53] == 0 && getEl("turretCombat").checked) {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(53, 0);
                                    buyEquip(21, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                } else {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }
                            }, 1);
                        }

                        this.counterType = function () { //now do we really need boost tick is the question ;3
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(18, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                if (player.reloads[53] == 0) {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(53, 0);
                                    buyEquip(21, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                } else {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false; // my godly ass antibull ;3
                                }
                            }, 1);
                        };
                        this.spikeTickType2 = function () {
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(21, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                if (player.reloads[53] == 0 && getEl("turretCombat").checked) {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(53, 0);
                                    buyEquip(21, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                } else {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }
                            }, 1);
                        };
                        this.syncTry = function() {
                            io.send("6", "Pew");
                            if (player.weapons[1] == 15) {
                                this.isTrue = true;
                                my.autoAim = true;
                                game.tickBase(() => {
                                    instaC.isTrue = true;
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(53, 0);
                                    buyEquip(0, 1);
                                    sendAutoGather();
                                    game.tickBase(() => {
                                        my.autoAim = false;
                                        instaC.isTrue = false;
                                        this.isTrue = false;
                                        sendAutoGather();
                                    }, 1);
                                }, 1);
                            }
                        };
                        this.counterType2 = function() {
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(21, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                if (player.reloads[53] == 0 && getEl("turretCombat").checked) {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(53, 0);
                                    buyEquip(21, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                } else {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }
                            }, 1);
                        };
                        this.antiCounterType = function() {
                            my.autoAim = true;
                            this.isTrue = true;
                            inantiantibull = true;
                            selectWeapon(player.weapons[0]);
                            buyEquip(6, 0);
                            buyEquip(21, 1);
                            io.send("D", near.aim2);
                            sendAutoGather();
                            game.tickBase(() => {
                                buyEquip(player.reloads[53] == 0 ? player.skins[53] ? 53 : 6 : 6, 0);
                                buyEquip(21, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                    inantiantibull = false;
                                }, 1);
                            }, 1)
                        };
                        this.rangeType = function(type) {
                            this.isTrue = true;
                            my.autoAim = true;
                            if (type == "ageInsta") {
                                my.ageInsta = false;
                                if (player.items[5] == 18) {
                                    place(5, near.aim2);
                                }
                                packet("9", undefined, 1);
                                buyEquip(22, 0);
                                buyEquip(21, 1);
                                game.tickBase(() => {
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(53, 0);
                                    buyEquip(21, 1);
                                    sendAutoGather();
                                    game.tickBase(() => {
                                        sendUpgrade(12);
                                        selectWeapon(player.weapons[1]);
                                        buyEquip(53, 0);
                                        buyEquip(21, 1);
                                        game.tickBase(() => {
                                            sendUpgrade(15);
                                            selectWeapon(player.weapons[1]);
                                            buyEquip(53, 0);
                                            buyEquip(21, 1);
                                            game.tickBase(() => {
                                                sendAutoGather();
                                                this.isTrue = false;
                                                my.autoAim = false;
                                            }, 1);
                                        }, 1);
                                    }, 1);
                                }, 1);
                            }
                            else {
                                selectWeapon(player.weapons[1]);
                                if (player.reloads[53] == 0 && near.dist2 <= 700 && near.skinIndex != 22) {
                                    buyEquip(53, 0);
                                } else {
                                    buyEquip(20, 0);
                                }
                                buyEquip(11, 1);
                                sendAutoGather();
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            }
                        };
                        this.oneTickType = function() {
                            io.send("6", "P_OT Start")
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(11, 1);
                            packet("9", near.aim2, 1);
                            if (player.weapons[1] == 15) {
                                my.revAim = true;
                                sendAutoGather();
                            }
                            game.tickBase(() => {
                                const trap1 = gameObjects
                                .filter((e) => e.trap && e.active)
                                .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                .find((trap) => {
                                    const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                    return (
                                        trap !== player &&
                                        (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                        trapDist <= 30
                                    );
                                });
                                if ([6, 22].includes(near.skinIndex) && trap1) io.send('6', 'p_OT [2/3]');
                                my.revAim = false;
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                buyEquip(19, 1);
                                packet("9", near.aim2, 1);
                                if (player.weapons[1] != 15) {
                                    sendAutoGather();
                                }
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                    packet("9", undefined, 1);
                                }, 1);
                            }, 1);
                        };
                        this.threeOneTickType = function() {
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                            biomeGear();
                            buyEquip(11, 1);
                            packet("9", near.aim2, 1);
                            game.tickBase(() => {
                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                buyEquip(53, 0);
                                buyEquip(11, 1);
                                packet("9", near.aim2, 1);
                                game.tickBase(() => {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(7, 0);
                                    buyEquip(19, 1);
                                    sendAutoGather();
                                    packet("9", near.aim2, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                        packet("9", undefined, 1);
                                    }, 1);
                                }, 1);
                            }, 1);
                        };
                        this.kmTickType = function() {
                            this.isTrue = true;
                            my.autoAim = true;
                            my.revAim = true;
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(11, 1);
                            sendAutoGather();
                            packet("9", near.aim2, 1);
                            game.tickBase(() => {
                                my.revAim = false;
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                buyEquip(19, 1);
                                packet("9", near.aim2, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                    packet("9", undefined, 1);
                                }, 1);
                            }, 1);
                        };
                        this.boostTickType = function() {
                            /*this.isTrue = true;
            my.autoAim = true;
            selectWeapon(player.weapons[0]);
            buyEquip(53, 0);
            buyEquip(11, 1);
            packet("33", near.aim2);
            game.tickBase(() => {
                place(4, near.aim2);
                selectWeapon(player.weapons[1]);
                biomeGear();
                buyEquip(11, 1);
                sendAutoGather();
                packet("33", near.aim2);
                game.tickBase(() => {
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    buyEquip(19, 1);
                    packet("33", near.aim2);
                    game.tickBase(() => {
                        sendAutoGather();
                        this.isTrue = false;
                        my.autoAim = false;
                        packet("33", undefined);
                    }, 1);
                }, 1);
            }, 1);*/
                            this.isTrue = true;
                            my.autoAim = true;
                            biomeGear();
                            buyEquip(11, 1);
                            packet("9", near.aim2, 1);
                            game.tickBase(() => {
                                if (player.weapons[1] == 15) {
                                    my.revAim = true;
                                }
                                selectWeapon(player.weapons[[9, 12, 13, 15].includes(player.weapons[1]) ? 1 : 0]);
                                buyEquip(53, 0);
                                buyEquip(11, 1);
                                if ([9, 12, 13, 15].includes(player.weapons[1])) {
                                    sendAutoGather();
                                }
                                packet("9", near.aim2, 1);
                                place(4, near.aim2);
                                game.tickBase(() => {
                                    my.revAim = false;
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(7, 0);
                                    buyEquip(19, 1);
                                    if (![9, 12, 13, 15].includes(player.weapons[1])) {
                                        sendAutoGather();
                                    }
                                    packet("9", near.aim2, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                        packet("9", undefined, 1);
                                    }, 1);
                                }, 1);
                            }, 1);
                        };
                        this.gotoGoal = function(goto, OT) {
                            let slowDists = (weeeee) => weeeee * config.playerScale;
                            let goal = {
                                a: goto - OT,
                                b: goto + OT,
                                c: goto - slowDists(1),
                                d: goto + slowDists(1),
                                e: goto - slowDists(2),
                                f: goto + slowDists(2),
                                g: goto - slowDists(4),
                                h: goto + slowDists(4)
                            };
                            let bQ = function(wwww, awwww) {
                                if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2 && awwww == 0) {
                                    buyEquip(31, 0);
                                } else {
                                    buyEquip(wwww, awwww);
                                }
                            }
                            if (enemy.length) {
                                let dst = near.dist2;
                                this.ticking = true;
                                if (dst >= goal.a && dst <= goal.b) {
                                    bQ(22, 0);
                                    bQ(11, 1);
                                    if (player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0] || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                    }
                                    return {
                                        dir: undefined,
                                        action: 1
                                    };
                                } else {
                                    if (dst < goal.a) {
                                        if (dst >= goal.g) {
                                            if (dst >= goal.e) {
                                                if (dst >= goal.c) {
                                                    bQ(40, 0);
                                                    bQ(10, 1);
                                                    if (configs.slowOT) {
                                                        player.buildIndex != player.items[1] && selectToBuild(player.items[1]);
                                                    } else {
                                                        if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                        }
                                                    }
                                                } else {
                                                    bQ(22, 0);
                                                    bQ(19, 1);
                                                    if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                    }
                                                }
                                            } else {
                                                bQ(6, 0);
                                                bQ(12, 1);
                                                if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                }
                                            }
                                        } else {
                                            biomeGear();
                                            bQ(11, 1);
                                            if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                            }
                                        }
                                        return {
                                            dir: near.aim2 + Math.PI,
                                            action: 0
                                        };
                                    } else if (dst > goal.b) {
                                        if (dst <= goal.h) {
                                            if (dst <= goal.f) {
                                                if (dst <= goal.d) {
                                                    bQ(40, 0);
                                                    bQ(9, 1);
                                                    if (configs.slowOT) {
                                                        player.buildIndex != player.items[1] && selectToBuild(player.items[1]);
                                                    } else {
                                                        if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                        }
                                                    }
                                                } else {
                                                    bQ(22, 0);
                                                    bQ(19, 1);
                                                    if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                    }
                                                }
                                            } else {
                                                bQ(6, 0);
                                                bQ(12, 1);
                                                if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                }
                                            }
                                        } else {
                                            biomeGear();
                                            bQ(11, 1);
                                            if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                            }
                                        }
                                        return {
                                            dir: near.aim2,
                                            action: 0
                                        };
                                    }
                                    return {
                                        dir: undefined,
                                        action: 0
                                    };
                                }
                            } else {
                                this.ticking = false;
                                return {
                                    dir: undefined,
                                    action: 0
                                };
                            }
                        }
                        this.spammer = function () {
                            if(antiBullType.value!="noab")return;
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(19, 1)
                            sendAutoGather();
                            game.tickBase(() => {
                                sendAutoGather();
                                this.isTrue = false;
                                my.autoAim = false;
                            }, 1);
                        };
                        this.bowMovement = function() {
                            let moveMent = this.gotoGoal(685, 3);
                            if (moveMent.action) {
                                if (player.reloads[53] == 0 && !this.isTrue) {
                                    this.rangeType("ageInsta");
                                } else {
                                    packet("9", moveMent.dir, 1);
                                }
                            } else {
                                packet("9", moveMent.dir, 1);
                            }
                        }
                        this.testMovement = function () {
                            let move1 = this.gotoGoal(1440, 3);
                            if(move1.action) {
                                io.send("6", "test complete")
                            } else {
                                packet("9", Number.MAX_VALUE)
                            }
                        }
                        this.tickMovement = function() {
                            const trap1 = gameObjects
                            .filter((e) => e.trap && e.active)
                            .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                            .find((trap) => {
                                const trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                return (
                                    trap !== player &&
                                    (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                                    trapDist <= 50
                                );
                            });
                            let moveMent = this.gotoGoal(([10, 14].includes(player.weapons[1]) && player.y2 > config.snowBiomeTop) ? 240 : player.weapons[1] == 15 ? 250 : player.y2 <= config.snowBiomeTop ? [10, 14].includes(player.weapons[1]) ? 270 : 265 : 275, 3);
                            if (moveMent.action) {
                                if ((![6, 22].includes(near.skinIndex) || [6, 22].includes(near.skinIndex) && trap1) && player.reloads[53] == 0 && !this.isTrue) {
                                    ([10, 14].includes(player.weapons[1]) && player.y2 > config.snowBiomeTop) || (player.weapons[1] == 15) ? this.oneTickType() : this.threeOneTickType();
                                    if ([6, 22].includes(near.skinIndex) && trap1) io.send('6', 'p_OT [1/3]');
                                } else {
                                    packet("9", moveMent.dir, 1);
                                }
                            } else {
                                packet("9", moveMent.dir, 1);
                            }
                        }
                        this.kmTickMovement = function() {
                            let moveMent = this.gotoGoal(240, 3);
                            if (moveMent.action) {
                                if (near.skinIndex != 22 && player.reloads[53] == 0 && !this.isTrue && ((game.tick - near.poisonTick) % config.serverUpdateRate == 8)) {
                                    this.kmTickType();
                                } else {
                                    packet("9", moveMent.dir, 1);
                                }
                            } else {
                                packet("9", moveMent.dir, 1);
                            }
                        }
                        this.boostTickMovement = function() {
                            let dist = player.weapons[1] == 9 ? 365 : player.weapons[1] == 12 ? 380 : player.weapons[1] == 13 ? 390 : player.weapons[1] == 15 ? 365 : 370;
                            let actionDist = player.weapons[1] == 9 ? 2 : player.weapons[1] == 12 ? 1.5 : player.weapons[1] == 13 ? 1.5 : player.weapons[1] == 15 ? 2 : 3;
                            let moveMent = this.gotoGoal(dist, actionDist);
                            if (moveMent.action) {
                                if (player.reloads[53] == 0 && !this.isTrue) {
                                    this.boostTickType();
                                } else {
                                    packet("9", moveMent.dir, 1);
                                }
                            } else {
                                packet("9", moveMent.dir, 1);
                            }
                        }

                        this.perfCheck = function(pl, nr) {
                            if (nr.weaponIndex == 11 && UTILS.getAngleDist(nr.aim2 + Math.PI, nr.d2) <= config.shieldAngle) return false;
                            if (![9, 12, 13, 15].includes(player.weapons[1])) return true;
                            let pjs = {
                                x: nr.x2 + (70 * Math.cos(nr.aim2 + Math.PI)),
                                y: nr.y2 + (70 * Math.sin(nr.aim2 + Math.PI))
                            };
                            if (UTILS.lineInRect(pl.x2 - pl.scale, pl.y2 - pl.scale, pl.x2 + pl.scale, pl.y2 + pl.scale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                                return true;
                            }
                            let finds = ais.filter(tmp => tmp.visible).find((tmp) => {
                                if (UTILS.lineInRect(tmp.x2 - tmp.scale, tmp.y2 - tmp.scale, tmp.x2 + tmp.scale, tmp.y2 + tmp.scale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                                    return true;
                                }
                            });
                            if (finds) return false;
                            finds = gameObjects.filter(tmp => tmp.active).find((tmp) => {
                                let tmpScale = tmp.getScale();
                                if (!tmp.ignoreCollision && UTILS.lineInRect(tmp.x - tmpScale, tmp.y - tmpScale, tmp.x + tmpScale, tmp.y + tmpScale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                                    return true;
                                }
                            });
                            if (finds) return false;
                            return true;
                        }
                        this.assistInsta=function(gobj,_40=player.skins[40]){
                            if(_things.player.weapons[1]!=10)return 'bozo'
                            let mBdmg=_things.items.weapons[10].dmg*config.weaponVariants[_things.player.secondaryVariant].val*(_things.items.weapons[10].sDmg)*(_40?3.3:1)
                            if(isnerf||gobj.health>mBdmg)return 'bozo\'js'
                            chat('Get assisted')
                            this.wait = false;
                            this.isTrue = true;
                            my.autoAim = true;
                            buyEquip(40, 0);
                            selectWeapon(_things.player.weapons[1]);
                            sendAutoGather();
                            game.tickBase(() => {
                                //this.wait = false;
                                _things.buyEquip(7,0);
                                _things.selectWeapon(_things.player.weapons[0]);
                                checkPlace(2, near.aim2)
                                game.tickBase(()=>{
                                    game.tickBase(()=>{
                                        _things.sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    },1)
                                },1)
                            },1)
                        }
                        function predictAim(enemy, projectileSpeed) {
                            const { x, y, moveDir, speed = 0, xVel = 0, yVel = 0 } = enemy;
                            const px = _things.player.x;
                            const py = _things.player.y;

                            // Direction fallback
                            let vx, vy;
                            if (typeof moveDir === "number") {
                                vx = Math.cos(moveDir) * speed;
                                vy = Math.sin(moveDir) * speed;
                            } else {
                                vx = xVel;
                                vy = yVel;
                            }

                            // Relative position
                            const relX = x - px;
                            const relY = y - py;

                            // Quadratic coefficients
                            const a = vx * vx + vy * vy - projectileSpeed * projectileSpeed;
                            const b = 2 * (relX * vx + relY * vy);
                            const c = relX * relX + relY * relY;

                            const disc = b * b - 4 * a * c;
                            let t;

                            if (disc >= 0 && Math.abs(a) > 1e-6) {
                                const sqrtDisc = Math.sqrt(disc);
                                const t1 = (-b - sqrtDisc) / (2 * a);
                                const t2 = (-b + sqrtDisc) / (2 * a);
                                t = Math.min(t1, t2) > 0 ? Math.min(t1, t2) : Math.max(t1, t2);
                            } else {
                                // No valid intercept time, fall back to direct aim
                                t = Math.hypot(relX, relY) / projectileSpeed;
                            }

                            const aimX = x + vx * t;
                            const aimY = y + vy * t;

                            return { x: aimX, y: aimY };
                        }
                        this.rangeFrame = function(swingBull,m,added){
                            if(isnerf)return 'bozo'
                            this.wait = false;
                            this.isTrue = true;
                            const o = (function(player = _things.player, target = _things.enemy.enemy){
                                const sx = player.x, sy = player.y;
                                const dx = target.x - sx, dy = target.y - sy;
                                const dist = Math.hypot(dx, dy);

                                // find sec weapon & proj, if none treat as missing
                                const secWep = weapons.find(w => w.id === player.secondaryIndex);
                                const hasRange = secWep && secWep.projectile != null && _things.items.projectiles[secWep.projectile];
                                const projR = hasRange
                                ? _things.items.projectiles[secWep.projectile]
                                : null;
                                const projT = _things.items.projectiles[1]; // turret proj

                                // time to hit (ticks)
                                const ticksR = hasRange ? dist / projR.speed : pingTime;
                                let ticksT;
                                if (swingBull) {
                                    // collision happens when centers are (player.scale + turretRadius) apart
                                    const collisionDist = player.scale + 20;
                                    const travelDist = Math.max(dist - collisionDist, 0);
                                    ticksT = travelDist / projT.speed;
                                } else {
                                    ticksT = dist / projT.speed;
                                }
                                const faster = swingBull?"range":ticksR < ticksT ? 'range' : 'turret';
                                const timeout = Math.abs(ticksR - ticksT)// * (m||1)+(added||0); // adjust multiplier if needed

                                return { ticksR, ticksT, faster, timeout, hasRange,pSpeed:hasRange?projR.speed:0};
                            })();
                            const canSwing = swingBull || o.faster === 'range';
                            //shoot turret first
                            let xA=3
                            function gxA(){
                                let _=['x','y'].map(e=>e+xA.toString())
                                let [x,y]=_.map(xy=>_things.enemy.enemy[xy])
                                return {x,y}
                            }
                            console.log(o,canSwing)
                            if (o.faster === 'range'||swingBull) {
                                console.log(1,'Turret')
                                _things.buyEquip(53, 0);
                            }else{
                                console.log(1,'Ranged')
                                _things.aimAt(gxA());
                                _things.selectWeapon(_things.player.weapons[1]);
                                _things.sendAutoGather();
                            }
                            setTimeout(()=>{
                                if(swingBull&&canSwing){
                                    if(swingBull){
                                        console.log(2,'Swing')
                                        // 3️⃣ Now equip hat-7 (primary) and swing
                                        _things.buyEquip(7, 0);
                                        _things.selectWeapon(_things.player.weapons[0])
                                        _things.sendAutoGather();
                                    }
                                }
                                else if (o.faster === 'range') {
                                    console.log(2,'ranged')
                                    _things.aimAt(gxA());
                                    _things.selectWeapon(_things.player.weapons[1]);
                                    _things.sendAutoGather();
                                }else{
                                    console.log(2,'turret')
                                    _things.buyEquip(53, 0);
                                }
                            },o.timeout)

                            setTimeout(()=>{
                                console.log(3,'off')
                                _things.sendAutoGather();
                                _things.autoAim = 0;
                                this.isTrue = false;
                            },o.timeout+300)
                            return;
                        }
                        this.rangeFrameWorking = function(swingBull){
                            if(isnerf)return 'bozo'
                            this.wait = false;
                            this.isTrue = true;
                            my.autoAim = true;
                            let o=(function(player=_things.player,targetPos=_things.enemy.enemy){
                                const sx = player.x, sy = player.y;
                                const dx = targetPos.x - sx, dy = targetPos.y - sy;
                                const dist = Math.hypot(dx, dy);
                                const wep   = weapons.find(w => w.id === player.secondaryIndex);
                                const projR = _things.items.projectiles[wep.projectile];
                                const projT = _things.items.projectiles[1];

                                const ticksR = dist / projR.speed;
                                const ticksT = dist / projT.speed;
                                const faster = ticksR < ticksT ? 'range' : 'turret';
                                let timout=Math.abs(ticksR-ticksT)
                                return {ticksR,ticksT,faster,timout}
                            })()
                            let canSwing=false
                            //shoot turret first
                            if (o.faster === 'range') {
                                canSwing=true
                                _things.buyEquip(53, 0);
                            }else{
                                _things.selectWeapon(_things.player.weapons[1]);
                                _things.sendAutoGather();
                            }
                            setTimeout(()=>{
                                if(swingBull&&canSwing){
                                    if(swingBull){
                                        // 3️⃣ Now equip hat-7 (primary) and swing
                                        _things.buyEquip(7, 0);
                                        _things.selectWeapon(_things.player.weapons[0])
                                    }
                                }
                                else if (o.faster === 'range') {
                                    _things.selectWeapon(_things.player.weapons[1]);
                                    _things.sendAutoGather();
                                }else{
                                    _things.buyEquip(53, 0);
                                }
                            },o.timout)

                            setTimeout(()=>{
                                _things.sendAutoGather();
                                _things.autoAim = 0;
                                this.isTrue = false;
                            },o.timout+300)
                            return;
                        }
                        this.rangeFrame2 = function(swingBull){
                            if (isnerf) return 'bozo';
                            this.wait = false;
                            this.isTrue = true;
                            my.autoAim = true;

                            // calc timings, handle missing ranged secondary
                            const o = (function(player = _things.player, target = _things.enemy.enemy){
                                const sx = player.x, sy = player.y;
                                const dx = target.x - sx, dy = target.y - sy;
                                const dist = Math.hypot(dx, dy);

                                // find sec weapon & proj, if none treat as missing
                                const secWep = weapons.find(w => w.id === player.secondaryIndex);
                                const hasRange = secWep && secWep.projectile != null && _things.items.projectiles[secWep.projectile];
                                const projR = hasRange
                                ? _things.items.projectiles[secWep.projectile]
                                : null;
                                const projT = _things.items.projectiles[1]; // turret proj

                                // time to hit (ticks)
                                const ticksR = hasRange ? dist / projR.speed : Infinity;
                                const ticksT = dist / projT.speed;
                                const faster = ticksR < ticksT ? 'range' : 'turret';
                                const timeout = Math.abs(ticksR - ticksT) * 100; // adjust multiplier if needed

                                return { ticksR, ticksT, faster, timeout, hasRange };
                            })();
                            // allow hat swing if we wanna swing bull or if range is faster
                            const canSwing = swingBull || o.faster === 'range';

                            // fire the slower one first to sync hits
                            if (o.faster === 'range' && o.hasRange) {
                                _things.buyEquip(53, 0); // turret first
                            } else {
                                _things.selectWeapon(_things.player.weapons[1]); // range (or turret if no range)
                                _things.sendAutoGather();
                            }

                            // after sync delay
                            setTimeout(() => {
                                if (swingBull && canSwing) {
                                    // swing hat-7
                                    _things.buyEquip(7, 0);
                                    _things.selectWeapon(_things.player.weapons[0]);
                                    _things.sendAutoGather();
                                } else if (o.faster === 'range') {
                                    // if we chose range-first path
                                    _things.selectWeapon(_things.player.weapons[1]);
                                    _things.sendAutoGather();
                                } else {
                                    // fallback turret equip/shoot
                                    _things.buyEquip(53, 0);
                                    //_things.sendAutoGather();
                                }
                            }, o.timeout);

                            // cleanup autoAim
                            setTimeout(() => {
                                _things.autoAim = 0;
                                this.isTrue = false;
                            }, o.timeout + 300);

                            return;
                        };

                    }
                };
                class AutobuyW {
                    constructor(buyHat, buyAcc) {
                        this.hat = function() {
                            buyHat.forEach((id) => {
                                let find = findID(hats, id);
                                if (find && !player.skins[id] && player.points >= find.price) packet("c", 1, id, 0);
                            });
                        };
                        this.acc = function() {
                            buyAcc.forEach((id) => {
                                let find = findID(accessories, id);
                                if (find && !player.tails[id] && player.points >= find.price) packet("c", 1, id, 1);
                            });
                        };
                    }
                };
                class Autobuy {
                    constructor(buyHat, buyAcc) {
                        this.buyHatOrder = buyHat;
                        this.buyAccOrder = buyAcc;
                        // One method for each, checks sequentially
                        this.hat = function() {
                            for (let i = 0; i < this.buyHatOrder.length; i++) {
                                let id = this.buyHatOrder[i];
                                let find = findID(hats, id);
                                if (find && !player.skins[id] && player.points >= find.price) {
                                    packet("c", 1, id, 0);
                                    break; // Only buy one per tick, in order!
                                }
                            }
                        };
                        this.acc = function() {
                            for (let i = 0; i < this.buyAccOrder.length; i++) {
                                let id = this.buyAccOrder[i];
                                let find = findID(accessories, id);
                                if (find && !player.tails[id] && player.points >= find.price) {
                                    packet("c", 1, id, 1);
                                    break; // Only buy one per tick, in order!
                                }
                            }
                        };
                    }
                }
                class Autoupgrade {
                    constructor() {
                        this.sb = function(upg) {
                            upg(3);
                            upg(17);
                            upg(31);
                            upg(23);
                            upg(9);
                            upg(38);
                        };
                        this.kh = function(upg) {
                            upg(3);
                            upg(17);
                            upg(31);
                            upg(23);
                            upg(10);
                            upg(38);
                            upg(4);
                            upg(25);
                        };
                        this.pb = function(upg) {
                            upg(5);
                            upg(17);
                            upg(32);
                            upg(23);
                            upg(9);
                            upg(38);
                        };
                        this.ph = function(upg) {
                            upg(5);
                            upg(17);
                            upg(32);
                            upg(23);
                            upg(10);
                            upg(38);
                            upg(28);
                            upg(25);
                        };
                        this.db = function(upg) {
                            upg(7);
                            upg(17);
                            upg(31);
                            upg(23);
                            upg(9);
                            upg(34);
                        };
                        /* old functions */
                        this.km = function(upg) {
                            upg(7);
                            upg(17);
                            upg(31);
                            upg(23);
                            upg(10);
                            upg(38);
                            upg(4);
                            upg(15);
                        };
                    };
                };

                class Damages {
                    constructor(items) {
                        // 0.75 1 1.125 1.5
                        this.calcDmg = function(dmg, val) {
                            return dmg * val;
                        };
                        this.getAllDamage = function(dmg) {
                            return [this.calcDmg(dmg, 0.75), dmg, this.calcDmg(dmg, 1.125), this.calcDmg(dmg, 1.5)];
                        };
                        this.weapons = [];
                        for (let i = 0; i < items.weapons.length; i++) {
                            let wp = items.weapons[i];
                            let name = wp.name.split(" ").length <= 1 ? wp.name : (wp.name.split(" ")[0] + "_" + wp.name.split(" ")[1]);
                            this.weapons.push(this.getAllDamage(i > 8 ? wp.Pdmg : wp.dmg));
                            this[name] = this.weapons[i];
                        }
                    }
                }

                /** CLASS CODES */
                // jumpscare code warn
                let tmpList = [];
                let nearspiker = false;
                // LOADING:
                let UTILS = new Utils();
                let items = new Items();
                let objectManager = new Objectmanager(GameObject, gameObjects, UTILS, config);
                let store = new Store();
                let hats = store.hats;
                let accessories = store.accessories;
                let projectileManager = new ProjectileManager(Projectile, projectiles, players, ais, objectManager, items, config, UTILS);
                let aiManager = new AiManager(ais, AI, players, items, null, config, UTILS);
                let textManager = new Textmanager();

                let traps = new Traps(UTILS, items);
                let instaC = new Instakill();
                let autoBuy = new Autobuy([15, 31, 6, 7,40, 22, 12, 53, 11, 26], [11, 13, 19, 18, 21]);
                let autoUpgrade = new Autoupgrade();

                let lastDeath;
                let minimapData;
                let mapMarker = {};
                let mapPings = [];
                let tmpPing;

                let breakTrackers = [];

                let pathFindTest = 0;
                let grid = [];
                let pathFind = {
                    active: false,
                    grid: 70,
                    scale: 1440,
                    x: 14400,
                    y: 14400,
                    chaseNear: false,
                    array: [],
                    lastX: this.grid / 2,
                    lastY: this.grid / 2
                };

                //const rangedWeapons = unsafeWindow.weapons.filter(weapon => weapon.projectile !== undefined);
                function hasRangedWeapon(equippedWeapons) {
                    return equippedWeapons.some(weaponId =>
                                                rangedWeapons.some(rangedWeapon => rangedWeapon.id === weaponId)
                                               );
                }

                function isAIInRange(player, ai) {
                    const playerWeapons = player.weapons; // [primaryWeaponId, secondaryWeaponId]
                    const primaryWeapon = weapons.find(w => w.id === playerWeapons[0]);
                    const secondaryWeapon = weapons.find(w => w.id === playerWeapons[1]);

                    // Calculate distance between player and AI
                    const distanceToAI = getDistance(player.x, player.y, ai.x, ai.y);

                    // Check if AI is within range of either weapon
                    const isInPrimaryRange = distanceToAI <= (primaryWeapon.range + 100);
                    const isInSecondaryRange = secondaryWeapon && (distanceToAI <= secondaryWeapon.range) || false;

                    return isInPrimaryRange || isInSecondaryRange;
                }

                function getDirection(player, target) {
                    // Calculate the difference in x and y coordinates
                    const dx = target.x - player.x;
                    const dy = target.y - player.y;

                    // Calculate the angle in radians
                    const angleRad = Math.atan2(dy, dx);

                    // Ensure the angle is in the range [0, 2*PI)
                    const direction = (angleRad + 2 * Math.PI) % (2 * Math.PI);

                    return direction;
                }

                async function waitTill() {
                    while (my.autoPush || traps.inTrap) await sleep(0);
                }
                playerRadius=45
                _things = {
                    get dist() {
                        return function(a, b, o = "", c = "") {
                            let _ = ['x', 'y'].map(e => e + o.toString());
                            let [x, y] = _.map(xy => a[xy]);
                            let p1 = { x, y };

                            _ = ['x', 'y'].map(e => e + c.toString());
                            [x, y] = _.map(xy => b[xy]);
                            let p2 = { x, y };
                            let d=getDistance(p1.x, p1.y, p2.x, p2.y);
                            //console.log({d,a,b,o,c})
                            return d // ✅ fixed here
                        };
                    },
                    canHit_(useP){
                        try{
                            var usedID =
                                useP&&player.weapons[0]!=8
                            ? player.weapons[0]
                            : _things.player.weaponIndex === 10
                            ? 10
                            : _things.player.weapons[1] === 10
                            ? 10
                            : _things.player.weapons[0];
                            let i = _things.closeItem;
                            let p = _things.player;
                            let w = weapons.find(e => e.id == usedID);

                            let canHit = (w.range - (w.xeOff||0)) >= (i.dist - i.item.getScale());
                            return {canHit,usedID}
                        }catch{return {canHit:0,usedID:0}}
                    },
                    get closeItem(){
                        let item= [..._things.liztobj]
                        .filter(e => e.x&&e.y&&e.active&&e.ignoreCollision !== true&&e.group?e.group.name!='spikes':false)
                        .sort((a, b) => {
                            const distFn = _things.dist; // assuming inside same class
                            const player = _things.player;
                            return distFn(player, a) - distFn(player, b); // sort by closest to player
                        })[0]
                        return {item,dist:this.dist(player,item)}
                    },
                    get objectManager(){return objectManager},
                    get ws(){return WS},
                    get instaC(){return instaC},
                    get autoAim(){return my.autoAim},
                    set autoAim(a){return my.autoAim=a},
                    get selectWeapon(){return selectWeapon},
                    get sendAutoGather(){return sendAutoGather},
                    get buyEquip(){return buyEquip},
                    get tickBase(){return game.tickBase},
                    get items(){return items},
                    get checkPlace(){return checkPlace},
                    quad(id){
                        for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                            checkPlace(id, i);
                        }
                    },
                    get configs(){return configs},
                    aimAt(t){
                        let d=getDirection(player,t)
                        _things.player.dir!=d&&(packet("D",getDirection(player,t)))
                    },
                    get traps(){return traps},
                    get players(){return players},
                    get liztobj() { return liztobj },
                    get traps() { return traps },
                    get gameObjects() { return gameObjects },
                    get selectWeapon() { return selectWeapon },
                    get my() {
                        return my
                    },
                    packet(...a) {
                        if(a[0]==_things.moveKey)(toMove=a,lastMoveDir=a[1]);
                        else packet(...a)
                    },
                    get closeAI() {
                        let rai=ais.filter(e=>e.visible)
                        if (!rai.length) return;
                        let ai = findClosestList(player.x, player.y, rai, weapons)
                        const aiInRange = isAIInRange(player, ai, weapons);
                        return { ai, aiInRange, targetDir: getDirection(player, ai) }
                    },
                    get player() {
                        return player
                    },
                    get findClosestList(){return findClosestList},
                    get enemy() {
                        return {
                            enemy: findClosestList(player.x, player.y, enemy),
                            get targetDir() {
                                try{
                                    return getDirection(player, this.enemy)
                                }catch{
                                    return null
                                }
                            }
                        }
                    },
                    get enemy_() {
                        return enemy
                    },
                    atkKey:'F',
                    moveKey:"9"
                }

                function random(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

                function moveInDirection(player, direction, offset) {
                    // Calculate the new position
                    const dx = Math.cos(direction) * offset;
                    const dy = Math.sin(direction) * offset;

                    // Update the player's position
                    player.x += dx;
                    player.y += dy;

                    console.log(`Player moved to: (${player.x}, ${player.y})`);
                }
                adjPercent=1
                worldScale = 1.5; //1.6 fullscreen
                //let squareSize = 25; // You can change this value to resize squares
                const overlayCanvas = new element('canvas')
                .style({
                    position: 'absolute',
                    top: '0',
                    left: '0',
                    width: '100vw',
                    height: '100vh',
                    zIndex: '10',
                    pointerEvents: 'none'
                });

                const ctx = overlayCanvas.element.getContext('2d');
                document.getElementById('gameCanvas').parentNode.insertBefore(overlayCanvas.element, document.getElementById('gameCanvas'));

                let obstacles = new Set(); // Store coordinates of red squares (obstacles)
                const MAX_PATHFINDING_ITERATIONS = 3000




                steps = 6; // Number of steps to render for the path
                // A* Node Constructor
                class Node {
                    constructor(x, y, g, h, parent = null) {
                        this.x = x;
                        this.y = y;
                        this.g = g; // Cost from start node
                        this.h = h; // Heuristic (estimated cost to end)
                        this.f = g + h; // Total cost
                        this.parent = parent;
                    }
                }

                // Heuristic function (Manhattan Distance)
                function heuristic(a, b) {
                    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
                }

                // A* Pathfinding Function
                function aStar(start, end) {
                    const openSet = [new Node(start[0], start[1], 0, heuristic(start, end))];
                    const closedSet = new Set();

                    while (openSet.length > 0) {
                        // Get the node with the lowest `f` value
                        openSet.sort((a, b) => a.f - b.f);
                        const current = openSet.shift();
                        const key = `${current.x},${current.y}`;

                        // If we reached the end, reconstruct the path
                        if (current.x === end[0] && current.y === end[1]) {
                            return reconstructPath(current);
                        }

                        closedSet.add(key);

                        // Check neighbors (up, down, left, right)
                        const neighbors = [
                            [current.x + squareSize, current.y],
                            [current.x - squareSize, current.y],
                            [current.x, current.y + squareSize],
                            [current.x, current.y - squareSize]
                        ];

                        for (const [nx, ny] of neighbors) {
                            const neighborKey = `${nx},${ny}`;

                            if (obstacles.has(neighborKey) || closedSet.has(neighborKey)) continue;

                            const gScore = current.g + 1;
                            const hScore = heuristic({ x: nx, y: ny }, { x: end[0], y: end[1] });
                            const neighbor = new Node(nx, ny, gScore, hScore, current);

                            const existing = openSet.find(n => n.x === nx && n.y === ny);

                            if (!existing || gScore < existing.g) {
                                openSet.push(neighbor);
                            }
                        }
                    }

                    return []; // No path found
                }

                // Reconstruct the Path from End to Start
                function reconstructPath(node) {
                    const path = [];
                    let current = node;

                    while (current) {
                        path.unshift([current.x, current.y]);
                        current = current.parent;
                    }

                    return path;
                }

                // Draw the Path Steps in White
                function fillFirstPathStep(path) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    for (let i = 0; i < Math.min(steps, path.length); i++) {
                        const [x, y] = path[i];
                        if (!obstacles.has(`${x},${y}`)) {
                            ctx.fillRect(x - squareSize / 2, y - squareSize / 2, squareSize, squareSize);
                        }
                    }
                }
                let spikeKT = function() {
                    return player.weapons[1] == 10 && ((info.health > items.weapons[player.weapons[0]].dmg) || player.weapons[0] == 5);
                }
                // Integrate A* with the Game Loop
                function drawGrid() {
                    reset();
                    obstacles.clear();

                    const width = overlayCanvas.element.width;
                    const height = overlayCanvas.element.height;

                    const centerX = width / 2;
                    const centerY = height / 2;
                    const { x: playerX, y: playerY } = _things.player;

                    // Draw Grid
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    for (let x = 0; x <= width; x += squareSize) {
                        for (let y = 0; y <= height; y += squareSize) {
                            ctx.strokeRect(x, y, squareSize, squareSize);
                        }
                    }

                    // Draw Obstacles
                    _things.liztobj.filter(isObstacle).forEach(obj => {
                        const { x: objX, y: objY } = obj;
                        const offsetX = centerX + (objX - playerX) * worldScale;
                        const offsetY = centerY + (objY - playerY) * worldScale;

                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        ctx.fillRect(offsetX - squareSize / 2, offsetY - squareSize / 2, squareSize, squareSize);
                        obstacles.add(`${offsetX},${offsetY}`);
                    });

                    // Draw Path to Enemies
                    _things.enemy_.forEach(enemy => {
                        const { x: enemyX, y: enemyY } = enemy;
                        const offsetX = centerX + (enemyX - playerX) * worldScale;
                        const offsetY = centerY + (enemyY - playerY) * worldScale;

                        const path = aStar([centerX, centerY], [offsetX, offsetY]);
                        fillFirstPathStep(path);
                    });
                }

                // Resize Canvas and Redraw
                function resizeCanvas() {
                    overlayCanvas.element.width = unsafeWindow.innerWidth;
                    overlayCanvas.element.height = unsafeWindow.innerHeight;
                    drawGrid();
                }
                function reset() {
                    ctx.clearRect(0, 0, overlayCanvas.element.width, overlayCanvas.element.height);
                }


                unsafeWindow.resizeCanvas=resizeCanvas

                function stop() {
                    typeof _things.player.moveDir==typeof 0&& (
                        _things.packet(_things.moveKey, null, 1),1
                        //_things.player.resetMoveDir()
                    )
                    lastMoveDir=null
                }

                // Implementing the adjustDirection function
                function adjustDirection(player, desiredDirection, obstacles) {
                    const avoidRadius = 60; // Adjust as needed
                    const avoidAngle = Math.PI / 4; // 45 degrees

                    let adjustedDirection = desiredDirection;

                    for (let obstacle of obstacles) {
                        // Calculate the distance and angle to the obstacle
                        const dx = obstacle.x - player.x;
                        const dy = obstacle.y - player.y;
                        const distance = Math.hypot(dx, dy);

                        if (distance < avoidRadius) {
                            const angleToObstacle = Math.atan2(dy, dx);
                            let angleDifference = angleToObstacle - desiredDirection;

                            // Normalize angleDifference to [-PI, PI]
                            if (angleDifference > Math.PI) angleDifference -= 2 * Math.PI;
                            if (angleDifference < -Math.PI) angleDifference += 2 * Math.PI;

                            if (Math.abs(angleDifference) < avoidAngle) {
                                // Obstacle is directly ahead, adjust direction
                                if (angleDifference > 0) {
                                    // Obstacle is to the right, turn left
                                    adjustedDirection -= avoidAngle;
                                } else {
                                    // Obstacle is to the left, turn right
                                    adjustedDirection += avoidAngle;
                                }
                                // Ensure adjustedDirection is within [0, 2*PI]
                                adjustedDirection = (adjustedDirection + 2 * Math.PI) % (2 * Math.PI);
                                // Break since we've adjusted for the nearest obstacle
                                break;
                            }
                        }
                    }

                    return adjustedDirection;
                }

                function isObstacle(obj) {
                    const hazardousNames = ["spikes", "greater spikes", "poison spikes", "spinning spikes", "pit trap"];
                    // Objects that block movement or are hazardous
                    return (
                        (obj.health && !obj.ignoreCollision && !obj.hideFromEnemy) || // Blocks movement
                        hazardousNames.includes(obj.name)                            // Is hazardous
                    );
                }
                function isObstaclePath(obj) {
                    // Objects that block movement or are hazardous
                    return (
                        (obj.health && (!obj.ignoreCollision||obj.name.includes('port')) && !obj.hideFromEnemy)                         // Is hazardous
                    );
                }

                function getObstaclesNearPlayer(player, gameObjects) {
                    const obstacleObjects = [];

                    gameObjects.forEach(obj => {
                        if (isObstacle(obj)) {
                            const distance = getDistance(player.x, player.y, obj.x, obj.y);
                            if (distance < 500) { // Adjust the detection radius as needed
                                obstacleObjects.push(obj);
                            }
                        }
                    });

                    return obstacleObjects;
                }
                function getAllObstaclesNearPlayer(player, gameObjects) {
                    const obstacleObjects = [];

                    gameObjects.forEach(obj => {
                        if (isObstaclePath(obj)&&!obj.name.includes('spawn')) {
                            const distance = getDistance(player.x, player.y, obj.x, obj.y);
                            //if (distance < 1000) { // Adjust the detection radius as needed
                            obstacleObjects.push(obj);
                            //}
                        }
                    });

                    return obstacleObjects;
                }

                // breaker useSpam farmAi
                let ids = {
                    faster_windmill: 11,
                    greater_spikes: 7,
                    pit_trap: 15,
                    power_mill: 12,
                    spikes: 6,
                    poison_spike: 8,
                    spinning_pikes: 9,
                    teleporter: 22,
                    turret: 17,
                    windmill: 10
                };

                autoGo = false
                let loop=setInterval(()=>{
                    if(autoGo&&!didSpawn){
                        clearInterval(loop)
                        packet("M", {
                            name: lastsp[0],
                            moofoll: lastsp[1],
                            skin: lastsp[2]
                        });
                    }
                })
                isMovingAuto=false
                breaker = false
                isMain = false
                useSpam = false
                farmAi = 0
                autoShield = true
                hasShield = false
                followID = false
                holdingShield = false
                autoRuby = 0
                breakOnly = false
                aimRuby = 0
                let alive = false
                rubyDir = -0.63
                onlybreaker=false
                chat = (msg) => _things.packet("6", msg);
                var breakk = false
                var canAtk = id => player.reloads[id] == 0;
                let oldAge = 0
                var sleep = ms => new Promise(a => setTimeout(a, ms));
                unsafeWindow.selection=[]
                function doMiddle(){
                    _things.enemy&&_things.enemy.enemy&&!instaC.isTrue&&(_things.packet('D',_things.enemy.enemy.aim2,1),instaC.rangeType())
                }
                _GM_setValue=GM_setValue
                _GM_getValue=GM_getValue
                _GM_addValueChangeListener=GM_addValueChangeListener
                GM_setValue('middle', false);
                lastMiddleValue=false,tt=null
                setInterval(() => {
                    let currentMiddleValue = GM_getValue('middle', false);
                    if (currentMiddleValue !== lastMiddleValue) {
                        console.log('[Polling] middle changed:', currentMiddleValue);
                        lastMiddleValue = currentMiddleValue;
                        if (autoGo && currentMiddleValue) {
                            if(_things.enemy.enemy&&!instaC.isTrue){
                                instaC.rangeFrame();
                            }
                        }
                    }
                }, 0); // Check every 100ms


                !async function () {
                    for (; ;) {
                        await sleep(0);
                        let aliveNow = _things.player ? _things.player.health >= 0.01 : false
                        if (alive != aliveNow) {
                            if(aliveNow&&!didSpawn)didSpawn=true;
                            console.log(aliveNow ? "Alive" : "Died")
                            unsafeWindow.selection=[]
                            if (aliveNow && autoRubyOnSpawn) {
                                autoRuby = 1
                                player.secondaryVariant=0
                                //player.primaryVariant=0
                                await sleep(200)
                            }
                        }
                        alive = aliveNow
                    }
                }()
                function getObjectsInLineOfSight(A, B) {
                    return _things.liztobj
                        .filter((obj) => obj.active && obj.render) // Filter active and rendered objects
                        .filter((obj) => {
                        const { x: cx, y: cy, scale } = obj;
                        const radius = scale / 2;

                        const x1 = A.x;
                        const y1 = A.y;
                        const x2 = B.x;
                        const y2 = B.y;

                        const dx = x2 - x1;
                        const dy = y2 - y1;

                        const fx = x1 - cx;
                        const fy = y1 - cy;

                        const a = dx * dx + dy * dy;
                        const b = 2 * (fx * dx + fy * dy);
                        const c = fx * fx + fy * fy - radius * radius;

                        let discriminant = b * b - 4 * a * c;

                        if (discriminant < 0) {
                            // No intersection
                            return false;
                        } else {
                            discriminant = Math.sqrt(discriminant);

                            const t1 = (-b - discriminant) / (2 * a);
                            const t2 = (-b + discriminant) / (2 * a);

                            // Check if at least one of the intersection points is within the segment
                            if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
                                return true;
                            }
                            return false;
                        }
                    })
                        .filter(e=>e.name?!e.name.includes('trap')&&!e.name.includes('form'):false)
                }
                function mainTargetChanged(newTarget) {
                    return (
                        !pathFind.mainTarget ||
                        pathFind.mainTarget.x !== newTarget.x ||
                        pathFind.mainTarget.y !== newTarget.y
                    );
                }

                function targetItemChanged(newTarget) {
                    return (
                        !pathFind.target ||
                        pathFind.target.x !== newTarget.x ||
                        pathFind.target.y !== newTarget.y
                    );
                }
                var targetPos;
                var offsetPos_=500;
                var obss=[]
                autoBow=false;

                function SendPathWithObstacles(pos, obstacles_) {
                    grid = [];
                    for (let y = 0; y < pathFind.grid; y++) {
                        grid[y] = [];
                        for (let x = 0; x < pathFind.grid; x++) {
                            const tmpXY = {
                                x: (player.x2 - pathFind.scale / 2) + (pathFind.scale / pathFind.grid) * x,
                                y: (player.y2 - pathFind.scale / 2) + (pathFind.scale / pathFind.grid) * y
                            };

                            // Check if cell is occupied by an obstacle
                            const isObstacle = obstacles_.some(obj => UTILS.getDist(obj, tmpXY, 0, 0) <= obj.getScale?obj.getScale():obj.scale);
                            grid[y][x] = isObstacle ? 1 : 0; // Blocked or passable
                        }
                    }
                }

                function calculateOffsetPosition(player, target, distance) {
                    const angle = Math.atan2(target.y - player.y, target.x - player.x);
                    return {
                        x: distance?player.x + distance * Math.cos(angle):target.x,
                        y: distance?player.y + distance * Math.sin(angle):target.y
                    };
                }
                !function(){
                    unsafeWindow.selects = [];
                    info2 = {};
                    console.log('User is in fact playing moomoo OG');
                    ageBarBody.style.transition = '1s';
                    items2 = JSON.parse('{"1":"7","2":"17","3":"31","4":"23","5":"10","6":"33","7":"28","8":"25"}')//{};

                    let teleport = 37,
                        hand_axe = 1,
                        greater_spike = 23,
                        great_axe = 2,
                        fast_mill = 28,
                        mineT = 29,
                        sapling = 30,
                        short_sword = 3,
                        katana = 4,
                        polearm = 5,
                        bat = 6,
                        daggers = 7,
                        stick = 8,
                        castle_wall = 21,
                        healing_pad = 35,
                        turret = 33,
                        platform = 34,
                        hunting_bow = 9,
                        cheese = 18,
                        great_hammer = 10,
                        wooden_shield = 11,
                        crossbow = 12,
                        repeater_crossbow = 13,
                        mc_grabby = 14,
                        stonewall = 20,
                        musket = 15,
                        cookie = 17,
                        trap = 31,
                        boost = 32,
                        blocker = 37,
                        power_mill = 28,
                        poison_spike = 24,
                        spining_spike = 25,
                        spawnpad = 36,
                        Age1 = null,
                        Age2 = null,
                        Age3 = null,
                        Age4 = null,
                        Age5 = null,
                        Age6 = null,
                        Age7 = null,
                        Age8 = null,
                        ranged = [crossbow, repeater_crossbow, musket, hunting_bow],
                        age = {
                            1: { hand_axe: 1, short_sword: 3, polearm: 5, daggers: 7, stick: 8, bat: 6 },
                            2: { cookie: 17, stonewall: 20 },
                            3: { trap: 31, boost: 32 },
                            4: { greater_spike: 23, mine: 29, sapling: 30, fast_mill: 27 },
                            5: { hunting_bow: 9, great_hammer: 10, mc_grabby: 14, wooden_shield: 11 },
                            6: { cheese: 18, castle_wall: 21, turret: 33, platform: 34, healing_pad: 35, blocker: 37, teleport: 38 },
                            7: { great_axe: 2, crossbow: 12, katana: 4, power_mill: 28 },
                            8: { repeater_crossbow: 13, musket: 15, poison_spike: 24, spining_spike: 25, spawnpad: 36 }
                        },
                        div = document.createElement('div');

                    weapons.forEach(e => {
                        e.age && (age[e.age - 1][e.name.split(' ').join('_')] = e.id);
                    });

                    // Function to update the selection path based on dependencies
                    function validatePath(ageIndex, selectedId) {
                        const selectedName = Object.keys(age[ageIndex]).find(key => age[ageIndex][key] === selectedId);
                        console.log(ageIndex)
                        // Dependencies for Musket
                        if (ranged.includes(selectedId)) {
                            if (!items2[5] || items2[5] !== hunting_bow) {
                                items2[5] = hunting_bow;
                                document.getElementById('sel5').value = hunting_bow;
                                //sendChat('Selected Bow for Musket');
                            }
                            if (!items2[7] || items2[7] !== crossbow) {
                                items2[7] = crossbow;
                                document.getElementById('sel7').value = crossbow;
                                //sendChat('Selected Crossbow for Musket');
                            }
                        }
                        // Dependencies for Katana
                        if (selectedId === katana && (!items2[1] || items2[1] !== short_sword)) {
                            items2[1] = short_sword;
                            document.getElementById('sel1').value = short_sword;
                            //sendChat('Selected Short Sword for Katana');
                        }
                        if (selectedId === great_axe && (!items2[1] || items2[1] !== hand_axe)) {
                            items2[1] = hand_axe;
                            document.getElementById('sel1').value = hand_axe;
                            //sendChat('Selected Short Sword for Katana');
                        }
                    }

                    (function(f = (e, b) => {
                        unsafeWindow.items2[b] = e.target.selectedOptions[0].value;
                        console.log([b], e.target.selectedOptions[0].value);
                    }, br = document.createElement('br')) {
                        for (let a in age) {
                            div.append(document.createElement('br'));
                            console.log(a);
                            let s = document.createElement('select');
                            unsafeWindow.selects.push([a, s]);
                            s.id = 'sel' + a;
                            s.classname = a;
                            let d = document.createElement('span');
                            d.innerText = `Age ${a}:`;
                            Object.keys(age[a]).forEach((e) => {
                                console.log(e, age[a][e]);
                                let b = document.createElement('option');
                                b.value = age[a][e];
                                b.innerText = e;
                                s.append(b);
                            });
                            div.append(d);
                            div.append(s);

                            s.onchange = function(e) {
                                var svalue = e.target.value;
                                var ageIndex = e.target.classname;
                                console.log('Age', ageIndex, 'to', svalue);
                                items2[ageIndex] = svalue;
                                validatePath(ageIndex, parseInt(svalue));
                            };
                        }
                        setupCard.append(div);
                    })();

                    unsafeWindow.spikes = [25, 23, 24, 6, 7, 9];
                    info2.ageitems = age;
                    info2.ageitems['0'] = { wood_wall: 19, spike: 6, windmill: 10 };
                    let serverBrowser=unsafeWindow.serverBrowser.children[0];
                    unsafeWindow.stoped = 1;
                    function NewServer(){
                        function getCR(){
                            return {name:serverBrowser.selectedOptions[0].innerText.split(' ')[0],id:serverBrowser.selectedOptions[0].value,index:serverBrowser.selectedOptions[0].innerText.split(' ')[1]};
                        }
                        var servers=[];
                        serverBrowser.children.forEah=[].forEach;[...serverBrowser.children].forEach(e=>{
                            var a=e.innerText.split(' ').pop().split('/')[0].split("[")[1]*1,
                                b=e.value,r=e.value.split(':')[0];
                            if(r==getCR().id.split(':')[0]){servers.push({a,b,e})}
                        })
                        var bestserver=servers.sort((a,b)=>b.a-a.a).filter(num=>num.a<40)[0];
                        var nsi=bestserver.b.split(":");nsi[1]=(nsi[1]*1)+1+'';nsi=nsi.join(':');
                        bestserver.b=nsi;
                        var ns=location.href.split('=');ns[1]=bestserver.b;ns=ns.join('=');
                        location.href=ns;
                    }
                    unsafeWindow.NewServer=NewServer;
                    function savel(){
                        localStorage.items2=JSON.stringify(items2)
                    }
                    function loadl(){
                        items2=JSON.parse(localStorage.items2);
                    }
                    const N=[
                        [],
                        [""],
                        ['Button','Crash?!','br','Button','New Server','br','Button','Autoplay','br','Button','Stop brekaing','br','Button','Load layout','br','Button','Save layout','br'],
                        [''],
                        [document,window],
                        {}
                    ]
                    var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){N[4][1]["crash"]()};B["innerText"]=N[2][1];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){N[4][1]["NewServer"]()};B["innerText"]=N[2][4];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){N[4][1]["Autoplay"]()};B["innerText"]=N[2][7];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){intrap=0};B["innerText"]=N[2][10];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){loadl()};B["innerText"]=N[2][13];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B);var B=N[4][0]["createElement"](N[2][0]);B["onclick"]=function(){savel()};B["innerText"]=N[2][16];guideCard["append"](N[4][0]["createElement"](N[2][2]));guideCard["append"](B)

                }();

                //chat commands
                !function(){
                    var _prefix = GM_getValue('prefix') || '!';
                    const _commands = {
                        "v": function(arg) {
                            const n = Number(arg);
                            if (!Number.isNaN(n)) {
                                viewSid = n;
                                GM_setValue('viewSid', viewSid);
                                sendChat(`👀 Now viewing bot ${viewSid}!`);
                            } else {
                                viewSid = null;
                                GM_setValue('viewSid', viewSid);
                                sendChat(`🔄 View reset—no bot selected.`);
                            }
                        },
                        "prefix": function(args){
                            if (args.length > 0) {
                                _prefix = args[0];
                                GM_setValue('prefix', _prefix);
                                sendChat(`Prefix now iz ${_prefix} mew!`);
                            }
                        },
                        "main": function(){
                            isMain = !isMain;
                            sendChat(`Main mode flip-flopped! XD`);
                        },
                        "bot": function(){
                            autoGo = !autoGo;
                            sendChat(`Bo-o-o-otMode iz ${autoGo ? "ON" : "OFF"} now!`);
                        },
                        "find":function(sid){
                            if(sid>=1&&!Number.isNaN(sid)){
                                GM_setValue('find',sid)
                            }
                        },
                        "mode": function(a){
                            console.log(a)
                            if(a&&a.length){
                                if(modes.includes(a)){
                                    mode=a
                                }else setTimeout(()=>{(sendChat(`Mode:${a} not found`),setTimeout(()=>{sendChat(`Modes:`+modes.join(','))},1000))},1000)
                            }else setTimeout(()=>{sendChat(`Modes:`+modes.join(','))},100)
                        },
                        "breaker": function(){
                            breaker = !GM_getValue('breaker', false);
                            GM_setValue('breaker', breaker);
                            sendChat(`Breaker iz ${breaker ? "ON" : "OFF"} now!`);
                        },
                        "useSpam": function(){
                            useSpam = !GM_getValue('useSpam', false);
                            GM_setValue('useSpam', useSpam);
                            sendChat(`Spam mode iz ${useSpam ? "ON" : "OFF"} zzz!`);
                        },
                        "farmAi": function(){
                            farmAi = !GM_getValue('farmAi', false);
                            GM_setValue('farmAi', farmAi);
                            sendChat(`FarmAI iz ${farmAi ? "ON" : "OFF"} baaa!`);
                        },
                        "spawn": function(a){
                            if(Number(a)==NaN)return;
                            for(let i=0;i<a;i++){open(location.href,'bot')}
                        },

                        "stay": function(){
                            isMain = false;
                            GM_setValue('stay', !isMain);
                            sendChat(`Bots R sittin n chillin!`);
                        },
                        "follow": function(id='d'){
                            GM_setValue('k','.')
                            let radius
                            if(radius&&radius.length&&Number(radius)!=NaN){
                                GM_setValue('radius',100)
                                setTimeout(()=>sendChat('Raduis:'+(GM_getValue('radius')||300)),500)
                            }
                            if(id&&id.length&&Number(id)!=NaN){
                                console.log('wtf',id,id.length,typeof id)
                                GM_setValue('stay', false);
                                GM_setValue('fID', id);
                                sendChat(`Following ID:${id}`);
                                return
                            }
                            GM_setValue('fID', null);
                            isMain = true;
                            GM_setValue('stay', !isMain);
                            sendChat(`Main mode iz ON, followz!`);
                        },
                        "r":function(r){
                            if(Number(r)!=NaN)GM_setValue('r',r);
                        },
                        "k": function(id) {
                            if (!isNaN(Number(id))) {
                                GM_setValue('k', id);
                            }else {
                                GM_setValue('k','.')
                                GM_setValue('breaker', false);
                            }
                        },
                        "autoclan": function(id) {
                            autoJoinMain=!autoJoinMain
                        },
                        "filterclan": function(id) {
                            filterclan=!filterclan
                        },
                        "clan": function (id) {
                            const arr = Array.from(
                                { length: 7 },
                                (_, i) => id[i] || "\x00"
                            ).join('')
                            GM_setValue("Mclan", id);
                        },
                        "ruby": function (id) {
                            if(!autoGo)return
                            autoRuby=!autoRuby
                            chat('weapon grind:'+autoRuby)
                        },
                        "autoruby": function (id) {
                            if(!autoGo)return
                            autoRubyOnSpawn=!autoRubyOnSpawn
                            chat('autoRubyOnSpawn:'+autoRubyOnSpawn)
                        },
                        "here": function(){
                            GM_setValue('stay', false);
                            GM_setValue('k','.')
                            GM_setValue('mainPos', { x: player.x, y: player.y });
                            sendChat(`Main posishun saved! =^_^=`);
                        },
                        "shield": function(){
                            autoShield = !GM_getValue('shield', false);
                            GM_setValue('shield', autoShield);
                            sendChat(`AutoShield iz ${autoShield ? "ON" : "OFF"}!`);
                        }
                    };

                    // Ensure that the values are loaded when the script runs
                    breaker = GM_getValue('breaker')||false;
                    useSpam = GM_getValue('useSpam')||false;
                    farmAi = GM_getValue('farmAi')||false;
                    allowComands=true
                    document.getElementById("chatBox").addEventListener('keydown', e => {
                        if (e.key === 'Enter') {  // Check if the Enter key is pressed
                            const input = e.target.value.trim();
                            if (input.startsWith(_prefix)) {
                                !allowComands&&e.preventDefault();  // Prevent the default action if it's a command
                                const command = input.slice(_prefix.length).split(" ")[0];
                                const args = input.slice(_prefix.length + command.length).trim().split(" ");

                                if (_commands.hasOwnProperty(command)) {
                                    _commands[command](...args);
                                    !allowComands&&(e.target.value = ''); // Clear the chat input after processing
                                }
                            }
                        }
                    });
                }();

                let runAtNextTick = [];
                function checkProjectileHolder(x, y, dir, range, speed, indx, layer, sid) {
                    let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
                    let projOffset = config.playerScale * 2;
                    let projXY = {
                        x: indx == 1 ? x : x - projOffset * Math.cos(dir),
                        y: indx == 1 ? y : y - projOffset * Math.sin(dir),
                    };
                    let nearPlayer = players.filter((e) => e.visible && UTILS.getDist(projXY, e, 0, 2) <= e.scale).sort(function (a, b) {
                        return UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2);
                    })[0];
                    if (nearPlayer) {
                        if (indx == 1) {
                            nearPlayer.shooting[53] = 1;
                        } else {
                            nearPlayer.shootIndex = weaponIndx;
                            nearPlayer.shooting[1] = 1;
                            antiProj(nearPlayer, dir, range, speed, indx, weaponIndx);
                        }
                    }
                }
                let projectileCount = 0;

                function antiProj(tmpObj, dir, range, speed, index, weaponIndex) {
                    if (!tmpObj.isTeam(player)) {
                        tmpDir = UTILS.getDirect(player, tmpObj, 2, 2);
                        if (UTILS.getAngleDist(tmpDir, dir) <= 0.2) {
                            tmpObj.bowThreat[weaponIndex]++;
                            if (index == 5) {
                                projectileCount++;
                            }
                            setTimeout(() => {
                                tmpObj.bowThreat[weaponIndex]--;
                                if (index == 5) {
                                    projectileCount--;
                                }
                            }, range / speed);
                            if (tmpObj.bowThreat[9] >= 1 && (tmpObj.bowThreat[12] >= 1 || tmpObj.bowThreat[15] >= 1)) {
                                place(1, tmpObj.aim2);
                                my.anti0Tick = 4;
                                if (!my.antiSync) {
                                    antiSyncHealing(4);
                                }
                            } else {
                                if (projectileCount >= 2) {
                                    place(1, tmpObj.aim2);
                                    healer();
                                    //sendChat("sync detect test");
                                    buyEquip(22, 0);
                                    buyEquip(13, 1);
                                    my.anti0Tick = 4;
                                    if (!my.antiSync) {
                                        antiSyncHealing(4);
                                    }
                                } else {
                                    if (projectileCount === 1) { // anti reverse or anti 1 tick with reaper
                                        buyEquip(6, 0);
                                        healer();
                                        game.tickBase(() => {
                                            // sendChat("rev detected");
                                        },2);
                                    }
                                    /*} else {
                    if (projectileCount >= 2) { // anti sync линия обороны N1
                    return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
                    player.chat.message = "pSyD";
                    healer();
                    buyEquip(6, 0);
                    }
                    }*/
                                }
                            }
                        }
                    }
                }
                // SHOW ITEM INFO:
                function showItemInfo(item, isWeapon, isStoreItem) {
                    if (player && item) {
                        UTILS.removeAllChildren(itemInfoHolder);
                        itemInfoHolder.classList.add("visible");
                        UTILS.generateElement({
                            id: "itemInfoName",
                            text: UTILS.capitalizeFirst(item.name),
                            parent: itemInfoHolder
                        });
                        UTILS.generateElement({
                            id: "itemInfoDesc",
                            text: item.desc,
                            parent: itemInfoHolder
                        });
                        if (isStoreItem) {

                        } else if (isWeapon) {
                            UTILS.generateElement({
                                class: "itemInfoReq",
                                text: !item.type?"primary":"secondary",
                                parent: itemInfoHolder
                            });
                        } else {
                            for (let i = 0; i < item.req.length; i += 2) {
                                UTILS.generateElement({
                                    class: "itemInfoReq",
                                    html: item.req[i] + "<span class='itemInfoReqVal'> x" + item.req[i + 1] + "</span>",
                                    parent: itemInfoHolder
                                });
                            }
                            if (item.group.limit) {
                                UTILS.generateElement({
                                    class: "itemInfoLmt",
                                    text: (player.itemCounts[item.group.id] || 0) + "/" + (config.isSandbox ? 99 : item.group.limit),
                                    parent: itemInfoHolder
                                });
                            }
                        }
                    } else {
                        itemInfoHolder.classList.remove("visible");
                    }
                }


                // RESIZE:
                unsafeWindow.addEventListener("resize", UTILS.checkTrusted(resize));

                function resize() {
                    screenWidth = unsafeWindow.innerWidth;
                    screenHeight = unsafeWindow.innerHeight;
                    /*let scaleFillNative = Math.max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
                gameCanvas.width = screenWidth * pixelDensity;
                gameCanvas.height = screenHeight * pixelDensity;
                gameCanvas.style.width = screenWidth + "px";
                gameCanvas.style.height = screenHeight + "px";
                mainContext.setTransform(
                    scaleFillNative, 0,
                    0, scaleFillNative,
                    (screenWidth * pixelDensity - (maxScreenWidth * scaleFillNative)) / 2,
                    (screenHeight * pixelDensity - (maxScreenHeight * scaleFillNative)) / 2
                );*/
                }
                resize();
                gameCanvas = document.getElementById("touch-controls-fullscreen");
                // MOUSE INPUT:
                gameCanvas.addEventListener("mousemove", gameInput, false);

                function gameInput(e) {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
                let clicks = {
                    left: false,
                    middle: false,
                    right: false,
                };
                unsafeWindow.addEventListener("mouseup", UTILS.checkTrusted(mouseUp));
                gameCanvas.addEventListener("mousedown", mouseDown, false);

                function mouseDown(e) {
                    if (attackState != 1) {
                        attackState = 1;
                        if (e.button == 0) {
                            clicks.left = true;
                        } else if (e.button == 1) {
                            e.preventDefault()
                            //clicks.middle = true;
                            console.log('[MouseDown] Middle click → setting GM value');
                            GM_setValue('middle', true); // ← might not trigger if already true
                            instaC.rangeFrame()

                        } else if (e.button == 2) {
                            e.preventDefault()
                            clicks.right = true;
                        }
                    }
                }
                function mouseUp(e) {
                    if (attackState != 0) {
                        attackState = 0;
                        if (e.button == 0) {
                            clicks.left = false;
                        } else if (e.button == 1) {
                            clicks.middle = false;
                            console.log('[MouseDown] Middle click → setting GM value');
                            GM_setValue('middle', !true); // ← might not trigger if already true

                        } else if (e.button == 2) {
                            clicks.right = false;
                        }
                    }
                }
                gameCanvas.addEventListener("wheel", wheel, false);

                function wheel(e) {
                    if (e.deltaY < 0) {
                        my.reSync = true;
                    } else {
                        my.reSync = false;
                    }
                }
                // INPUT UTILS:
                function getMoveDir() {
                    //if(bestEsc)return bestEsc
                    if(autoGo)return toMove[1]
                    let dx = 0;
                    let dy = 0;
                    for (let key in moveKeys) {
                        let tmpDir = moveKeys[key];
                        dx += !!keys[key] * tmpDir[0];
                        dy += !!keys[key] * tmpDir[1];
                    }
                    return dx == 0 && dy == 0 ? undefined : Math.atan2(dy, dx);
                }

                function getSafeDir() {
                    if (!player)
                        return 0;
                    if (!player.lockDir) {
                        lastDir = Math.atan2(mouseY - (screenHeight / 2), mouseX - (screenWidth / 2));
                    }
                    return lastDir || 0;
                }
                function getAttackDir(debug) {
                    if (debug) {
                        if (!player)
                            return "0";
                        if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap)) && player.reloads[player.weapons[0]] == 0))
                            lastDir = getEl("weaponGrind").checked ? "getSafeDir()" : enemy.length ? my.revAim ? "(near.aim2 + Math.PI)" : "near.aim2" : "getSafeDir()";
                        else
                            if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = "getSafeDir()";
                        else
                            if (!instaC.isTrue && nearspiker && player.reloads[spikeKT() ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = "aimSpike";
                        else
                            if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = "traps.aim";

                        else
                            if (!player.lockDir) {
                                if (configs.noDir) return "undefined";
                                lastDir = "getSafeDir()";
                            }
                        return lastDir;
                    } else {
                        if (!player)
                            return 0;
                        if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap)) && player.reloads[player.weapons[0]] == 0))
                            lastDir = getEl("weaponGrind").checked ? getSafeDir() : enemy.length ? my.revAim ? (near.aim2 + Math.PI) : near.aim2 : getSafeDir();
                        else
                            if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = getSafeDir();
                        else
                            if (!instaC.isTrue && nearspiker && player.reloads[spikeKT() ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = aimSpike;
                        else
                            if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = traps.aim;
                        else
                            if (!player.lockDir) {
                                if (configs.noDir) return undefined;
                                lastDir = getSafeDir();
                            }
                        return lastDir || 0;
                    }
                }

                function getVisualDir() {
                    if (!player)
                        return 0;
                    if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap)) && player.reloads[player.weapons[0]] == 0))
                        lastDir = getEl("weaponGrind").checked ? getSafeDir() : enemy.length ? my.revAim ? (near.aim2 + Math.PI) : near.aim2 : getSafeDir();
                    else
                        if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                            lastDir = getSafeDir();
                    else
                        if (!instaC.isTrue && nearspiker && player.reloads[spikeKT() ? player.weapons[1] : player.weapons[0]] == 0)
                            lastDir = aimSpike;
                    else
                        if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0)
                            lastDir = traps.aim;
                    else
                        if (!player.lockDir) {
                            lastDir = getSafeDir();
                        }
                    return lastDir || 0;
                }

                // KEYS:
                function keysActive() {
                    return (
                        allianceMenu.style.display != "block" && chatHolder.style.display != "block"
                    );
                }

                function toggleMenuChat() {
                    if (menuChatDiv.style.display != "none") {
                        //   chatHolder.style.display = "none";
                        // if (menuChatBox.value != "") {
                        //commands[command.slice(1)]
                        let cmd = function(command) {
                            return {
                                found: command.startsWith("/") && commands[command.slice(1).split(" ")[0]],
                                //fv: commands[command.slice(1).split(" ")[0]]
                            }
                        }
                        let command = cmd(menuChatBox.value);
                        if (command.found) {
                            if (typeof command.fv.action === "function") {
                                command.fv.action(menuChatBox.value);
                            }
                        } else {
                            sendChat(menuChatBox.value);
                        }
                        menuChatBox.value = "";
                        menuChatBox.blur();
                    } else {
                        if (menuCBFocus) {
                            menuChatBox.blur();
                        } else {
                            menuChatBox.focus();
                        }
                    }
                }


                function keyDown(event) {
                    let keyNum = event.which || event.keyCode || 0;
                    if (player && player.alive && keysActive()) {
                        if (!keys[keyNum]) {
                            keys[keyNum] = 1;
                            macro[event.key] = 1;
                            if (keyNum == 27) {
                                openMenu = !openMenu;
                                $("#menuDiv").toggle();
                                $("#menuChatDiv").toggle();
                            } else if (keyNum == 69) {
                                sendAutoGather();
                            } else if (keyNum == 67) {
                                updateMapMarker();
                            } else if (player.weapons[keyNum - 49] != undefined) {
                                player.weaponCode = player.weapons[keyNum - 49];
                            } else if (moveKeys[keyNum]) {
                                sendMoveDir();
                            } else if (event.key == "m") {
                                pads.placeSpawnPads = !pads.placeSpawnPads;
                            } else if (event.key == "z") {
                                mills.place = !mills.place;
                                textManager.showText(player.x2, player.y2, 20, 0.15, 1850, `Automills: ${mills.place}`, "#00FFFF", 2);
                            } else if (event.key == "Z") {
                                typeof unsafeWindow.debug == "function" && unsafeWindow.debug();
                            } else if (keyNum == 32) {
                                packet("9", 1, getSafeDir(), 1);
                                packet("9", 0, getSafeDir(), 1);
                            } else if (event.key == ",") {
                                player.sync = true;
                            } else if (event.key == "t") {
                                autoOneFrameToggled = !autoOneFrameToggled;
                                const oneFrameStatus = autoOneFrameToggled ? "On" : "Off";
                                textManager.showText(player.x2, player.y2, 20, 0.15, 1850, `OneFrame: ${oneFrameStatus}`, "#00FFFF", 2);
                            }
                        }
                    }
                }
                addEventListener("keydown", UTILS.checkTrusted(keyDown));

                function keyUp(event) {
                    if (player && player.alive) {
                        let keyNum = event.which || event.keyCode || 0;
                        if (keyNum == 13) {
                            toggleMenuChat();
                        } else if (keysActive()) {
                            if (keys[keyNum]) {
                                keys[keyNum] = 0;
                                macro[event.key] = 0;
                                if (moveKeys[keyNum]) {
                                    sendMoveDir();
                                } else if (event.key == ",") {
                                    player.sync = false;
                                }
                            }
                        }
                    }
                }
                unsafeWindow.addEventListener("keyup", UTILS.checkTrusted(keyUp));

                function sendMoveDir() {
                    let newMoveDir = getMoveDir();
                    if (lastMoveDir == undefined || newMoveDir == undefined || Math.abs(newMoveDir - lastMoveDir) > 0.3) {
                        if (!(my.autoPush||my.autoPush2)) {
                            packet("9", newMoveDir, 1);
                        }
                        lastMoveDir = newMoveDir;
                    }
                }
                function findAllianceBySid(sid) {
                    return player.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
                }
                /** PATHFIND TEST */
                function chechPathColl(tmp) {
                    return ((player.scale + tmp.getScale()) / (player.maxSpeed * items.weapons[player.weaponIndex].spdMult)) + (tmp.dmg && !tmp.isTeamObject(player) ? 35 : 0);
                    return tmp.colDiv == 0.5 ? (tmp.scale * tmp.colDiv) :
                        !tmp.isTeamObject(player) && tmp.dmg ? (tmp.scale + player.scale) :
                    tmp.isTeamObject(player) && tmp.trap ? 0 : tmp.scale;
                }

                function CanObject(pos, one, two) {
                    let checkColl = gameObjects.filter(tmp => player.canSee(tmp) && tmp.active);
                    for (let y = 0; y < pathFind.grid; y++) {
                        grid[y] = [];
                        for (let x = 0; x < pathFind.grid; x++) {
                            let tmpXY = {
                                x: (player.x2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * x),
                                y: (player.y2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * y)
                            }
                            // Debug each cell calculation
                            const dist = UTILS.getDist(pos, tmpXY, one, two);
                            //console.log(`Cell (${x}, ${y}) Distance:`, dist);
                            if (dist <= 35) {
                                //console.log(`Setting LastX, LastY to:`, x, y);
                                pathFind.lastX = x;
                                pathFind.lastY = y;
                                grid[y][x] = 0;
                                continue;
                            }

                            let find = checkColl.find(tmp => UTILS.getDist(tmp, tmpXY, 0, 0) <= chechPathColl(tmp));
                            if (find) {
                                if (find.trap) {
                                    grid[y][x] = 0;
                                    continue;
                                }
                                grid[y][x] = 1;
                            } else {
                                grid[y][x] = 0;
                            }
                        }
                    }
                }
                // BUTTON EVENTS:
                function bindEvents() {}
                bindEvents();

                function SendPath(pos, one, two) {
                    grid = [];
                    CanObject(pos, one, two);
                    //console.log("Grid after SendPath:", grid); // Debug the grid
                    //console.log("PathFind LastX:", pathFind.lastX, "LastY:", pathFind.lastY); // Debug coordinates

                }
                let CheckAim = near.aim2,
                    CheckDist = near.dist2;

                function Move() {
                    const trap1 = gameObjects
                    .filter((e) => e.trap && e.active)
                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                    .find((trap) => {
                        const trapDist = Math.sqrt((trap.y - near.y2) ** 2 + (trap.x - near.x2) ** 2);
                        return (
                            trap !== player &&
                            (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) &&
                            trapDist <= 50
                        );
                    });
                    ResetActions();
                    if (near.dist2 > items.weapons[player.weapons[0]].range + near.scale * 1.8) {
                        if (((player.shameCount > 5) || player.skinIndex == 45) && CheckDist < 400) {
                            console.log('Stoping-CheckAim',CheckAim)
                            packet("9", CheckAim + Math.PI, 1);
                        } else if (CheckDist <= items.weapons[player.weaponIndex].range + near.scale && trap1) {
                            console.log('Stoping')
                            packet("9", undefined, 1);
                        } else if (!trap1 && CheckDist < items.weapons[player.weaponIndex].range + near.scale * 1.8) {
                            packet("9", CheckAim + Math.PI, 1);console.log('Stoping-CheckAim',CheckAim)
                        } else if (CheckDist >= items.weapons[player.weaponIndex].range + near.scale * 1.8) {
                            packet("9", CheckAim, 1);console.log('Stoping-CheckAim',CheckAim)
                        } else {
                            console.log('Stoping')
                            packet("9", undefined, 1);
                        }
                    }
                }
                let lastTarget  = null;
                function ResetActions() {
                    my.canMove = true;
                    my.MillAim = false;
                    my.SpikeAim = false;
                    my.canHat = true;
                }
                //JPS
                function PathfinderJPS(pos, one, two) {
                    pathFind.scale = (config.maxScreenWidth / (10/9)) * 1.3;

                    if (traps.inTrap) return;

                    // if we’re already in range just fire off Move()
                    if (CheckDist <= items.weapons[player.weapons[0]].range + near.scale * 1.8
                        || player.skinIndex === 45
                        || player.shameCount > 6
                       ) {
                        return Move();
                    }

                    // otherwise compute a JPS path
                    SendPath(pos, one, two);

                    if (!grid || grid.length === 0) {
                        console.error("Error: Grid is not initialized.");
                        return;
                    }

                    // build PF grid
                    const pfGrid = new pathfinding_.Grid(grid);

                    // pick a JPS variant
                    const finder = new pathfinding_.JumpPointFinder({
                        diagonalMovement: pathfinding_.DiagonalMovement.IfAtMostOneObstacle,
                        // you can also pass {}, Never, Always, OnlyWhenNoObstacles, etc.
                    });

                    const startX = Math.floor(grid[0].length / 2);
                    const startY = Math.floor(grid.length    / 2);
                    const endX   = pathFind.lastX;
                    const endY   = pathFind.lastY;

                    // sanity check
                    if ([ startX, startY, endX, endY ].some(v => isNaN(v))) {
                        console.error("Error: Invalid coordinates for pathfinding.");
                        return;
                    }

                    // run JPS
                    const path = finder.findPath(startX, startY, endX, endY, pfGrid);

                    if (path.length < 2) {
                        pathFind.array = [];
                        return Move();
                    }

                    pathFind.array = path;

                    // translate the second node into a world‑offset and send it
                    const next   = path[1];
                    const tmpXY  = {
                        x: (player.x2 - pathFind.scale/2) + (pathFind.scale/pathFind.grid)*next.x,
                        y: (player.y2 - pathFind.scale/2) + (pathFind.scale/pathFind.grid)*next.y,
                    };
                    io.send("9", UTILS.getDirect(tmpXY, player, 0, 2), 1);
                }

                //constanly go
                async function backgroundPathfinder() {
                    // only start once
                    while (true) {
                        // if we’re trapped, clear out and wait a bit
                        if (traps.inTrap) {
                            pathFind.array = [];
                            await sleep(200);
                            continue;
                        }

                        // if already in firing range, no path needed
                        if ( CheckDist <= items.weapons[player.weapons[0]].range + near.scale * 1.8
                            || player.skinIndex === 45
                            || player.shameCount > 6
                           ) {
                            pathFind.array = [];
                            await sleep(100);
                            continue;
                        }
                        SendPath(pos, one, two);
                        easystar.setGrid(grid);
                        easystar.setAcceptableTiles([0]);
                        // make sure grid exists
                        if (!grid || !grid.length) {
                            console.error("Grid not ready");
                            await sleep(200);
                            continue;
                        }

                        // compute coords
                        const startX = Math.floor(grid[0].length / 2);
                        const startY = Math.floor(grid.length    / 2);
                        const endX   = pathFind.lastX;
                        const endY   = pathFind.lastY;
                        if ([startX, startY, endX, endY].some(isNaN)) {
                            console.error("Invalid path coords");
                            await sleep(200);
                            continue;
                        }

                        // promisify easystar
                        const path = await new Promise(resolve => {
                            easystar.setGrid(grid);
                            easystar.setAcceptableTiles([0]);
                            // easystar.enableDiagonals();
                            easystar.findPath(startX, startY, endX, endY, resolve);
                            easystar.calculate();
                        });

                        if (!path) {
                            pathFind.array = [];
                            await sleep(100);
                            continue;
                        }

                        pathFind.array = path;
                        await sleep(50);          // throttle your re‑computations
                    }
                }
                //backgroundPathfinder() doesnt work

                //A*
                // keep a reference to the last array we were walking
                let currentPath = [];//idk man

                function PathfinderBroke(p, o, t) {
                    // update the “where to” coords for your background task
                    pos = p; one = o; two = t;

                    // if the background has handed us a brand‑new array, reset
                    if (pathFind.array !== currentPath) {
                        currentPath = pathFind.array;
                    }

                    // if there’s still at least one step left, follow it…
                    if (currentPath && currentPath.length > 0) {
                        const next = currentPath.shift();
                        const scale = (config.maxScreenWidth/(10/9))*1.3;
                        const tmpXY = {
                            x: (player.x2 - (scale/2)) + ((scale/pathFind.grid)*next.x),
                            y: (player.y2 - (scale/2)) + ((scale/pathFind.grid)*next.y)
                        };
                        io.send("9", UTILS.getDirect(tmpXY, player, 0, 2), 1);
                    }
                    else {
                        // path exhausted (or never set) → fallback to your normal Move()
                        Move();
                    }
                }

                let lastPathTarget = null;
                /** PATHFIND TEST */
                function shouldRepath() {
                    console.log(pathIndex,currentPath.length,lastPathTarget&&lastPathTarget.x !== pathFind.lastX,lastPathTarget&&lastPathTarget.y !== pathFind.lastY)
                    return (
                        !currentPath.length ||
                        pathIndex >= currentPath.length ||
                        !lastPathTarget ||
                        lastPathTarget.x !== pathFind.lastX ||
                        lastPathTarget.y !== pathFind.lastY
                    );
                }
                function followPath() {
                    if (!currentPath.length || pathIndex >= currentPath.length) return;

                    const step = currentPath[pathIndex];
                    const target = {
                        x: (player.x2 - pathFind.scale/2) + (pathFind.scale/pathFind.grid)*step.x,
                        y: (player.y2 - pathFind.scale/2) + (pathFind.scale/pathFind.grid)*step.y
                    };

                    _things.packet("9", UTILS.getDirect(target, player, 0, 2), 1);

                    const dx = player.x2 - target.x,
                          dy = player.y2 - target.y;

                    // threshold = 8px; tweak if needed
                    console.log(getDistance(player.x,player.y,target.x,target.y))
                    console.log(Math.hypot(dx, dy).toFixed(0),getDistance(player.x,player.y,target.x,target.y).toFixed(0))
                    if (Math.hypot(dx, dy) < 8) {
                        pathIndex++;
                    }
                }

                function PathfinderGPT(pos, one, two) {
                    pathFind.scale = (config.maxScreenWidth / (10/9)) * 1.3;
                    if (traps.inTrap) return;
                    if (
                        CheckDist <= items.weapons[player.weapons[0]].range + near.scale * 1.8 ||
                        player.skinIndex === 45 ||
                        player.shameCount > 6
                    ) {
                        Move();
                        return;
                    }

                    SendPath(pos, one, two);
                    easystar.setGrid(grid);
                    easystar.setAcceptableTiles([0]);
                    easystar.enableDiagonals();

                    if (!grid.length) {
                        console.error("Grid not ready.");
                        return;
                    }

                    const startX = Math.floor(grid[0].length/2),
                          startY = Math.floor(grid.length/2),
                          endX   = pathFind.lastX,
                          endY   = pathFind.lastY;

                    // only re-path if target changed
                    if (
                        lastTarget&&lastTarget.x === endX &&
                        lastTarget&&lastTarget.y === endY &&
                        currentPath.length
                    ) return;

                    lastTarget = { x: endX, y: endY };

                    easystar.findPath(startX, startY, endX, endY, function(path) {
                        if (!path || path.length <= 1) {
                            currentPath = [];
                            pathIndex   = 1;
                            Move();
                        } else {
                            console.log('currentPath set',currentPath)
                            currentPath = path;
                            pathIndex   = 1;
                        }
                    });
                    easystar.calculate();
                }

                function Pathfinder(pos, one, two) {
                    pathFind.scale = (config.maxScreenWidth / (10/9)) * 1.3;
                    if (!traps.inTrap) {
                        if (((CheckDist <= items.weapons[player.weapons[0]].range + near.scale * 1.8) || player.skinIndex == 45 || player.shameCount > 6)) {
                            Move();
                        } else {
                            SendPath(pos, one, two);
                            easystar.setGrid(grid);
                            easystar.setAcceptableTiles([0]);
                            easystar.enableDiagonals();
                            if (!grid || grid.length === 0) {
                                console.error("Error: Grid is not initialized.");
                                return;
                            }
                            const startX = Math.floor(grid[0].length / 2);
                            const startY = Math.floor(grid.length / 2);
                            const endX = pathFind.lastX;
                            const endY = pathFind.lastY;

                            if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY)) {
                                console.error("Error: Invalid coordinates for pathfinding.");
                                return;
                            }
                            easystar.findPath((grid[0].length / 2), (grid.length / 2), pathFind.lastX, pathFind.lastY, function(path) {
                                if (path === null) {
                                    currentPath=[]
                                    pathFind.array = [];
                                    Move();
                                } else {
                                    pathFind.array = path;
                                    if (pathFind.array.length > 1) {
                                        currentPath=path;
                                        let tmpXY = {
                                            x: (player.x2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * path[1].x),
                                            y: (player.y2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * path[1].y)
                                        }
                                        //console.log('moving')
                                        toMove=["9", UTILS.getDirect(tmpXY, player, 0, 2), 1]
                                        packet("9", UTILS.getDirect(tmpXY, player, 0, 2), 1)
                                        lastMoveDir=UTILS.getDirect(tmpXY, player, 0, 2)
                                        _things.packet("9", UTILS.getDirect(tmpXY, player, 0, 2), 1)
                                        return
                                        if(my.autoPush){
                                        }else _things.packet("9", UTILS.getDirect(tmpXY, player, 0, 2), 1)

                                    }
                                }
                            });
                            easystar.calculate();
                        }
                    }
                }
                // ITEM COUNT DISPLAY:
                let isItemSetted = [];
                function updateItemCountDisplay(index = undefined) {
                    for (let i = 3; i < items.list.length; ++i) {
                        let id = items.list[i].group.id;
                        let tmpI = items.weapons.length + i;
                        if (!isItemSetted[tmpI]) {
                            isItemSetted[tmpI] = document.createElement("div");
                            isItemSetted[tmpI].id = "itemCount" + tmpI;
                            getEl("actionBarItem" + tmpI).appendChild(isItemSetted[tmpI]);
                            isItemSetted[tmpI].style = `
                        display: block;
                        position: absolute;
                        padding-left: 5px;
                        font-size: 2em;
                        color: #fff;
                        `;
                            isItemSetted[tmpI].innerHTML = player.itemCounts[id] || 0;
                        } else {
                            if (index == id) isItemSetted[tmpI].innerHTML = player.itemCounts[index] || 0;
                        }
                    }
                }
                my.pushPhase = 0;
                // AUTOPUSH:
                var retrappable = false;
                // A* search to find a trap chain that leads to a valid spike
                function findTrapPathAStar(start) {
                    // Each node in the open list: { trap, path, cost, estimate }
                    let openList = [];
                    let closedSet = new Set();

                    // Heuristic: use distance from the current trap to the nearest valid spike, or fallback to 'near'
                    function heuristic(trap) {
                        const spikes = gameObjects.filter(tmp =>
                                                          tmp.dmg && tmp.active && tmp.isTeamObject(player) &&
                                                          UTILS.getDist(tmp, trap, 0, 0) <= near.scale + trap.scale + tmp.scale
                                                         );
                        if (spikes.length) {
                            let bestSpike = spikes.sort((a, b) => UTILS.getDist(a, trap, 0, 0) - UTILS.getDist(b, trap, 0, 0))[0];
                            return UTILS.getDist(trap, bestSpike, 0, 0);
                        }
                        // Fallback: estimate distance to 'near'
                        return UTILS.getDist(trap, near, 0, 2);
                    }

                    // Initialize openList with traps reachable from the start
                    const initialTraps = gameObjects.filter(tmp =>
                                                            tmp.trap && tmp.active && tmp.isTeamObject(player) &&
                                                            UTILS.getDist(tmp, start, 0, 2) <= start.scale + tmp.getScale() + 5
                                                           );
                    for (let trap of initialTraps) {
                        let cost = UTILS.getDist(start, trap, 0, 2);
                        openList.push({ trap, path: [trap], cost, estimate: heuristic(trap) });
                    }

                    while (openList.length) {
                        // Sort openList by f = cost + estimate and get the best candidate
                        openList.sort((a, b) => (a.cost + a.estimate) - (b.cost + b.estimate));
                        let current = openList.shift();
                        let lastTrap = current.trap;

                        // Check if lastTrap can reach a valid spike
                        const spikes = gameObjects.filter(tmp =>
                                                          tmp.dmg && tmp.active && tmp.isTeamObject(player) &&
                                                          UTILS.getDist(tmp, lastTrap, 0, 0) <= near.scale + lastTrap.scale + tmp.scale
                                                         );
                        if (spikes.length) {
                            let validSpike = spikes.sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))[0];
                            return { path: current.path, spike: validSpike };
                        }

                        closedSet.add(lastTrap);

                        // Get neighbors: traps reachable from lastTrap
                        const neighbors = gameObjects.filter(tmp =>
                                                             tmp.trap && tmp.active && tmp.isTeamObject(player) &&
                                                             UTILS.getDist(tmp, lastTrap, 0, 2) <= lastTrap.scale + tmp.getScale() + 5
                                                            ).sort((a, b) => UTILS.getDist(a, lastTrap, 0, 2) - UTILS.getDist(b, lastTrap, 0, 2));

                        for (let neighbor of neighbors) {
                            // Skip if neighbor is already in the current path to avoid cycles
                            if (current.path.includes(neighbor)) continue;
                            let newCost = current.cost + UTILS.getDist(lastTrap, neighbor, 0, 2);
                            let newPath = current.path.concat(neighbor);
                            let estimate = heuristic(neighbor);
                            // Only add neighbor if it hasn't been processed already
                            if (!closedSet.has(neighbor)) {
                                openList.push({ trap: neighbor, path: newPath, cost: newCost, estimate });
                            }
                        }
                    }
                    return null;
                }

                // Example A* based autoPush function
                function PathAStar() {
                    const result = findTrapPathAStar(near);
                    if (result) {
                        const { path, spike: validSpike } = result;
                        RealPush = true;
                        const pushDistance = 250;
                        const pushAngle = UTILS.getDirect(near, validSpike, 2, 0);
                        const pushDist = UTILS.getDist(near, validSpike, 2, 0);

                        const pos = {
                            x: validSpike.x + pushDistance * Math.cos(pushAngle),
                            y: validSpike.y + pushDistance * Math.sin(pushAngle),
                            x2: validSpike.x + ((pushDist + player.scale * 1.5) * Math.cos(pushAngle)),
                            y2: validSpike.y + ((pushDist + player.scale * 1.5) * Math.sin(pushAngle))
                        };
                        const pos3 = {
                            x2: validSpike.x + ((pushDist + player.scale * 1.5) * Math.cos(pushAngle)),
                            y2: validSpike.y + ((pushDist + player.scale * 1.5) * Math.sin(pushAngle))
                        };
                        const pos4 = {
                            x2: validSpike.x + ((pushDist + player.scale * 1) * Math.cos(pushAngle)),
                            y2: validSpike.y + ((pushDist + player.scale * 1) * Math.sin(pushAngle))
                        };
                        const pos5 = {
                            x: pos4.x2 + Math.cos(30),
                            y: pos4.y2 + Math.sin(30)
                        };

                        my.autoPush = true;
                        if (UTILS.getDist(near, validSpike, 2, 0) <= 100 && near.health != 100 && near.dist2 <= 150) {
                            my.pushLine = Infinity;
                        } else {
                            my.pushLine = {
                                x: validSpike.x + Math.cos(70),
                                y: validSpike.y + Math.sin(70),
                                x2: pos3.x2 + Math.cos(30),
                                y2: pos3.y2 + Math.sin(30)
                            };
                        }
                        if (UTILS.getDist(near, validSpike, 2, 0) <= 100 && near.health != 100 && near.dist2 <= 150) {
                            pathFind.active = false;
                            packet("9", undefined, 1);
                        } else {
                            if (near.dist2 <= 100) {
                                pathFind.active = false;
                                packet("9", UTILS.getDirect(pos, player, 2, 2), 1);
                                retrappable = true;
                            } else {
                                pathFind.active = true;
                                Pathfinder(pos5, 0, 0);
                                retrappable = true;
                            }
                        }
                    } else {
                        if (my.autoPush) {
                            my.autoPush = false;
                            packet("9", undefined, 1);
                            retrappable = false;
                        }
                        RealPush = false;
                    }
                }

                function resetPushState( ){
                    if (my.autoPush) {
                        my.autoPush = false;
                        packet("9", undefined, 1);
                        retrappable = false;
                    }
                    RealPush = false;
                }
                const {
                    sin: V,
                    cos: U,
                    min: j,
                    max: oe,
                    random: t,
                    floor: f,
                    trunc: n,
                    ceil: c,
                    round: H,
                    tan: i,
                    PI: W,
                    sqrt: D,
                    abs: S,
                    pow: re,
                    log: s,
                    LN2: o,
                    atan2: P,
                    SQRT2: r,
                    acos: a,
                    sign: l,
                    hypot: d
                } = Math;
                const ae = W * 2;
                const h = W / 2.6;
                const le = JSON.stringify;
                const E = JSON.parse;
                const ce = 1e3 / 9;
                const u = ce * 2;
                let X=Utils;
                function S4(a, b) {
                    // e.g. UTILS internally uses getDistance
                    return UTILS.getDist(
                        { x: a.x2 ?? a.x, y: a.y2 ?? a.y },
                        { x: b.x2 ?? b.x, y: b.y2 ?? b.y },
                        2, 0
                    );
                }

                // distance + optional trap‑offset
                function se(a, b, mode) {
                    // mode==="player" or "object" just applies a little tweak; drop it if you don’t need
                    const base = S4(a, b);
                    let tweak = 0;
                    if (mode === "player") tweak = -1.8 * 35;
                    else if (mode === "object") tweak = -(b.scale ?? 0);
                    return base + tweak;
                }

                // pure angle between two points
                function B(a, b) {
                    return P(
                        (b.y2 ?? b.y) - (a.y2 ?? a.y),
                        (b.x2 ?? b.x) - (a.x2 ?? a.x)
                    );
                }

                // another raw‑dist alias
                function Dy(a, b) {
                    return d(
                        (a.x2 ?? a.x) - (b.x2 ?? b.x),
                        (a.y2 ?? a.y) - (b.y2 ?? b.y)
                    );
                }

                // projection check used for “nudge back” logic
                function Py(vec, dx, dy) {
                    return (vec.x * dx + vec.y * dy) / (vec.x * dy - vec.y * dx);
                }

                // alias for se
                function vy(a, b) {
                    return se(a, b);
                }

                // simple Manhattan‑like metric (used elsewhere)
                function ky(a, b) {
                    return S(a.x - b.x) + S(a.y - b.y);
                }

                // minimal angular difference [0…π]
                function Ay(a, b) {
                    let diff = S(a - b) % (2 * W);
                    if (diff > W) diff = 2 * W - diff;
                    return diff;
                }
                function te(ownerSid) {
                    if (ownerSid == null) return true;
                    // find the object whose sid matches
                    const ownerObj = gameObjects.find(o => o.sid === ownerSid);
                    if (!ownerObj) return false;
                    // use their isTeamObject logic, passing your player as the reference
                    return ownerObj.isTeamObject(player);
                }

                function autoPushNeedFix() {
                    // 1️⃣ Bail out if we’re not in‑game or not in a trap, or special skin glitch
                    if (
                        !near.inTrap ||
                        !near ||
                        !inGame ||
                        (near && player.skinIndex === 45 && se(player, near) > 90)
                    ) {
                        my.autoPush = false;
                        packet("9", undefined, 1);
                        return;
                    }


                    // 2️⃣ Build the base direction from player→enemy
                    const baseAngle = P(near.y2 - player.y2, near.x2 - player.x2);

                    // 3️⃣ Initialize our “curve” accumulator
                    const curve = {
                        x: U(baseAngle),
                        y: V(baseAngle),
                        objs: []
                    };

                    // 4️⃣ Sort all objects by distance to the enemy
                    const sorted = gameObjects.slice().sort((a, b) => se(a, near) - se(b, near));

                    // 5️⃣ Accumulate each valid spike into our curve vector
                    for (const obj of sorted) {
                        // skip the trap itself
                        if (near.inTrap.sid === obj.sid) continue;

                        // is this a spike inside our trap?
                        const inTrapRange = se(near.inTrap, obj) <=
                              50 + (obj.type === 1 ? obj.scale * 0.55 : obj.scale) + 26;
                        const isSpike = (
                            (te(obj.owner&&obj.owner.sid) && obj.group.name === "spikes") ||
                            (!near.team && obj.group.name === "spikes" && obj.owner.sid !== near.sid) ||
                            (obj.type === 1 && obj.y >= 12000)
                        );
                        const chainedOk = curve.objs.length === 1 &&
                              se(obj, near.inTrap) <= 50 + obj.scale + 22.5 &&
                              se(obj, curve.objs[0]) <= curve.objs[0].scale + obj.scale + 42.5 &&
                              !obj.ignoreCollision;

                        if ((inTrapRange && isSpike) || chainedOk) {
                            // angle and strength toward this spike
                            const ang      = P(obj.y - near.y2, obj.x - near.x2);
                            const strength = 170 - Dy(obj, near);

                            // only accept the first or “gentle turn” spikes
                            if (
                                (!curve.objs.length) ||
                                (
                                    Ay(
                                        P(obj.y - near.inTrap.y, obj.x - near.inTrap.x),
                                        P(curve.objs[0].y - near.inTrap.y, curve.objs[0].x - near.inTrap.x)
                                    ) <= 1.9 &&
                                    se(obj, curve.objs[0]) <= curve.objs[0].scale + obj.scale + 67.5
                                )
                            ) {
                                curve.x += strength * U(ang);
                                curve.y += strength * V(ang);
                                curve.objs.push(obj);
                            }

                            // nudge back toward trap center if needed
                            if (
                                Py(
                                    curve,
                                    near.inTrap.x  - near.x2,
                                    near.inTrap.y  - near.y2
                                ) > 0
                            ) {
                                curve.x += (near.inTrap.x - near.x2) * 2;
                                curve.y += (near.inTrap.y - near.y2) * 2;
                            }
                        }
                    }

                    // 6️⃣ If we actually built a curve vector, solve for the deviation
                    if (d(curve.x, curve.y) > 5) {
                        RealPush=true
                        pathFind.acitve=false
                        my.autoPush=true
                        const distNP = Dy(near, player);           // enemy→player
                        const theta  = Ay(baseAngle, P(curve.y, curve.x)); // angle between base & curve
                        const target = curve.objs[0];              // first spike
                        const inside = se(near, target) <= target.scale + 38.75;
                        const s      = 3600
                        + re(distNP, 2)
                        - (28.5 + (inside ? 71.5 : 0))
                        * distNP
                        * U(theta);
                        const dev = a(
                            (re(distNP, 2) + s - 3600) /
                            (2 * distNP * D(s))
                        );
                        if (dev) {
                            // pick CW vs CCW for the deviation
                            const signum = Math.sign(
                                (near.x2 - player.x2) * curve.y -
                                (near.y2 - player.y2) * curve.x
                            );
                            const finalAngle = baseAngle - signum * dev;

                            // compute exactly where the enemy will exit the trap
                            const exitDist = se(player, near) + 30;
                            const exitPt = {
                                x: player.x2 + exitDist * U(finalAngle),
                                y: player.y2 + exitDist * V(finalAngle)
                            };

                            // collision test (optional)
                            const hasHitSpike = near.hitSpike;
                            const collisionOk = !E3(player, finalAngle, null, null);

                            // alignment for a straight‐line fallback
                            const straightOk = Ay(
                                B(near, target),
                                B(player,   near)
                            ) <= 2;

                            // 7️⃣ Fire if allowed
                            if (
                                (
                                    (!hasHitSpike || (se(player, exitPt) > 100 && hasHitSpike))
                                    && configs.autoPush
                                ) || (
                                    !configs.autoPush && straightOk && collisionOk
                                )
                            ) {
                                packet("9", finalAngle, 1);
                            } else {
                                packet("9", null, 1);
                            }
                        }
                    }
                }








                // helper to reset
                function resetPush() {
                    if (my.autoPush) {
                        my.autoPush = false;
                        packet("9", undefined, 1);
                        retrappable = false;
                    }
                    RealPush    = false;
                    my.pushLine = null;
                }




                added=30

                // any other math fns you need:
                const angleDiff    = (a,b)=>Math.acos(Math.cos(a-b));
                const dot             = (v, x, y) => v.x * x + v.y * y;
                const vectorLength    = v => Math.hypot(v.x, v.y);
                function autoPush2() {
                    // reset helper
                    function reset() {
                        if (my.autoPush) {
                            my.autoPush = false;
                            packet("9", undefined, 1);  // cancel any leftover push input
                            retrappable = false;
                        }
                        RealPush    = false;
                        my.pushLine = null;
                    }

                    // 1️⃣ find your trap
                    const FindTrap = gameObjects
                    .filter(o => o.trap && o.active && o.isTeamObject(player) &&
                            UTILS.getDist(o, near,0,2) <= near.scale + o.getScale() + 5)
                    .sort((a,b) =>
                          UTILS.getDist(a, near,0,2) - UTILS.getDist(b, near,0,2)
                         )[0];
                    if (!FindTrap) return reset();

                    // 2️⃣ pick your spike
                    const FindSpike = gameObjects
                    .filter(o => o.dmg && o.active && o.isTeamObject(player) &&
                            UTILS.getDist(o, FindTrap,0,0) <= near.scale + FindTrap.scale + o.scale)
                    .sort((a,b) =>
                          UTILS.getDist(a, near,0,2) - UTILS.getDist(b, near,0,2)
                         )[0];
                    if (!FindSpike) return reset();

                    RealPush    = true;
                    my.autoPush = true;

                    // 3️⃣ compute straight‐push helpers
                    const pushAngle = UTILS.getDirect(near, FindSpike,2,0);
                    const pushDist  = UTILS.getDist( near, FindSpike,2,0);

                    // build exitPt (pos5)
                    const pos4 = {
                        x2: FindSpike.x + ((pushDist + player.scale*1) * Math.cos(pushAngle)),
                        y2: FindSpike.y + ((pushDist + player.scale*1) * Math.sin(pushAngle))
                    };
                    const exitPt = {
                        x: pos4.x2 + Math.cos(30),
                        y: pos4.y2 + Math.sin(30)
                    };

                    // 4️⃣ compute circle‐entry/exit around the enemy
                    const cx     = near.x2, cy = near.y2;
                    const radius = (near.scale||30) + added;  // your adjustable radius
                    let entryAngle = Math.atan2(player.y2 - cy, player.x2 - cx);
                    let exitAngle  = Math.atan2(exitPt.y   - cy, exitPt.x   - cx);

                    // normalize angles to –π..π
                    const norm = a => (a + 3*Math.PI) % (2*Math.PI) - Math.PI;
                    entryAngle = norm(entryAngle);
                    exitAngle  = norm(exitAngle);

                    // pick the shorter arc direction
                    const diff = (exitAngle - entryAngle + 2*Math.PI) % (2*Math.PI);
                    const ccw  = diff > Math.PI;

                    // exact entryPt on the circle rim
                    const entryPt = {
                        x: cx + radius * Math.cos(entryAngle),
                        y: cy + radius * Math.sin(entryAngle)
                    };

                    // stash for drawing
                    my.pushLine = {
                        start:      { x: player.x2, y: player.y2 },
                        entry:      entryPt,
                        center:     { x: cx,        y: cy        },
                        radius, entryAngle, exitAngle, ccw,
                        exit:       exitPt
                    };

                    // 5️⃣ move vs push
                    const PF_D = 250;  // how close to entryPt to stop
                    const distToEntry = UTILS.getDist(
                        { x: player.x2, y: player.y2 },
                        entryPt, 2, 0
                    );

                    // still too far → walk there
                    if (distToEntry > PF_D) {
                        pathFind.active = true;
                        packet("9", undefined, 1);        // cancel any push input
                        Pathfinder(entryPt, 0, 0);
                        retrappable = false;
                        return;
                    }

                    // we’ve arrived → do curved vs straight shove
                    pathFind.active = false;
                    // compute alignment angle
                    const anglePE = UTILS.getDirect(player, near,    2, 0);
                    const angleES = UTILS.getDirect(near,   FindSpike,2, 0);
                    let raw       = Math.abs(anglePE - angleES);
                    if (raw > Math.PI) raw = 2*Math.PI - raw;
                    const angleDeg = raw * 180 / Math.PI;

                    const ANGLE_THRESH = 40;
                    if (angleDeg <= ANGLE_THRESH) {
                        // straight‐line shove
                        packet("9", pushAngle, 1);
                    } else {
                        // curved shove at exitPt
                        const finalAngle = UTILS.getDirect(near, exitPt, 2, 0);
                        packet("9", finalAngle, 1);
                    }
                    retrappable = true;
                }


                // helper to reset
                function resetPush() {
                    if (my.autoPush) {
                        my.autoPush = false;
                        packet("9", undefined, 1);
                        retrappable = false;
                    }
                    RealPush    = false;
                    my.pushLine = null;
                }


                function autoPushBrok() {
                    const FindTrap = gameObjects
                    .filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= near.scale + tmp.getScale() + 5)
                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))[0];

                    if (FindTrap) {
                        const FindSpike = gameObjects
                        .filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, FindTrap, 0, 0) <= near.scale + FindTrap.scale + tmp.scale)
                        .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))[0];

                        if (FindSpike) {
                            RealPush = true;
                            const pushDistance = 250;
                            const pushAngle = UTILS.getDirect(near, FindSpike, 2, 0);
                            const pushDist = UTILS.getDist(near, FindSpike, 2, 0);

                            const pos = {
                                x: FindSpike.x + pushDistance * Math.cos(pushAngle),
                                y: FindSpike.y + pushDistance * Math.sin(pushAngle),
                                x2: FindSpike.x + ((pushDist + player.scale * 1.5) * Math.cos(pushAngle)),
                                y2: FindSpike.y + ((pushDist + player.scale * 1.5) * Math.sin(pushAngle))
                            };
                            const pos3 = {
                                x2: FindSpike.x + ((pushDist + player.scale * 1.5) * Math.cos(pushAngle)),
                                y2: FindSpike.y + ((pushDist + player.scale * 1.5) * Math.sin(pushAngle))
                            };
                            const pos2 = {
                                x: pos3.x2 + Math.cos(30),
                                y: pos3.y2 + Math.sin(30)
                            };
                            const pos4 = {
                                x2: FindSpike.x + ((pushDist + player.scale * 1) * Math.cos(pushAngle)),
                                y2: FindSpike.y + ((pushDist + player.scale * 1) * Math.sin(pushAngle))
                            };
                            const pos5 = {
                                x: pos4.x2 + Math.cos(30),
                                y: pos4.y2 + Math.sin(30)
                            };
                            my.autoPush = true;
                            if (UTILS.getDist(near, FindSpike, 2, 0) <= 100 && near.health != 100 && near.dist2 <= 150) {
                                my.pushLine = Infinity;
                            } else {
                                my.pushLine = {
                                    x: FindSpike.x + Math.cos(70),
                                    y: FindSpike.y + Math.sin(70),
                                    x2: pos3.x2 + Math.cos(30),
                                    y2: pos3.y2 + Math.sin(30)
                                };
                            }
                            if (UTILS.getDist(near, FindSpike, 2, 0) <= 100 && near.health != 100 && near.dist2 <= 150) {
                                pathFind.active = false;
                                _things.packet("9", undefined, 1);
                                //;lastMoveDir=undefined
                            } else {
                                if (near.dist2 <= 100) {
                                    pathFind.active = false;
                                    _things.packet("9", UTILS.getDirect(pos, player, 2, 2), 1);
                                    //lastMoveDir=UTILS.getDirect(pos, player, 2, 2)
                                    retrappable = true;
                                } else {
                                    pathFind.active = true;
                                    Pathfinder(pos5, 0, 0);
                                    retrappable = true;
                                }
                            }
                        } else {
                            if (my.autoPush) {
                                my.autoPush = false;
                                _things.packet("9", undefined, 1);//;lastMoveDir=undefined
                                retrappable = false;
                            }
                            RealPush = false;
                        }
                    } else {
                        if (my.autoPush) {
                            my.autoPush = false;
                            _things.packet("9", undefined, 1);//;lastMoveDir=undefined
                            retrappable = false;
                        }
                        RealPush = false;
                    }
                }
                // inside your Traps constructor:

                // inside your Traps constructor, replace the previous autoPushVisual with:

                _things.autoPushVisual = () => {return};


                function autoPush() {

                    let trapA=_things.autoPushChain.traps&&(_things.autoPushChain.traps[0])
                    let trapB=_things.autoPushChain.traps&&(_things.autoPushChain.traps[1])

                    let FindTrap = gameObjects
                    .filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= near.scale + tmp.getScale() + 5)
                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))[0]//||_things.autoPushChain.traps&&_things.autoPushChain.traps.length>=2&&(_things.autoPushChain.traps&&(_things.autoPushChain.traps[0]))

                    if (FindTrap) {
                        let chain=(_things.autoPushChain.traps&&(_things.autoPushChain.traps[1])),chaining=false
                        let FindSpike = gameObjects
                        .filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, FindTrap, 0, 0) <= near.scale + FindTrap.scale + tmp.scale)
                        .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))[0]//(chain?(chaining=true,chain):(chaining-false,null));
                        if(!FindSpike&&trapA&&trapB){
                            FindTrap=trapA
                            FindSpike=trapB
                            chaining=true;
                        }
                        if (FindSpike) {
                            RealPush = true;
                            const pushDistance = 250;
                            const pushAngle = UTILS.getDirect(near, FindSpike, 2, 0);
                            const pushDist = UTILS.getDist(near, FindSpike, 2, 0);

                            const pos = {
                                x: FindSpike.x + pushDistance * Math.cos(pushAngle),
                                y: FindSpike.y + pushDistance * Math.sin(pushAngle),
                                x2: FindSpike.x + ((pushDist + player.scale * 1.5) * Math.cos(pushAngle)),
                                y2: FindSpike.y + ((pushDist + player.scale * 1.5) * Math.sin(pushAngle))
                            };
                            const pos3 = {
                                x2: FindSpike.x + ((pushDist + player.scale * 1.5) * Math.cos(pushAngle)),
                                y2: FindSpike.y + ((pushDist + player.scale * 1.5) * Math.sin(pushAngle))
                            };
                            const pos2 = {
                                x: pos3.x2 + Math.cos(30),
                                y: pos3.y2 + Math.sin(30)
                            };
                            const pos4 = {
                                x2: FindSpike.x + ((pushDist + player.scale * 1) * Math.cos(pushAngle)),
                                y2: FindSpike.y + ((pushDist + player.scale * 1) * Math.sin(pushAngle))
                            };
                            const pos5 = {
                                x: pos4.x2 + Math.cos(30),
                                y: pos4.y2 + Math.sin(30)
                            };
                            my.autoPush = true;

                            if (UTILS.getDist(near, FindSpike, 2, 0) <= 100 && near.health != 100 && near.dist2 <= 150) {
                                my.pushLine = Infinity;
                            } else {
                                my.pushLine = {
                                    x: FindSpike.x + Math.cos(70),
                                    y: FindSpike.y + Math.sin(70),
                                    x2: pos3.x2 + Math.cos(30),
                                    y2: pos3.y2 + Math.sin(30)
                                };
                            }
                            if (!chaining&&UTILS.getDist(near, FindSpike, 2, 0) <= 100 && near.health != 100 && near.dist2 <= 150) {
                                pathFind.active = false;
                                packet("9", undefined, 1);
                                clicks.left=1
                            } else {
                                if (near.dist2 <= 100) {
                                    pathFind.active = false;
                                    packet("9", UTILS.getDirect(pos, player, 2, 2), 1);
                                    retrappable = true;
                                    clicks.left=0
                                } else {
                                    pathFind.active = true;
                                    Pathfinder(pos5, 0, 0);
                                    retrappable = true;
                                }
                            }
                        }
                        else {
                            if (my.autoPush) {
                                my.autoPush = false;
                                packet("9", undefined, 1);
                                retrappable = false;
                            }
                            RealPush = false;
                        }
                    } else {
                        if (my.autoPush) {
                            my.autoPush = false;
                            packet("9", undefined, 1);
                            retrappable = false;
                        }
                        /*if(my.autoPush2&&(typeof 0 == typeof _things.autoPushChain.moveDir_)){
                        _things.autoPushChain.moveDir_
                        toMove=["9",_things.autoPushChain.moveDir_, 1]
                        packet("9", _things.autoPushChain.moveDir_, 1)
                        lastMoveDir=_things.autoPushChain.moveDir_
                        packet('9',_things.autoPushChain.moveDir_)
                    }*/
                        RealPush = false;
                    }
                }
                /*function knockBackPredict() {
                //thank you OE2375
                let KBIndc = {
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 0,
                    instax: 0,
                    instay: 0,
                    turretx: 0,
                    turrety: 0
                }
                let nea = Math.atan2(near.y2 - player.y2, near.x2 - player.x2);
                let minDist = Infinity;
                let neIT = gameObjects.filter(e => e.name == "pit trap" && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= e.getScale() + player.scale + 5).sort((a, b) => {
                    return UTILS.getDist(a, near, 0, 2) - UTILS.UTILS.getDist(b, near, 0, 2);
                })[0];
                if (near.dist2 - player.scale * 1.8 <= items.weapons[player.weapons[0]].range && !neIT) {
                    for (let tmp of gameObjects) {
                        let scope = KBIndc;
                        if (tmp.dmg && tmp.active && tmp.isTeamObject(player)) {
                            let primaryScaling = (items.weapons[player.weapons[0]].knock||0) * items.weapons[player.weapons[0]].range + player.scale * 2
                            let secondaryScaling = ![undefined, 9, 12, 13, 15].includes(player.weapons[1]) ? (items.weapons[player.weapons[1]].knock||0) * items.weapons[player.weapons[1]].range + player.scale*2 - 10 : player.weapons[1] != undefined ? 60 : 0
                            let instaStuff = primaryScaling + secondaryScaling
                            let turretStuff = player.reloads[53] == 0 ? primaryScaling + secondaryScaling + 75 : instaStuff
                            let primaryX = near.x2 + primaryScaling * Math.cos(nea)
                            let primaryY = near.y2 + primaryScaling * Math.sin(nea)
                            let secondaryX = near.x2 + secondaryScaling * Math.cos(nea)
                            let secondaryY = near.y2 + secondaryScaling * Math.sin(nea)
                            let instaX = near.x2 + instaStuff * Math.cos(nea)
                            let instaY = near.y2 + instaStuff * Math.sin(nea)
                            let turretX = near.x2 + turretStuff * Math.cos(nea)
                            let turretY = near.y2 + turretStuff * Math.sin(nea)
                            scope.x0 = primaryX, scope.y0 = primaryY
                            scope.x1 = secondaryX, scope.y1 = secondaryY
                            scope.instax = instaX, scope.instay = instaY
                            scope.turretx = turretX, scope.turrety = turretY
                            if ((UTILS.getDist({ x: primaryX, y: primaryY }, tmp, 0, 0) <= tmp.scale + player.scale) && player.reloads[player.weapons[0]] == 0 && !traps.inTrap) {
                                tracker.draw2.active = true
                                tracker.draw2.x = tmp.x
                                tracker.draw2.y = tmp.y
                                tracker.draw2.scale = tmp.scale
                                return "insta them"
                            }
                            if ((UTILS.getDist({ x: instaX, y: instaY }, tmp, 0, 0) <= tmp.scale + player.scale) && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && !traps.inTrap) {
                                return "insta them"
                                tracker.draw2.active = true
                                tracker.draw2.x = tmp.x
                                tracker.draw2.y = tmp.y
                                tracker.draw2.scale = tmp.scale
                            }
                        }
                    }
                } else {
                    tracker.draw2.active = false
                    KBIndc = {
                        x0: 0,
                        y0: 0,
                        x1: 0,
                        y1: 0,
                        instax: 0,
                        instay: 0,
                        turretx: 0,
                        turrety: 0
                    }
                }
                return false
            }*/
                let barbKbPredict = false;
                function getBreakOffset(botPos, spikePos, offsetDist) {
                    const ang = Math.atan2(spikePos.y - botPos.y, spikePos.x - botPos.x);
                    return {
                        x: spikePos.x - Math.cos(ang) * offsetDist,
                        y: spikePos.y - Math.sin(ang) * offsetDist
                    };
                }

                function antiKnockBackPredict() {
                    const enemy = _things.enemy.enemy;
                    if (!enemy) return null;

                    const primaryWeap   = items.weapons[enemy.primaryIndex]   || { range: 0, knock: 0 };
                    const secondaryWeap = items.weapons[enemy.secondaryIndex] || { range: 0, knock: 0 };

                    // angle & unit vector from enemy → player
                    const nea  = Math.atan2(player.y2 - enemy.y2, player.x2 - enemy.x2);
                    const dirX = Math.cos(nea), dirY = Math.sin(nea);

                    // quick pit-trap block check
                    const blockingTrap = gameObjects
                    .filter(e =>
                            e.name === "pit trap" &&
                            e.active &&
                            e.isTeamObject(enemy) &&
                            UTILS.getDist(e, player, 0, 2) <= e.getScale() + enemy.scale + 5
                           )
                    .sort((a, b) =>
                          UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2)
                         )[0];
                    if (player.dist2 - enemy.scale * 1.8 > primaryWeap.range || blockingTrap)
                        return null;

                    for (let tmp of gameObjects) {
                        if (!tmp.dmg || !tmp.active || tmp.isTeamObject(player)) continue;

                        // 🔒 NEW: only consider spikes/traps that lie in front of you
                        const toTmpX = tmp.x - player.x2;
                        const toTmpY = tmp.y - player.y2;
                        // dot > 0 means tmp is roughly in the knockback dir
                        if (dirX * toTmpX + dirY * toTmpY <= 0) continue;

                        // compute knockback distances
                        const primaryScaling = primaryWeap.knock * primaryWeap.range + enemy.scale*2;
                        let secondaryScaling = 0;
                        if (enemy.secondaryIndex != null) {
                            const si = enemy.secondaryIndex;
                            secondaryScaling = [9,12,13,15].includes(si)
                                ? 60
                            : secondaryWeap.knock * secondaryWeap.range + enemy.scale*2 - 10;
                        }
                        const instaStuff = primaryScaling + secondaryScaling;
                        const barbKnock  = 235;

                        // predicted positions
                        const pX = player.x2 + primaryScaling * dirX;
                        const pY = player.y2 + primaryScaling * dirY;
                        const iX = player.x2 + instaStuff     * dirX;
                        const iY = player.y2 + instaStuff     * dirY;

                        const reloads         = enemy.reloads || {};
                        const readyPrimary   = reloads[enemy.primaryIndex]   === 0;
                        const readySecondary = reloads[enemy.secondaryIndex] === 0;

                        // 1) primary hit
                        if (
                            readyPrimary &&
                            !traps.inTrap &&
                            UTILS.getDist({ x:pX, y:pY }, tmp, 0, 0) <= tmp.scale + enemy.scale
                        ) return { x: tmp.x, y: tmp.y, scale: tmp.scale };

                        // 2) insta-kill
                        if (
                            readyPrimary && readySecondary && !traps.inTrap &&
                            UTILS.getDist({ x:iX, y:iY }, tmp, 0, 0) <= tmp.scale + enemy.scale
                        ) return { x: tmp.x, y: tmp.y, scale: tmp.scale };

                        // 3) over-knock
                        const d2 = UTILS.getDist({ x:iX, y:iY }, tmp, 0,0);
                        if (
                            readyPrimary && readySecondary && !traps.inTrap &&
                            d2 > tmp.scale + enemy.scale &&
                            d2 <= tmp.scale + enemy.scale + barbKnock
                        ) return { x: tmp.x, y: tmp.y, scale: tmp.scale };
                    }

                    return null;
                }
                function willDieIfMove() {
                    const enemy = _things.enemy.enemy;
                    if (!enemy || !player || !player.inGame) return false;

                    const primaryWeap = items.weapons[enemy.primaryIndex] || { range: 0, knock: 0 };

                    const nea = Math.atan2(player.y3 - enemy.y2, player.x3 - enemy.x2); // use predicted coords
                    const dirX = Math.cos(nea), dirY = Math.sin(nea);

                    const predictedKnockback = primaryWeap.knock * primaryWeap.range + enemy.scale * 2;

                    // predict knockback position based on new direction
                    const predictedX = player.x3 + predictedKnockback * dirX;
                    const predictedY = player.y3 + predictedKnockback * dirY;

                    for (let obj of gameObjects) {
                        if (!obj.active || obj.isTeamObject(player) || !obj.dmg) continue;

                        // Ensure object lies in knockback path
                        const toTmpX = obj.x - player.x3;
                        const toTmpY = obj.y - player.y3;
                        if (dirX * toTmpX + dirY * toTmpY <= 0) continue;

                        const dist = UTILS.getDist({ x: predictedX, y: predictedY }, obj, 0, 0);
                        if (dist <= obj.scale + enemy.scale) {
                            return true;
                        }
                    }

                    return false;
                }


                // GLOBAL VARS
                let enemyP = '2'; // can be '1','2','3','4','5'
                let playerP = '5'; // same

                function knockBackPredictEnemyToPlayerW(enemyP,playerP) {
                    const enemyObj=_things.enemy.enemy
                    const playerObj=player
                    if(!_things.enemy.enemy)return;
                    let KBIndc = {
                        x0: 0, y0: 0, x1: 0, y1: 0,
                        instax: 0, instay: 0, turretx: 0, turrety: 0
                    };

                    // Pulls the right coordinates dynamically
                    let enemyX = enemyObj['x'+enemyP], enemyY = enemyObj['y'+enemyP];
                    let playerX = playerObj['x'+playerP], playerY = playerObj['y'+playerP];

                    let nea = Math.atan2(playerY - enemyY, playerX - enemyX);

                    let neIT = gameObjects
                    .filter(e =>
                            e.name == "pit trap" &&
                            e.active &&
                            e.isTeamObject(enemyObj) &&
                            UTILS.getDist(e, playerObj, 0, 2) <= e.getScale() + enemyObj.scale + 5
                           )
                    .sort((a, b) =>
                          UTILS.getDist(a, playerObj, 0, 2) - UTILS.getDist(b, playerObj, 0, 2)
                         )[0];

                    // Check: enemy is in range, no blocking pit trap
                    let primaryWep = items.weapons[enemyObj.primaryIndex] || {range: 0, knock: 0, dmg: 0};
                    let canReach = (enemyObj['dist'+enemyP] - enemyObj.scale * 1.8 <= primaryWep.range && !neIT);

                    if (canReach) {
                        for (let tmp of gameObjects) {
                            if (tmp.dmg && tmp.active && tmp.isTeamObject(enemyObj)) {
                                let secondaryWep = items.weapons[enemyObj.secondaryIndex] || {knock:0, range:0};
                                let primaryScaling   = (primaryWep.knock || 0) * primaryWep.range + enemyObj.scale * 2;
                                let secondaryScaling = ![undefined,9,12,13,15].includes(enemyObj.secondaryIndex)
                                ? (secondaryWep.knock||0) * secondaryWep.range + enemyObj.scale*2 - 10
                                : enemyObj.secondaryIndex !== undefined ? 60 : 0;

                                let instaStuff = primaryScaling + secondaryScaling;
                                let turretStuff = enemyObj.reloads[53] == 0 ? primaryScaling + secondaryScaling + 75 : instaStuff;

                                // Calculate predicted hits based on the dynamic coordinates
                                let primaryX   = enemyX + primaryScaling * Math.cos(nea);
                                let primaryY   = enemyY + primaryScaling * Math.sin(nea);
                                let secondaryX = enemyX + secondaryScaling * Math.cos(nea);
                                let secondaryY = enemyY + secondaryScaling * Math.sin(nea);
                                let instaX     = enemyX + instaStuff * Math.cos(nea);
                                let instaY     = enemyY + instaStuff * Math.sin(nea);
                                let turretX    = enemyX + turretStuff * Math.cos(nea);
                                let turretY    = enemyY + turretStuff * Math.sin(nea);

                                let barbarianKnockback = 235;

                                KBIndc.x0 = primaryX; KBIndc.y0 = primaryY;
                                KBIndc.x1 = secondaryX; KBIndc.y1 = secondaryY;
                                KBIndc.instax = instaX; KBIndc.instay = instaY;
                                KBIndc.turretx = turretX; KBIndc.turrety = turretY;

                                // Insert your death check here
                                let willDie = true;
                                // For example:
                                // willDie = (playerObj.hp <= primaryWep.dmg);
                                if(enemyObj.reloads[enemyObj.primaryIndex] == 0){
                                    //console.log((UTILS.getDist({x: primaryX, y: primaryY}, tmp, 0, 0) <= tmp.scale + enemyObj.scale))
                                    return (UTILS.getDist({x: primaryX, y: primaryY}, tmp, 0, 0) <= tmp.scale + enemyObj.scale)&&({ x: primaryX, y: primaryY })
                                }
                                if (
                                    (UTILS.getDist({x: primaryX, y: primaryY}, tmp, 0, 0) <= tmp.scale + enemyObj.scale)
                                    && enemyObj.reloads[enemyObj.primaryIndex] == 0
                                    && !traps.inTrap
                                    && willDie
                                ) {
                                    return { x: primaryX, y: primaryY };
                                }
                            }
                        }
                    }
                    return false;
                }
                function knockBackPredictEnemyToPlayer(enemyP, playerP) {
                    const enemyObj = _things.enemy.enemy;
                    const playerObj = player;
                    if (!enemyObj) return false;

                    let KBIndc = {
                        x0: 0, y0: 0, x1: 0, y1: 0,
                        instax: 0, instay: 0, turretx: 0, turrety: 0
                    };

                    // Dynamic coordinates
                    let enemyX = enemyObj['x' + enemyP], enemyY = enemyObj['y' + enemyP];
                    let playerX = playerObj['x' + playerP], playerY = playerObj['y' + playerP];
                    let nea = Math.atan2(playerY - enemyY, playerX - enemyX);

                    // Find closest trap (optional, you can use this for extra visual hints)
                    let neIT = gameObjects
                    .filter(e =>
                            e.name == "pit trap" &&
                            e.active &&
                            e.isTeamObject(enemyObj) &&
                            UTILS.getDist(e, playerObj, 0, 2) <= e.getScale() + enemyObj.scale + 5
                           )
                    .sort((a, b) =>
                          UTILS.getDist(a, playerObj, 0, 2) - UTILS.getDist(b, playerObj, 0, 2)
                         )[0];

                    let primaryWep = items.weapons[enemyObj.primaryIndex] || { range: 0, knock: 0, dmg: 0 };
                    let canReach = (enemyObj['dist' + enemyP] - enemyObj.scale * 1.8 <= primaryWep.range && !neIT);

                    if (canReach) {
                        for (let tmp of gameObjects) {
                            if (tmp.dmg && tmp.active && tmp.isTeamObject(enemyObj)) {
                                let secondaryWep = items.weapons[enemyObj.secondaryIndex] || { knock: 0, range: 0 };
                                let primaryScaling = (primaryWep.knock || 0) * primaryWep.range + enemyObj.scale * 2;
                                let secondaryScaling = ![undefined, 9, 12, 13, 15].includes(enemyObj.secondaryIndex)
                                ? (secondaryWep.knock || 0) * secondaryWep.range + enemyObj.scale * 2 - 10
                                : enemyObj.secondaryIndex !== undefined ? 60 : 0;

                                let instaStuff = primaryScaling + secondaryScaling;
                                let turretStuff = enemyObj.reloads[53] == 0 ? primaryScaling + secondaryScaling + 75 : instaStuff;

                                // Calculate predicted coords
                                let primaryX = enemyX + primaryScaling * Math.cos(nea);
                                let primaryY = enemyY + primaryScaling * Math.sin(nea);
                                let secondaryX = enemyX + secondaryScaling * Math.cos(nea);
                                let secondaryY = enemyY + secondaryScaling * Math.sin(nea);
                                let instaX = enemyX + instaStuff * Math.cos(nea);
                                let instaY = enemyY + instaStuff * Math.sin(nea);
                                let turretX = enemyX + turretStuff * Math.cos(nea);
                                let turretY = enemyY + turretStuff * Math.sin(nea);

                                // Save all knockback/insta hit positions
                                KBIndc.x0 = primaryX; KBIndc.y0 = primaryY;
                                KBIndc.x1 = secondaryX; KBIndc.y1 = secondaryY;
                                KBIndc.instax = instaX; KBIndc.instay = instaY;
                                KBIndc.turretx = turretX; KBIndc.turrety = turretY;

                                // Check lethal
                                let willDie = false;
                                let lethalObj = null;
                                // Try main knockback spot (edit as needed for your game, can check others too)
                                if (
                                    (UTILS.getDist({ x: primaryX, y: primaryY }, tmp, 0, 0) <= tmp.scale + enemyObj.scale)
                                    && enemyObj.reloads[enemyObj.primaryIndex] == 0
                                    && !traps.inTrap
                                ) {
                                    willDie = true;
                                    lethalObj = tmp;
                                }

                                // You can also check instaX/instaY etc for multi-type attacks!
                                // Add more conditions if your game needs them

                                if (willDie) {
                                    return {
                                        willDie: true,
                                        lethalObj,
                                        enemyObj,
                                        KBIndc,
                                        hitPos: { x: primaryX, y: primaryY }, // or use instaX/instaY if that's the lethal
                                        // Add more sauce here as needed (e.g. which weapon)
                                    };
                                }
                            }
                        }
                    }
                    return false;
                }

                function knockBackPredict() {
                    //thank you OE2375
                    let KBIndc = {
                        x0: 0,
                        y0: 0,
                        x1: 0,
                        y1: 0,
                        instax: 0,
                        instay: 0,
                        turretx: 0,
                        turrety: 0
                    }
                    let nea = Math.atan2(near.y2 - player.y2, near.x2 - player.x2);
                    let minDist = Infinity;
                    let neIT = gameObjects.filter(e => e.name == "pit trap" && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= e.getScale() + player.scale + 5).sort((a, b) => {
                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                    })[0];
                    if (near.dist2 - player.scale * 1.8 <= items.weapons[player.weapons[0]].range && !neIT) {
                        for (let tmp of gameObjects) {
                            let scope = KBIndc;
                            if (tmp.dmg && tmp.active && tmp.isTeamObject(player)) {
                                let primaryScaling = (items.weapons[player.weapons[0]].knock||0) * items.weapons[player.weapons[0]].range + player.scale * 2
                                let secondaryScaling = ![undefined, 9, 12, 13, 15].includes(player.weapons[1]) ? (items.weapons[player.weapons[1]].knock||0) * items.weapons[player.weapons[1]].range + player.scale*2 - 10 : player.weapons[1] != undefined ? 60 : 0
                                let instaStuff = primaryScaling + secondaryScaling
                                let turretStuff = player.reloads[53] == 0 ? primaryScaling + secondaryScaling + 75 : instaStuff
                                let primaryX = near.x2 + primaryScaling * Math.cos(nea)
                                let primaryY = near.y2 + primaryScaling * Math.sin(nea)
                                let secondaryX = near.x2 + secondaryScaling * Math.cos(nea)
                                let secondaryY = near.y2 + secondaryScaling * Math.sin(nea)
                                let instaX = near.x2 + instaStuff * Math.cos(nea)
                                let instaY = near.y2 + instaStuff * Math.sin(nea)
                                let turretX = near.x2 + turretStuff * Math.cos(nea)
                                let turretY = near.y2 + turretStuff * Math.sin(nea)
                                let barbarianKnockback = 235;
                                scope.x0 = primaryX, scope.y0 = primaryY
                                scope.x1 = secondaryX, scope.y1 = secondaryY
                                scope.instax = instaX, scope.instay = instaY
                                scope.turretx = turretX, scope.turrety = turretY
                                if ((UTILS.getDist({ x: primaryX, y: primaryY }, tmp, 0, 0) <= tmp.scale + player.scale) && player.reloads[player.weapons[0]] == 0 && !traps.inTrap) {
                                    tracker.draw2.active = true
                                    tracker.draw2.x = tmp.x
                                    tracker.draw2.y = tmp.y
                                    tracker.draw2.scale = tmp.scale
                                    return "insta them"
                                }
                                if ((UTILS.getDist({ x: instaX, y: instaY }, tmp, 0, 0) <= tmp.scale + player.scale) && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && !traps.inTrap) {
                                    tracker.draw2.active = true
                                    tracker.draw2.x = tmp.x
                                    tracker.draw2.y = tmp.y
                                    tracker.draw2.scale = tmp.scale
                                    return "insta them"
                                }
                                if ((UTILS.getDist({ x: instaX, y: instaY }, tmp, 0, 0) > tmp.scale + player.scale && UTILS.getDist({ x: instaX, y: instaY }, tmp, 0, 0) <= tmp.scale + player.scale + barbarianKnockback) && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && !traps.inTrap) {
                                    buyEquip(26, 0);
                                    barbKbPredict = true;
                                    tracker.draw2.active = true
                                    tracker.draw2.x = tmp.x
                                    tracker.draw2.y = tmp.y
                                    tracker.draw2.scale = tmp.scale
                                }
                            }
                        }
                    } else {
                        tracker.draw2.active = false
                        barbKbPredict = false;
                        KBIndc = {
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            instax: 0,
                            instay: 0,
                            turretx: 0,
                            turrety: 0
                        }
                    }
                    return false
                }
                // ADD DEAD PLAYER:
                function addDeadPlayer(tmpObj) {
                    deadPlayers.push(new DeadPlayer(tmpObj.x, tmpObj.y, tmpObj.dir, tmpObj.buildIndex, tmpObj.weaponIndex, tmpObj.weaponVariant, tmpObj.skinColor, tmpObj.scale, tmpObj.name));
                }

                /** APPLY SOCKET CODES */

                // SET INIT DATA:
                function setInitData(data) {
                    alliances = data.teams;
                }

                // SETUP GAME:
                function setupGame(yourSID) {
                    keys = {};
                    macro = {};
                    playerSID = yourSID;
                    attackState = 0;
                    inGame = true;
                    packet("F", 0, getAttackDir(), 1);
                    my.ageInsta = true;
                    if (firstSetup) {
                        firstSetup = false;
                        gameObjects.length = 0;
                        liztobj.length = 0;
                    }
                }

                // ADD NEW PLAYER:
                function addPlayer(data, isYou) {
                    let tmpPlayer = findPlayerByID(data[0]);
                    if (!tmpPlayer) {
                        tmpPlayer = new Player(data[0], data[1], config, UTILS, projectileManager,
                                               objectManager, players, ais, items, hats, accessories);
                        players.push(tmpPlayer);
                        if (data[1] != playerSID) {
                            addMenuChText("Game", `Encountered ${data[2]} {${data[1]}}.`, "lightblue");
                        }
                    } else {
                        if (data[1] != playerSID) {
                            addMenuChText("Game", `Encountered ${data[2]} {${data[1]}} times.`, "lightblue");
                        }
                    }
                    tmpPlayer.spawn(isYou ? true : null);
                    tmpPlayer.visible = false;
                    tmpPlayer.oldPos = {
                        x2: undefined,
                        y2: undefined
                    };
                    tmpPlayer.x2 = undefined;
                    tmpPlayer.y2 = undefined;
                    tmpPlayer.x3 = undefined;
                    tmpPlayer.y3 = undefined;
                    tmpPlayer.setData(data);
                    if (isYou) {
                        if (!player) {
                            unsafeWindow.prepareUI(tmpPlayer);
                        }
                        player = tmpPlayer;
                        camX = player.x;
                        camY = player.y;
                        my.lastDir = 0;
                        updateItems();
                        updateAge();
                        updateItemCountDisplay();
                        for (let i = 0; i < 5; i++) {
                            petals.push(new Petal(player.x, player.y));
                        }
                        if (player.skins[7]) {
                            my.reSync = true;
                        }
                    }
                }

                // REMOVE PLAYER:
                function removePlayer(id) {
                    for (let i = 0; i < players.length; i++) {
                        if (players[i].id == id) {
                            addMenuChText("Game", players[i].name + " left the game", "yellow");
                            players.splice(i, 1);
                            break;
                        }
                    }
                }

                // UPDATE HEALTH:
                function updateHealth(sid, value) {
                    tmpObj = findPlayerBySID(sid);
                    if (tmpObj) {
                        tmpObj.oldHealth = tmpObj.health;
                        tmpObj.health = value;
                        tmpObj.judgeShame();
                        if (tmpObj.oldHealth > tmpObj.health) {
                            tmpObj.damaged = tmpObj.oldHealth - tmpObj.health;
                            advHeal.push([sid, value, tmpObj.damaged]);
                        } else {
                        }
                        if (tmpObj.health <= 0) {
                            bots.forEach((hmm) => {
                                hmm.whyDie = tmpObj.name;
                            });
                        }
                    }
                }

                // KILL PLAYER:
                function killPlayer() {
                    petals = [];
                    inGame = false;
                    lastDeath = {
                        x: player.x,
                        y: player.y,
                    };
                    /*menuCardHolder.style.display = "block";
                mainMenu.style.display = "block";
                diedText.style.display = "none";*/
                    if (configs.autoRespawn) {
                        try{
                            getEl("ot-sdk-btn-floating").style.display = "none";
                        }catch{}
                        packet("M", {
                            name: lastsp[0],
                            moofoll: lastsp[1],
                            skin: lastsp[2]
                        });
                    }
                }

                // UPDATE PLAYER ITEM VALUES:
                function updateItemCounts(index, value) {
                    if (player) {
                        player.itemCounts[index] = value;
                        updateItemCountDisplay(index);
                    }
                }

                // UPDATE AGE:
                function updateAge(xp, mxp, age) {
                    //console.log(xp,mxp,age)
                    if (xp != undefined)
                        player.XP = xp;
                    if (mxp != undefined)
                        player.maxXP = mxp;
                    if (age != undefined)
                        player.age = age;
                }

                // UPDATE UPGRADES:
                function updateUpgrades(points, age) {
                    player.upgradePoints = points;
                    player.upgrAge = age;
                    items2[age - 1]&&(_things.packet('H', items2[age - 1]))
                    if (points > 0) {
                        tmpList.length = 0;
                        UTILS.removeAllChildren(upgradeHolder);
                        for (let i = 0; i < items.weapons.length; ++i) {
                            if (items.weapons[i].age == age && (testMode || items.weapons[i].pre == undefined || player.weapons.indexOf(items.weapons[i].pre) >= 0)) {
                                let e = UTILS.generateElement({
                                    id: "upgradeItem" + i,
                                    class: "actionBarItem",
                                    onmouseout: function () {
                                        showItemInfo();
                                    },
                                    parent: upgradeHolder
                                });
                                e.style.backgroundImage = getEl("actionBarItem" + i).style.backgroundImage;
                                tmpList.push(i);
                            }
                        }
                        for (let i = 0; i < items.list.length; ++i) {
                            if (items.list[i].age == age && (testMode || items.list[i].pre == undefined || player.items.indexOf(items.list[i].pre) >= 0)) {
                                let tmpI = (items.weapons.length + i);
                                let e = UTILS.generateElement({
                                    id: "upgradeItem" + tmpI,
                                    class: "actionBarItem",
                                    onmouseout: function () {
                                        showItemInfo();
                                    },
                                    parent: upgradeHolder
                                });
                                e.style.backgroundImage = getEl("actionBarItem" + tmpI).style.backgroundImage;
                                tmpList.push(tmpI);
                            }
                        }
                        for (let i = 0; i < tmpList.length; i++) {
                            (function (i) {
                                let tmpItem = getEl('upgradeItem' + i);
                                tmpItem.onmouseover = function () {
                                    if (items.weapons[i]) {
                                        showItemInfo(items.weapons[i], true);
                                    } else {
                                        showItemInfo(items.list[i - items.weapons.length]);
                                    }
                                };
                                tmpItem.onclick = UTILS.checkTrusted(function () {
                                    packet("H", i);
                                });
                                UTILS.hookTouchEvents(tmpItem);
                            })(tmpList[i]);
                        }
                        if (tmpList.length) {
                            upgradeHolder.style.display = "block";
                            upgradeCounter.style.display = "block";
                            upgradeCounter.innerHTML = "SELECT ITEMS (" + points + ")";
                        } else {
                            upgradeHolder.style.display = "none";
                            upgradeCounter.style.display = "none";
                            showItemInfo();
                        }
                    } else {
                        upgradeHolder.style.display = "none";
                        upgradeCounter.style.display = "none";
                        showItemInfo();
                    }
                }

                // KILL OBJECT:
                function killObject(sid) {
                    let findObj = findObjectBySid(sid);
                    objectManager.disableBySid(sid);
                    if (near.dist2 <= items.weapons[5].range + near.scale * 1.8) {
                        healer();
                        buyEquip(6,0);
                        addMenuChText("[Game]", "AntiSpikeTick", "red");
                        antispiketicked = true;
                        setTimeout(()=>{
                            antispiketicked = false;
                        },100);
                    }
                    // spiektick 24/7
                    let objDist = Math.hypot(findObj.y-player.y2, findObj.x-player.x2);
                    let nearTrap = gameObjects.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= (near.scale + tmp.getScale() + 5));
                    let spike = gameObjects.find(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) < 87 && !nearTrap);
                    let placeObj = spike ? 4 : 2;
                    if (objDist <= 150 && near.dist2 <= 168 && tmpObj != player && placeObj != 4&&!isnerf) {
                        instaC.canSpikeTick = true;
                        instaC.syncHit = true;
                    }

                    if (player) {
                        for (let i = 0; i < breakObjects.length; i++) {
                            if (breakObjects[i].sid == sid) {
                                breakObjects.splice(i, 1);
                                break;
                            }
                        }
                        if (!player.canSee(findObj)) {
                            breakTrackers.push({x: findObj.x, y: findObj.y});
                        }
                        if (breakTrackers.length > 8) {
                            breakTrackers.shift();
                        }
                        traps.replacer(findObj);
                    }
                }

                // KILL ALL OBJECTS BY A PLAYER:
                function killObjects(sid) {
                    if (player) objectManager.removeAllItems(sid);
                }
                function isAlly(sid, pSid) {
                    tmpObj = findPlayerBySID(sid);
                    if (!tmpObj) {
                        return;
                    }
                    if (pSid) {
                        let pObj = findPlayerBySID(pSid);
                        if (!pObj) {
                            return;
                        }
                        if (pObj.sid == sid) {
                            return true;
                        } else if (tmpObj.team) {
                            return tmpObj.team === pObj.team ? true : false;
                        } else {
                            return false;
                        }
                    }
                    if (!tmpObj) {
                        return;
                    }
                    if (player.sid == sid) {
                        return true;
                    } else if (tmpObj.team) {
                        return tmpObj.team === player.team ? true : false;
                    } else {
                        return false;
                    }
                }
                function fgdo(a, b) {
                    return Math.sqrt(Math.pow((b.y - a.y), 2) + Math.pow((b.x - a.x), 2));
                }
                let lastPos = { x: 0, y: 0 };
                let mills = {
                    x: undefined,
                    y: undefined,
                    size: function(size) {
                        return size * 1.45;
                    },
                    dist: function(size) {
                        return size * 1.8;
                    },
                    active: config.isSandbox ? false : false,
                    count: 0,
                };
                let laztPoz = {};
                let oldXY = {
                    x: undefined,
                    y: undefined,
                };
                // UPDATE PLAYER DATA:
                const safeWalk = () => {
                    let found = false;
                    let spik = null;
                    let spikenear = false;
                    my.autoPush = false;
                    pathFind.active = false;
                    pathFind.chaseNear = false;
                    const buildings = gameObjects.sort((a, b) => Math.hypot(player.y2 - a.y, player.x2 - a.x) - Math.hypot(player.y2 - b.y, player.x2 - b.x));

                    const spikes = buildings.filter((obj) => {
                        return (
                            (obj.name === "spikes" || obj.name === "greater spikes" || obj.name === "spinning spikes" || obj.name === "poison spikes") &&
                            !isAlly(obj.owner.sid) &&
                            obj.owner.sid !== player.sid &&
                            fgdo(player, obj) < 250 &&
                            obj.active
                        );
                    });

                    const newPos = {
                        x: player.x2 + (player.x2 - lastPos.x) * 1.2 + Math.cos(player.moveDir) * 50,
                        y: player.y2 + (player.y2 - lastPos.y) * 1.2 + Math.sin(player.moveDir) * 50,
                    };

                    for (let i = 0; i < spikes.length; i++) {
                        if (fgdo(spikes[i], newPos) < spikes[i].scale + player.scale + 5 && !traps.inTrap) {
                            found = true;
                            spikenear = false;
                            spik = spikes[i];
                            break;
                        }
                    }
                    for (let i = 0; i < spikes.length; i++) {
                        if (fgdo(spikes[i], player) < spikes[i].scale + player.scale + 35 && traps.inTrap) {
                            spikenear = true;
                            found = false;
                            spik = spikes[i];
                            break;
                        }
                    }

                    const aimSpike = () => {
                        packet("D", Math.atan2(spik.y - player.y2, spik.x - player.x2));
                    }
                    const stopOnCollisionAndBreakObject = () => {
                        my.autoPush = false;
                        /*pathFind.active = false;
                    pathFind.chaseNear = false;
                    selectWeapon(player.weapons[player.weapons[1] === 10 ? 1 : 0])
                    sendAutoGather();
                    buyEquip(40, 0);
                    aimSpike();
                    my.waitHit = 1;
                    game.tickBase(() => {
                        sendAutoGather();
                        my.waitHit = 0;
                    }, 1);*/
                    }

                    if (found && !traps.inTrap && !phantom.find(b => b.sid === spik.sid)) {
                        let avoidDir = UTILS.getDirect(spik, player, 0, 2) + Math.PI;
                        if (player.reloads[player.weapons[0]] === 0 && !instaC.isTrue && !clicks.left && !clicks.right && player.reloads[player.weapons[1]] === 0) stopOnCollisionAndBreakObject();;
                        safewalking = true;
                        // packet("9", avoidDir, 1);
                        packet("e")
                        my.autoPush = false;
                        //pathFind.active = false;
                        pathFind.chaseNear = false;
                        tracker.draw3.active = true
                        tracker.draw3.x = spik.x
                        tracker.draw3.y = spik.y
                        tracker.draw3.scale = spik.scale
                    } else if (!phantom.find(b => b.sid === spik.sid) && spikenear){//beta antipush
                        if (player.reloads[player.weapons[0]] === 0 && !instaC.isTrue && !clicks.left && !clicks.right && player.reloads[player.weapons[1]] === 0) {
                            aimSpike();
                            tracker.draw1.active = true
                            tracker.draw1.x = spik.x
                            tracker.draw1.y = spik.y
                            tracker.draw1.scale = spik.scale
                        }
                    } else if(!_things.pathVisual){
                        safewalking = false;
                        packet("9", lastMoveDir, 1);
                        tracker.draw3.active = false
                        tracker.draw1.active = false
                    }
                    lastPos.x = player.x2;
                    lastPos.y = player.y2;
                }




                let pathIndex = 0;
                let millAngle_=_tr(Math.floor(Math.random() * 360)),millLoop=setInterval(()=>{
                    if(!traps.inTrap&&_things.player.x2 === _things.player.x && _things.player.y2 === _things.player.y);millAngle_=_tr(Math.floor(Math.random() * 360))
                    if(millDone&&player)clearInterval(millAngle_)
                },10000)
                function updatePlayers(data) { //bulltick
                    //safeWalk();
                    if (player.shameCount > 0) {
                        my.reSync = true;
                    } else {
                        my.reSync = false;
                    }

                    if (tmpObj == player) {
                        (!mills.x || !oldXY.x) && (mills.x = oldXY.x = tmpObj.x2);
                        (!mills.y || !oldXY.y) && (mills.y = oldXY.y = tmpObj.y2);
                    }
                    game.tick++;
                    enemy = [];
                    nears = [];
                    near = [];
                    game.tickSpeed = performance.now() - game.lastTick;
                    game.lastTick = performance.now();
                    players.forEach((tmp) => {
                        tmp.forcePos = !tmp.visible;
                        tmp.visible = false;
                    });
                    for (let i = 0; i < data.length;) {
                        tmpObj = findPlayerBySID(data[i]);
                        if (tmpObj) {
                            tmpObj.t1 = (tmpObj.t2 === undefined) ? game.lastTick : tmpObj.t2;
                            tmpObj.t2 = game.lastTick;
                            tmpObj.oldPos.x2 = tmpObj.x2;
                            tmpObj.oldPos.y2 = tmpObj.y2;
                            tmpObj.x1 = tmpObj.x;
                            tmpObj.y1 = tmpObj.y;
                            tmpObj.x2 = data[i + 1];
                            tmpObj.y2 = data[i + 2];
                            tmpObj.x3 = tmpObj.x2 + (tmpObj.x2 - tmpObj.oldPos.x2);
                            tmpObj.y3 = tmpObj.y2 + (tmpObj.y2 - tmpObj.oldPos.y2);
                            // Double extrapolation (x4/y4)
                            tmpObj.x4 = tmpObj.x3 + (tmpObj.x3 - tmpObj.x2);
                            tmpObj.y4 = tmpObj.y3 + (tmpObj.y3 - tmpObj.y2);

                            // Triple extrapolation (x5/y5)
                            tmpObj.x5 = tmpObj.x4 + (tmpObj.x4 - tmpObj.x3);
                            tmpObj.y5 = tmpObj.y4 + (tmpObj.y4 - tmpObj.y3);
                            tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 3] : tmpObj.d2;
                            tmpObj.d2 = data[i + 3];
                            tmpObj.dt = 0;
                            tmpObj.buildIndex = data[i + 4];
                            tmpObj.weaponIndex = data[i + 5];
                            tmpObj.weaponVariant = data[i + 6];
                            tmpObj.team = data[i + 7];
                            tmpObj.isLeader = data[i + 8];
                            tmpObj.oldSkinIndex = tmpObj.skinIndex;
                            tmpObj.oldTailIndex = tmpObj.tailIndex;
                            tmpObj.skinIndex = data[i + 9];
                            tmpObj.tailIndex = data[i + 10];
                            tmpObj.iconIndex = data[i + 11];
                            tmpObj.zIndex = data[i + 12];
                            tmpObj.visible = true;
                            tmpObj.lu=Date.now()
                            tmpObj.update(game.tickSpeed);
                            tmpObj.dist2 = UTILS.getDist(tmpObj, player, 2, 2);
                            tmpObj.aim2 = UTILS.getDirect(tmpObj, player, 2, 2);
                            tmpObj.dist3 = UTILS.getDist(tmpObj, player, 3, 3);
                            tmpObj.aim3 = UTILS.getDirect(tmpObj, player, 3, 3);
                            tmpObj.dist4 = UTILS.getDist(tmpObj, player, 4, 4);
                            tmpObj.aim4  = UTILS.getDirect(tmpObj, player, 4, 4);

                            tmpObj.dist5 = UTILS.getDist(tmpObj, player, 5, 5);
                            tmpObj.aim5  = UTILS.getDirect(tmpObj, player, 5, 5);
                            tmpObj.damageThreat = 0;
                            if (tmpObj.skinIndex == 45 && tmpObj.shameTimer <= 0) {
                                tmpObj.addShameTimer();
                            }
                            if (tmpObj.oldSkinIndex == 45 && tmpObj.skinIndex != 45) {
                                tmpObj.shameTimer = 0;
                                tmpObj.shameCount = 0;
                                if (tmpObj == player) {
                                    healer();
                                }
                            }
                            if (phantom.length > 0) {
                                for(let build of phantom) objectManager.disableBySid(build.sid);

                                phantom = [];
                            }

                            if (tmpObj == player) {
                                if (gameObjects.length) {
                                    gameObjects.forEach((tmp) => {
                                        tmp.onNear = false;
                                        if (tmp.active) {
                                            if (!tmp.onNear && UTILS.getDist(tmp, tmpObj, 0, 2) <= tmp.scale + items.weapons[tmpObj.weapons[0]].range) {
                                                tmp.onNear = true;
                                            }
                                            if (tmp.isItem && tmp.owner) {
                                                if (!tmp.pps && tmpObj.sid == tmp.owner.sid && UTILS.getDist(tmp, tmpObj, 0, 2) > (parseInt(getEl("breakRange").value)||0) && !tmp.breakObj && ![13, 14, 20].includes(tmp.id)) {
                                                    tmp.breakObj = true;
                                                    breakObjects.push({
                                                        x: tmp.x,
                                                        y: tmp.y,
                                                        sid: tmp.sid
                                                    });
                                                }
                                            }
                                        }
                                    });
                                    if (liztobj.length) {
                                        liztobj.forEach((tmp) => {
                                            tmp.onNear = false;
                                            if (tmp.active) {
                                                if (!tmp.onNear && UTILS.getDist(tmp, tmpObj, 0, 2) <= tmp.scale + items.weapons[tmpObj.weapons[0]].range) {
                                                    tmp.onNear = true;
                                                }
                                                if (tmp.isItem && tmp.owner) {
                                                    if (!tmp.pps && tmpObj.sid == tmp.owner.sid && UTILS.getDist(tmp, tmpObj, 0, 2) > (parseInt(getEl("breakRange").value) || 0) && !tmp.breakObj && ![13, 14, 20].includes(tmp.id)) {
                                                        tmp.breakObj = true;
                                                        breakObjects.push({
                                                            x: tmp.x,
                                                            y: tmp.y,
                                                            sid: tmp.sid
                                                        });
                                                    }
                                                }
                                            }
                                        });
                                        let nearTrap = gameObjects.filter(e => e.trap && e.active && UTILS.getDist(e, tmpObj, 0, 2) <= (tmpObj.scale + e.getScale() + 5) && !e.isTeamObject(tmpObj)).sort(function (a, b) {
                                            return UTILS.getDist(a, tmpObj, 0, 2) - UTILS.getDist(b, tmpObj, 0, 2);
                                        })[0];
                                        if (nearTrap) {
                                            traps.dist = UTILS.getDist(nearTrap, tmpObj, 0, 2);
                                            traps.aim = UTILS.getDirect(nearTrap, tmpObj, 0, 2);
                                            if (!traps.inTrap) {
                                                traps.protect(traps.aim);
                                            }
                                            traps.inTrap = true;
                                            !traps.lastHitTime&&(traps.lastHitTime=Date.now());
                                            setTimeout(()=>{
                                                //if()
                                            },1000)
                                            traps.info = nearTrap;
                                        } else {
                                            traps.inTrap = false;
                                            traps.info = {};
                                        }
                                        let nearSpike = gameObjects.filter(
                                            (object) =>
                                            (object.name == 'spikes' ||
                                             object.name == 'poison spikes' ||
                                             object.name == 'spinning spikes' ||
                                             object.name == 'greater spikes') &&
                                            object.active &&
                                            UTILS.getDist(object, tmpObj, 0, 2) <= 120 &&
                                            !object.isTeamObject(tmpObj)
                                        ).sort((a, b) => UTILS.getDist(a, tmpObj, 0, 2) - UTILS.getDist(b, tmpObj, 0, 2))[0];

                                        if (nearSpike && !instaC.isTrue) {
                                            aimSpike = UTILS.getDirect(nearSpike, player, 0, 2);
                                            nearspiker = true;
                                            info = nearSpike;
                                        } else {
                                            nearspiker = false;
                                            info = {};
                                        }
                                    } else {
                                        traps.inTrap = false;
                                    }
                                }
                            }
                            if (tmpObj.weaponIndex < 9) {
                                tmpObj.primaryIndex = tmpObj.weaponIndex;
                                tmpObj.primaryVariant = tmpObj.weaponVariant;
                            } else if (tmpObj.weaponIndex > 8) {
                                tmpObj.secondaryIndex = tmpObj.weaponIndex;
                                tmpObj.secondaryVariant = tmpObj.weaponVariant;
                            }
                        }
                        i += 13;
                    }
                    if (textManager.stack.length) {
                        let stacks = [];
                        let notstacks = [];
                        let num = 0;
                        let num2 = 0;
                        let pos = {
                            x: null,
                            y: null
                        };
                        let pos2 = {
                            x: null,
                            y: null
                        }
                        textManager.stack.forEach((text) => {
                            if (text.value >= 0) {
                                if (num == 0) pos = {
                                    x: text.x,
                                    y: text.y
                                };
                                num += Math.abs(text.value);
                            } else {
                                if (num2 == 0) pos2 = {
                                    x: text.x,
                                    y: text.y
                                };
                                num2 += Math.abs(text.value);
                            }
                        });
                        if (num2 > 0) {
                            textManager.showText(pos2.x, pos2.y, Math.max(45, Math.min(50, num2)), 0.18, 500, num2, "#8ecc51");
                        }
                        if (num > 0) {
                            textManager.showText(pos.x, pos.y, Math.max(45, Math.min(50, num)), 0.18, 500, num, "#fff");
                        }
                        textManager.stack = [];
                    }
                    if (runAtNextTick.length) {
                        runAtNextTick.forEach((tmp) => {
                            checkProjectileHolder(...tmp);
                        });
                        runAtNextTick = [];
                    }
                    for (let i = 0; i < data.length;) {
                        tmpObj = findPlayerBySID(data[i]);
                        if (tmpObj) {

                            if (!tmpObj.isTeam(player)) {
                                enemy.push(tmpObj);
                                if (tmpObj.dist2 <= items.weapons[tmpObj.primaryIndex == undefined ? 5 : tmpObj.primaryIndex].range + (player.scale * 2)) {
                                    nears.push(tmpObj);
                                }
                            }
                            tmpObj.manageReload();
                            if (tmpObj != player) {
                                tmpObj.addDamageThreat(player);
                            }
                        }
                        i += 13;
                    }
                    /*projectiles.forEach((proj) => {
                    tmpObj = proj;
                    if (tmpObj.active) {
                        tmpObj.tickUpdate(game.tickSpeed);
                    }
                });*/
                    if (player && player.alive) {
                        if (enemy.length) {
                            near = enemy.sort(function (tmp1, tmp2) {
                                return tmp1.dist2 - tmp2.dist2;
                            })[0];
                        } else {
                            // console.log("no enemy");
                        }
                        if (game.tickQueue[game.tick]) {
                            game.tickQueue[game.tick].forEach((action) => {
                                action();
                            });
                            game.tickQueue[game.tick] = null;
                        }
                        function notif2(message, target) {
                            const notif = document.createElement("div");
                            notif.style.position = "fixed";
                            notif.style.bottom = "20px";
                            notif.style.right = "20px";
                            notif.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
                            notif.style.color = "white";
                            notif.style.padding = "14px 28px";
                            notif.style.borderRadius = "10px";
                            notif.style.fontFamily = "'Hammersmith', sans-serif";
                            notif.style.fontSize = "18px";
                            notif.style.fontWeight = "bold";
                            notif.style.zIndex = "1000";
                            notif.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
                            notif.style.opacity = "0";
                            notif.style.transform = "translateY(20px)";
                            notif.style.transition = "opacity 0.6s ease, transform 0.6s ease";
                            notif.textContent = `${message} ${target}`;
                            document.body.appendChild(notif);
                            setTimeout(() => {
                                notif.style.opacity = "1";
                                notif.style.transform = "translateY(0)";
                            }, 10);
                            setTimeout(() => {
                                notif.style.opacity = "0";
                                notif.style.transform = "translateY(20px)";
                                setTimeout(() => {
                                    notif.remove();
                                }, 600);
                            }, 3000);
                        }

                        if (advHeal.length) {
                            advHeal.forEach((updHealth) => {
                                if (unsafeWindow.pingTime < 150) {
                                    let sid = updHealth[0];
                                    let value = updHealth[1];
                                    let totalDamage = 100 - value
                                    let damaged = updHealth[2];
                                    tmpObj = findPlayerBySID(sid);
                                    let bullTicked = false;
                                    if (tmpObj && tmpObj.health <= 0) {
                                        if (!tmpObj.death) {
                                            tmpObj.death = true;
                                            if (tmpObj != player) {
                                                if(sid==GM_getValue('k')){
                                                    GM_setValue('k','.')
                                                    GM_setValue('breaker',true)
                                                    console.log('Got',tmpObj.name, "has died",sid,GM_getValue('k'))
                                                }
                                                console.log(tmpObj.name, "has died",sid,GM_getValue('k'))
                                                notif2(tmpObj.name, "has died");
                                            }
                                            addDeadPlayer(tmpObj);
                                        }
                                    }
                                    if (tmpObj == player) {
                                        if (tmpObj.skinIndex == 7 && (damaged == 5 || (tmpObj.latestTail == 13 && damaged == 2))) {
                                            if (my.reSync) {
                                                my.reSync = false;
                                                tmpObj.setBullTick = true;
                                            }
                                            bullTicked = true;
                                        }
                                        if (inGame) {
                                            let attackers = getAttacker(damaged);
                                            let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                                            let includeSpikeDmgs = enemy.length ? !bullTicked && (gearDmgs.includes(damaged) && near.skinIndex == 11) : false;
                                            let healTimeout = 140 - unsafeWindow.pingTime;
                                            let dmg = 100 - player.health;
                                            let slowHeal = function (timer, tickBase) {
                                                if (!tickBase) {
                                                    setTimeout(() => {
                                                        healer();
                                                    }, timer);
                                                } else {
                                                    game.tickBase(() => {
                                                        healer()
                                                    }, 2)
                                                }
                                            }
                                            if (getEl("healingBeta").checked) {
                                                if (enemy.length) {
                                                    if ([0, 7, 8].includes(near.primaryIndex)) {
                                                        if (damaged < 75) {//normal heal
                                                            slowHeal(healTimeout)
                                                        } else {
                                                            healer()
                                                        }
                                                    }
                                                    let NearHasOneFrame = near.primaryVariant >= 1 && near.weapons[0] == 5
                                                    let PolOrKat = player.weapons[0] === 4 || player.weapons[0] === 5
                                                    let canSafeHitback = PolOrKat && !traps.inTrap && player.shameCount <= 4 && !NearHasOneFrame && !antispiketicked && !safewalking// && near.reloads[player.weapons[0]] == 0
                                                    if (canSafeHitback && damaged >= 20 && configs.HKH && near.dist2 <= 150 && (player.weapons[0] == 4 || player.weapons[0] == 3 || player.weapons[0] == 5) && player.skinIndex == 11 && player.reloads[player.weapons[1]] == 0 && player.reloads[player.weapons[0]] == 0) {//hitback
                                                        HKH();
                                                        addMenuChText("[Game]", "HitBack - KillHit", "lightBlue");
                                                        healer();
                                                    }
                                                    if(player.weapons[1] == 11) {//shield anti
                                                        if ([15, 9, 12, 13].includes(near.secondaryIndex) && near.reloads[near.secondaryIndex] == 1) {
                                                            if (damaged < 75) {
                                                                my.autoAim = true;
                                                                selectWeapon(player.weapons[1]);
                                                                slowHeal(healTimeout)
                                                                setTimeout(() => {
                                                                    selectWeapon(player.weapons[0]);
                                                                    my.autoAim = false;
                                                                }, 250);
                                                            }
                                                        }
                                                    } else if(player.weapons[1] == 11) {//shield anti2
                                                        if (near.skinIndex == 53) {
                                                            my.autoAim = true;
                                                            selectWeapon(player.weapons[1]);
                                                            slowHeal(healTimeout)
                                                            setTimeout(() => {
                                                                selectWeapon(player.weapons[0]);
                                                                my.autoAim = false;
                                                            }, 250);
                                                        }
                                                    }
                                                    if ([1, 2, 6].includes(near.primaryIndex)) {
                                                        if (damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5) {
                                                            healer()
                                                        } else {
                                                            slowHeal(healTimeout)
                                                        }
                                                    }
                                                    if (near.primaryIndex == 5 && near.secondaryIndex == 10 && traps.inTrap && dmg >= 10 && near.reloads[near.primaryIndex] == 0) { //beta anti rev tick
                                                        healer()
                                                    }
                                                    if (near.primaryIndex == 3) {//sword insta
                                                        if (near.secondaryIndex == 15) {
                                                            if (near.primaryVariant < 2) {
                                                                if (damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 6) {
                                                                    tmpObj.canEmpAnti = true
                                                                    healer()
                                                                } else {
                                                                    slowHeal(healTimeout)
                                                                }
                                                            } else {
                                                                if (damaged > 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 6 && game.tick - player.antiTimer > 1) {
                                                                    tmpObj.canEmpAnti = true
                                                                    tmpObj.antiTimer = game.tick
                                                                    healer()
                                                                } else {
                                                                    slowHeal(healTimeout)
                                                                }
                                                            }
                                                        } else {
                                                            if (damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        }
                                                    }
                                                    if (near.primaryIndex == 4) {
                                                        if (near.primaryVariant >= 1) {
                                                            if (damaged >= 10 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        } else {
                                                            if (damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 3) {
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        }
                                                    }
                                                    if ([undefined, 5].includes(near.primaryIndex)) {
                                                        if (near.secondaryIndex == 10) {
                                                            if (dmg >= (includeSpikeDmgs ? 10 : 20) && tmpObj.damageThreat + dmg >= 80 && tmpObj.shameCount < 6) {
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        } else
                                                            if (near.primaryVariant >= 2 || near.primaryVariant == undefined) {
                                                                if (dmg >= (includeSpikeDmgs ? 15 : 20) && tmpObj.damageThreat + dmg >= 50 && tmpObj.shameCount < 6) {
                                                                    healer()
                                                                } else {
                                                                    slowHeal(healTimeout)
                                                                }
                                                            } else
                                                                if ([undefined || 15].includes(near.secondaryIndex)) {
                                                                    if (damaged > (includeSpikeDmgs ? 8 : 20) && player.damageThreat >= 25 && (game.tick - player.antiTimer) > 1) {
                                                                        if (tmpObj.shameCount < 5) {
                                                                            healer()
                                                                        } else {
                                                                            slowHeal(healTimeout)
                                                                        }
                                                                    } else {
                                                                        slowHeal(healTimeout)
                                                                    }
                                                                } else
                                                                    if ([9, 12, 13].includes(near.secondaryIndex)) {
                                                                        if (dmg >= 25 && player.damageThreat + dmg >= 70 && tmpObj.shameCount < 6) {
                                                                            healer()
                                                                        } else {
                                                                            slowHeal(healTimeout)
                                                                        }
                                                                    } else {
                                                                        if (damaged > 25 && player.damageThreat + dmg >= 95) {
                                                                            healer()
                                                                        } else {
                                                                            slowHeal(healTimeout)
                                                                        }
                                                                    }
                                                    }
                                                    if (near.primaryIndex == 6) {
                                                        if (near.secondaryIndex == 15) {
                                                            if (damaged >= 25 && tmpObj.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        } else {
                                                            if (damaged >= 70 && tmpObj.shameCount < 4) {
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        }
                                                    }
                                                    if (damaged >= 30 && near.reloads[near.secondaryIndex] == 0 && near.dist2 <= 150 && player.skinIndex == 11 && player.tailIndex == 21) instaC.canCounter = true
                                                } else {
                                                    if (damaged >= 70) {
                                                        healer()
                                                    } else {
                                                        slowHeal(healTimeout)
                                                    }
                                                }
                                            } else {
                                                if (damaged >= (includeSpikeDmgs ? 8 : 25) && dmg + player.damageThreat >= 80 && (game.tick - player.antiTimer) > 1) {
                                                    if (tmpObj.reloads[53] == 0 && tmpObj.reloads[tmpObj.weapons[1]] == 0) {
                                                        tmpObj.canEmpAnti = true;
                                                    } else {
                                                        player.soldierAnti = true;
                                                    }
                                                    tmpObj.antiTimer = game.tick;
                                                    let shame = [0, 4, 6, 7, 8].includes(near.primaryIndex) ? 2 : 5;
                                                    if (tmpObj.shameCount < shame) {
                                                        healer();
                                                    } else {
                                                        if (near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21))) {
                                                            slowHeal(healTimeout)
                                                        } else {
                                                            slowHeal(healTimeout, 1)
                                                        }
                                                    }
                                                } else {
                                                    if (near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21))) {
                                                        slowHeal(healTimeout)
                                                    } else {
                                                        slowHeal(healTimeout, 1)
                                                    }
                                                }
                                                if (damaged >= 25 && near.dist2 <= 140 && player.skinIndex == 11 && player.tailIndex == 21) instaC.canCounter = true
                                            }
                                        } else {
                                            if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
                                                tmpObj.setPoisonTick = true;
                                            }
                                        }
                                    }
                                } else {
                                    let [sid, value, damaged] = updHealth;
                                    let totalDamage = 100 - value;
                                    let tmpObj = findPlayerBySID(sid);
                                    let bullTicked = false;

                                    if (tmpObj == player) {
                                        if (tmpObj.skinIndex == 7 && (damaged == 5 || (tmpObj.latestTail == 13 && damaged == 2))) {
                                            if (my.reSync) {
                                                my.reSync = false;
                                                tmpObj.setBullTick = true;
                                                bullTicked = true;
                                            }
                                        }
                                        if (inGame) {
                                            let attackers = getAttacker(damaged);
                                            let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                                            let includeSpikeDmgs = enemy.length ? !bullTicked && (gearDmgs.includes(damaged) && near.skinIndex == 11) : false;
                                            let healTimeout = 60;
                                            let dmg = 100 - player.health;
                                            let shameCountThreshold = [2, 5][[0, 4, 6, 7, 8].includes(near.primaryIndex) ? 0 : 1];

                                            let slowHeal = function (timer, tickBase) {
                                                if (!tickBase) setTimeout(() => healer(), timer);
                                                else game.tickBase(() => healer(), 2);
                                            };

                                            if (getEl("healingBeta").checked) {
                                                let canHealFast = [0, 7, 8].includes(near.primaryIndex) ? damaged < 75 :
                                                [1, 2, 6].includes(near.primaryIndex) ? damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5 :
                                                [undefined, 5].includes(near.primaryIndex) ? dmg >= (includeSpikeDmgs ? 15 : 20) && tmpObj.damageThreat + dmg >= 50 && tmpObj.shameCount < 6 :
                                                near.primaryIndex == 3 && near.secondaryIndex == 15 ? damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5 && game.tick - player.antiTimer > 1 :
                                                near.primaryIndex == 4 ? near.primaryVariant >= 1 ? damaged >= 10 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4 :
                                                damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 3 :
                                                near.primaryIndex == 6 && near.secondaryIndex == 15 ? damaged >= 25 && tmpObj.damageThreat + dmg >= 95 && tmpObj.shameCount < 4 :
                                                damaged >= 25 && player.damageThreat + dmg >= 95;

                                                canHealFast ? healer() : slowHeal(healTimeout);
                                            } else {
                                                let canHealFast = damaged >= (includeSpikeDmgs ? 8 : 25) && dmg + player.damageThreat >= 80 && (game.tick - player.antiTimer) > 1;

                                                if (canHealFast) {
                                                    if (tmpObj.reloads[53] == 0 && tmpObj.reloads[tmpObj.weapons[1]] == 0) tmpObj.canEmpAnti = true;
                                                    else player.soldierAnti = true;
                                                    tmpObj.antiTimer = game.tick;
                                                    if (tmpObj.shameCount < shameCountThreshold) healer();
                                                    else slowHeal(healTimeout, near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21)) ? 0 : 1);
                                                } else {
                                                    slowHeal(healTimeout, near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21)) ? 0 : 1);
                                                }
                                            }
                                        } else {
                                            if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
                                                tmpObj.setPoisonTick = true;
                                            }
                                        }
                                    }
                                }
                            });
                            advHeal = [];
                        }
                        players.forEach((tmp) => {
                            if (!tmp.visible && player != tmp) {
                                tmp.reloads = {
                                    0: 0,
                                    1: 0,
                                    2: 0,
                                    3: 0,
                                    4: 0,
                                    5: 0,
                                    6: 0,
                                    7: 0,
                                    8: 0,
                                    9: 0,
                                    10: 0,
                                    11: 0,
                                    12: 0,
                                    13: 0,
                                    14: 0,
                                    15: 0,
                                    53: 0,
                                };
                            }
                            if (tmp.setBullTick) {
                                tmp.bullTimer = 0;
                            }
                            if (tmp.setPoisonTick) {
                                tmp.poisonTimer = 0;
                            }
                            tmp.updateTimer();
                        });

                        if (inGame) {
                            if (enemy.length) {
                                if (!instaC.isTrue && configs.predictTick && my.anti0Tick <= 0) {
                                    let spikeSync = knockBackPredict()
                                    if (spikeSync == "insta them" && (![9, 12, 13, 15].includes(player.weapons[1]) || near.dist2 <= items.weapons[player.weapons[1]].range + player.scale * 1.8)) {
                                        instaC.changeType(configs.revTick || player.weapons[1] == 10 ? "rev" : "normal");
                                    }
                                }
                                if (player.canEmpAnti) {
                                    player.canEmpAnti = false;
                                    if (near.dist2 <= 300 && !my.safePrimary(near) && !my.safeSecondary(near)) {
                                        if (near.reloads[53] == 0){
                                            player.empAnti = true;
                                            player.soldierAnti = false;
                                            //modLog("EmpAnti");
                                        } else {
                                            player.empAnti = false;
                                            player.soldierAnti = true;
                                            //modLog("SoldierAnti");
                                        }
                                    }
                                }
                                let prehit = gameObjects.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 3) <= (tmp.scale + near.scale)).sort(function (a, b) {
                                    return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                })[0];
                                if (prehit) {
                                    if (near.dist2 <= items.weapons[player.weapons[0]].range + player.scale * 1.8 && configs.predictTick) {
                                        instaC.canSpikeTick = true;
                                        instaC.syncHit = true;
                                        if (configs.revTick && player.weapons[1] == 15 && player.reloads[53] == 0 && instaC.perfCheck(player, near)) {
                                            instaC.revTick = true;
                                        }
                                    }
                                }
                                let antiSpikeTick = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + player.scale)).sort(function (a, b) {
                                    return UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2);
                                })[0];
                                if (antiSpikeTick && !traps.inTrap) {
                                    if (near.dist2 <= items.weapons[5].range + near.scale * 1.8) {//anti vel
                                        my.anti0Tick = 1;
                                        addMenuChText("[Game]", "Anti Vel", "red");
                                        healer();
                                        buyEquip(6,0);
                                    }
                                }
                            }
                            let bultect = false;
                            if((game.tick - near.bullTick) % 9 == 0 && near.skinIndex == 7) {
                                addMenuChText("[Game]","Bulltick detected: " + near.name + "[" + near.sid + "]", "#40E0D0", "", "#40E0D0");
                                bultect = true;
                                game.tickBase(() => {
                                    bultect = false;
                                }, 1)
                            }
                            //_things.traps.inTrap&&(_things.aimAt(_things.traps.info))
                            let trapFound
                            if (enemy.length) {
                                if (player.canEmpAnti) {
                                    player.canEmpAnti = false;
                                    if (near.dist2 <= 300 && !my.safePrimary(near) && !my.safeSecondary(near)) {
                                        if (near.reloads[53] == 0) {
                                            player.empAnti = true;
                                            player.soldierAnti = false;
                                            //modLog("EmpAnti");
                                        } else {
                                            player.empAnti = false;
                                            player.soldierAnti = true;
                                            //modLog("SoldierAnti");
                                        }
                                    }
                                }
                                let prehit = liztobj.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 3) <= (tmp.scale + near.scale)).sort(function(a, b) {
                                    return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                })[0];
                                if (prehit) {
                                    if (near.dist3 <= items.weapons[player.weapons[0]].range + player.scale * 1.8 && configs.predictTick) {
                                        instaC.canSpikeTick = true;
                                        instaC.syncHit = true;
                                        if (configs.revTick && player.weapons[1] == 15 && player.reloads[53] == 0 && instaC.perfCheck(player, near)) {
                                            instaC.revTick = true;
                                        }
                                    }
                                }
                                let antiSpikeTick = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + player.scale)).sort(function(a, b) {
                                    return UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2);
                                })[0];
                                if (antiSpikeTick && !traps.inTrap) {
                                    if (near.dist2 <= items.weapons[5].range + near.scale * 1.8) {
                                        my.anti0Tick = 1;
                                        if (configs.combatWarnings) {
                                            player.chat.count = 1500;
                                        }
                                    }
                                }
                                trapFound=gameObjects
                                    .filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= near.scale + tmp.getScale() + 5)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))[0]
                            }
                            _things.trapFound=trapFound
                            if ((useWasd ? true : ((player.checkCanInsta(true) >= 220 ? player.checkCanInsta(true) : player.checkCanInsta(false)) >= (player.weapons[1] == 10 ? 95 : 100))) && near.dist2 <= items.weapons[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]].range + near.scale * 1.8 && (instaC.wait || (useWasd && Math.floor(Math.random() * 5) == 0)) && !instaC.isTrue && !my.waitHit && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && (useWasd ? true : (player.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate))) && instaC.perfCheck(player, near)) {
                                if (player.checkCanInsta(true) >= 220) {
                                    instaC.nobull = useWasd ? false : instaC.canSpikeTick ? false : true;
                                } else {
                                    instaC.nobull = false;
                                }
                                instaC.can = true;
                            }
                            else {
                                instaC.can = false;
                            }
                            // First, check for insta availability thresholds.
                            _things.canNoBull = player.checkCanInsta(true);
                            _things.canBull = player.checkCanInsta(false);

                            let availableInstaTypes = [];
                            if (_things.canNoBull >= 100) {
                                availableInstaTypes.push('nobull');
                            }
                            if (_things.canBull >= 100) {
                                availableInstaTypes.push('rev', 'Normal');
                            }
                            if (unsafeWindow.autoInsta && availableInstaTypes.length > 0&&!my.autoPush&&!my.autoPush2) {
                                const primaryWeapon = player.weapons[0];
                                const secondaryWeapon = player.weapons[1];
                                const inRange = near.dist2 <= items.weapons[primaryWeapon].range + player.scale * 1.8;
                                const isFullyReloaded =
                                      player.reloads[primaryWeapon] === 0 &&
                                      player.reloads[secondaryWeapon] === 0 &&
                                      player.reloads[53] === 0;

                                // Pick a random insta type from the available options.
                                let instaChoice = _random(availableInstaTypes);

                                // For weapons 15, 9, 12, or 13 (with additional conditions)
                                if ([15, 9, 12, 13].includes(secondaryWeapon)) {
                                    // Added a check: if near.skinIndex != 6 or _things.canBull > 110, then allow insta.
                                    if (
                                        isFullyReloaded &&
                                        !clicks.right &&
                                        inRange &&
                                        secondaryWeapon !== 10 &&
                                        (near.skinIndex !== 6// || _things.canBull > 110
                                        )
                                    ) {
                                        instaC.changeType(instaChoice);
                                        //sendChat('Me insta now: ' + instaChoice);
                                        addMenuChText("[Game]", "AutoInsta: 2 Shame "+instaChoice, "lightBlue");
                                    }
                                }
                                // For secondaryWeapon 10 with primaryWeapon 5 or 4.
                                else if (secondaryWeapon === 10 && (primaryWeapon === 5 || primaryWeapon === 4)) {
                                    if (
                                        near.shameCount >= 5 &&
                                        isFullyReloaded &&
                                        !clicks.right &&
                                        inRange &&
                                        near.skinIndex !== 6
                                    ) {
                                        instaC.changeType("normal");
                                        console.log('Me insta now ok');
                                        addMenuChText("[Game]", "AutoInsta: 5 Shame {normal}", "lightBlue");
                                    }
                                }
                            }

                            if (configs.smartAutoInsta) {
                                const primaryWeapon = player.weapons[0];
                                const secondaryWeapon = player.weapons[1];
                                const inRange = near.dist2 <= items.weapons[primaryWeapon].range + player.scale * 1.8;
                                const isFullyReloaded = player.reloads[primaryWeapon] === 0 && player.reloads[secondaryWeapon] === 0 && player.reloads[53] == 0;

                                if (secondaryWeapon === 15 || secondaryWeapon === 9 || secondaryWeapon === 12 || secondaryWeapon === 13) {
                                    if (near.shameCount >= 5 && isFullyReloaded && !clicks.right && inRange && secondaryWeapon !== 10 && near.skinIndex != 6) {
                                        instaC.changeType(instaType.value)
                                        console.log('Me insta now:'+instaType.value)
                                        //instaC.changeType((secondaryWeapon === 9 || secondaryWeapon === 12 || secondaryWeapon === 13) ? "rev" : "normal");
                                        addMenuChText("[Game]", "AutoInsta: 5 Shame {not}", "lightBlue");
                                    }
                                }
                                else if (secondaryWeapon === 10 && ((primaryWeapon === 5 || primaryWeapon === 4))) {
                                    if (near.shameCount >= 5 && isFullyReloaded && !clicks.right && inRange && near.skinIndex != 6) {
                                        instaC.changeType("normal");
                                        console.log('Me insta now ok')
                                        addMenuChText("[Game]", "AutoInsta: 5 Shame {normal}", "lightBlue");
                                    }
                                }
                            }
                            if (configs.autobullspam&&!nearspiker) {
                                if (near.dist2 <= (items.weapons[player.weapons[0]].range + near.scale * 1.8) && !traps.inTrap && player.reloads[player.weapons[0]] == 0) {
                                    instaC.canspam = true;
                                } else {
                                    instaC.canspam = false;
                                }
                                if (instaC.canspam) {
                                    try{
                                        instaC.spammer()
                                    }catch(err){console.warn(err)}
                                }
                            }
                            macro.q && place(0, getAttackDir());
                            macro.f && place(4, getSafeDir());
                            macro.v && place(2, getSafeDir());
                            macro.y && place(5, getSafeDir());
                            macro.h && place(player.getItemType(22), getSafeDir());
                            macro.n && place(3, getSafeDir());
                            laztPoz.x = player.x;
                            laztPoz.y = player.y;
                            let objectSize = mills.size(items.list[player.items[3]].scale);
                            let objectDist = mills.dist(items.list[player.items[3]].scale);
                            const threshold    = player.age <= 7 ? 90 : 299;
                            const currentCount = player.itemCounts[3] || 0;
                            const canMill      = autoGo && currentCount < threshold;

                            // expose for debug/GUI
                            canM = canMill;

                            // Auto-sync your toggle only when autoGo is active and you’re not done
                            if (!millDone && autoGo) {
                                mills.place = canMill;
                            }

                            // Lock it down once you hit the cap
                            if(autoGo&&!traps.inTrap){
                                if (currentCount >= threshold&&player.age<=8) {
                                    mills.place = false;
                                }else if(currentCount >= threshold){
                                    if (!millDone) console.warn("Mills Done"); // flex moment
                                    millDone    = true;
                                    mills.place=false;
                                }
                                // grab primary & maybe-secondary
                                const primaryIdx   = player.weapons[0];
                                const secondaryIdx = player.weapons[1]; // might be undefined

                                // decide which weapon index to check reload on
                                let checkIdx = primaryIdx;
                                if (secondaryIdx !== undefined) {
                                    const spd0 = items.weapons[primaryIdx].spdMult;
                                    const spd1 = items.weapons[secondaryIdx].spdMult;
                                    checkIdx = spd0 < spd1 ? secondaryIdx : primaryIdx;
                                }

                                // now this won't throw, because checkIdx is always a valid index
                                let targetW = player.reloads[checkIdx] === 0;

                                if (!millDone && mills.place&&targetW) {
                                    _things.packet(_things.atkKey, 1, millAngle_, 1);
                                    _things.packet(_things.atkKey, 1, millAngle_, 0);
                                }
                                // move packet (no change)

                            }

                            // Placement: only if not done, AND (auto-go or manual toggle), AND distance/tick checks
                            if (
                                !millDone &&
                                (mills.place || canMill) &&
                                UTILS.getDist(mills, player, 0, 2)
                                > objectDist + items.list[player.items[3]].placeOffset &&
                                game.tick % 2 === 0
                            ) {
                                const boomDir = UTILS.getDirect(
                                    { x: mills.x, y: mills.y },
                                    player,
                                    0,
                                    2
                                );

                                // spray placements in a triangle like before
                                if (currentCount < threshold - 2)
                                    checkPlace(3, boomDir + UTILS.toRad(objectSize));
                                if (currentCount < threshold - 1)
                                    checkPlace(3, boomDir - UTILS.toRad(objectSize));
                                checkPlace(3, boomDir);

                                // update your state
                                mills.count = Math.max(0, mills.count - 1);
                                mills.x     = player.x2;
                                mills.y     = player.y2;
                            }
                            //    if (game.tick % .3 == 0) {
                            if (pads.placeSpawnPads) {
                                for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                    checkPlace(player.getItemType(20), UTILS.getDirect(player.oldPos, player, 2, 2) + i);
                                    //}
                                }
                            }
                            if (instaC.can) {
                                console.log('Me insta now oki')
                                //instaC.changeType(player.weapons[1] == 10 ? "rev" : "normal");
                                instaC.changeType(player.weapons[1] == 10 ? "rev" : instaType.value);
                            }
                            if (instaC.canCounter) {
                                instaC.canCounter = false;
                                if (player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                                    if (player.secondaryIndex != 10) instaC.counterType();
                                    else instaC.hammerCounterType()
                                }
                            }
                            if (instaC.canSpikeTick){
                                instaC.canSpikeTick = false;
                                if (instaC.revTick) {
                                    instaC.revTick = false;
                                    if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) && player.reloads[player.weapons[1]] == 0 && !instaC.isTrue) {
                                        sendChat('Ill Rev ya')
                                        instaC.changeType("rev");
                                        addMenuChText(null, "[RevSyncHit]", "yellow");
                                    }
                                } else {
                                    if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) && player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                                        //sendChat('Ill Spike ya')
                                        instaC.spikeTickType();
                                        if (instaC.syncHit) {
                                            addMenuChText(null, "[SyncHit]", "yellow");
                                        }
                                    }
                                }
                            }
                            if (instaC.canKb) {
                                instaC.canKb = false;
                                if(!instaC.isTrue) {
                                    return "insta them"
                                }
                            }

                            if (nearspiker &&!clicks['left'] &&!clicks['right'] &&!instaC.isTrue) {
                                // Determine the desired weapon based on spikeKT()
                                let desiredWeapon = spikeKT() ? player.weapons[1] : player.weapons[0];

                                // If the player is not holding the desired weapon or is reloading, select the weapon
                                if (
                                    player.weaponIndex !== desiredWeapon ||
                                    player.reloads > -1
                                ) {
                                    selectWeapon(desiredWeapon);
                                }

                                // If the weapon's cooldown is ready and not waiting for hit confirmation
                                if (player.reloads[desiredWeapon] === 0) {
                                    let dir=getAttackDir()
                                    packet("D",dir)
                                    //_things.packet(_things.atkKey, 1, getAttackDir(), 1);
                                    sendAutoGather();
                                    my.waitHit = true;

                                    // Schedule to send gather command again after 1 millisecond
                                    game.tickBase(() => {
                                        //_things.packet(_things.atkKey, 0, getAttackDir(), 1);
                                        sendAutoGather();
                                        my.waitHit = false;
                                    }, 1);
                                }
                            }
                            if (!clicks.middle && (clicks.left || clicks.right) && !instaC.isTrue) {
                                if ((player.weaponIndex != (clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0])) || player.buildIndex > -1) {
                                    selectWeapon(clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]);
                                }
                                if (player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit) {
                                    sendAutoGather();
                                    my.waitHit = 1;
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        my.waitHit = 0;
                                    }, 1);
                                }
                            }

                            if (traps.inTrap) {
                                if (!clicks.left && !clicks.right && !instaC.isTrue) {
                                    let index=traps.notFast() ? player.weapons[1] : player.weapons[0]
                                    let val
                                    try{val=items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1) * (tmpObj.skinIndex == 40 ? 3.3 : 1);}catch{}
                                    if(false&&getAttackDir(true)=='traps.aim'&&_things.enemy.enemy&&_things.enemy.enemy.dist2&&_things.enemy.enemy.dist2<(35*1.2)){
                                        let[_,__]=[..._things.player.weapons].map(e=>weapons.find(a=>a.id==e).range)
                                        let t=_<__?1:0
                                        selectWeapon(player.weapons[t])
                                        if(!my.waitHit&&player.reloads[player.weapons[t]]==0){
                                            //my.waitHit=1
                                            _things.packet(_things.atkKey, 1, _things.enemy.targetDir, 1);
                                            //sendAutoGather();
                                            my.waitHit = 1;
                                            game.tickBase(() => {
                                                _things.packet(_things.atkKey, 0, _things.enemy.targetDir, 1);
                                                //sendAutoGather();
                                                my.waitHit = 0;
                                            }, 1);
                                        }
                                    }
                                    else{
                                        if (player.weaponIndex != (traps.notFast() ? player.weapons[1] : player.weapons[0]) || player.buildIndex > -1) {
                                            selectWeapon(traps.notFast() ? player.weapons[1] : player.weapons[0]);
                                        }
                                        if (player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit) {
                                            _things.packet(_things.atkKey, 1, getAttackDir(), 1);
                                            //sendAutoGather();
                                            my.waitHit = 1;
                                            game.tickBase(() => {
                                                _things.packet(_things.atkKey, 0, getAttackDir(), 1);
                                                //sendAutoGather();
                                                my.waitHit = 0;
                                            }, 1);
                                        }
                                    }
                                }
                            }

                            if (traps.inTrap&&!true) {
                                if (!clicks.left && !clicks.right && !instaC.isTrue) {
                                    if (player.weaponIndex != (traps.notFast() ? player.weapons[1] : player.weapons[0]) || player.buildIndex > -1) {
                                        selectWeapon(traps.notFast() ? player.weapons[1] : player.weapons[0]);
                                    }
                                    const buildings = gameObjects.sort((a, b) => Math.hypot(player.y2 - a.y, player.x2 - a.x) - Math.hypot(player.y2 - b.y, player.x2 - b.x));

                                    const spikes = buildings.filter((obj) => {
                                        return (
                                            (obj.name === "spikes" || obj.name === "greater spikes" || obj.name === "spinning spikes" || obj.name === "poison spikes") &&
                                            !isAlly(obj.owner.sid) &&
                                            obj.owner.sid !== player.sid &&
                                            fgdo(player, obj) < 250 &&
                                            obj.active
                                        );
                                    });
                                    let spik = null;
                                    let spikenear = false;
                                    let found = false;
                                    const newPos = {
                                        x: player.x2 + (player.x2 - lastPos.x) * 1.2 + Math.cos(player.moveDir) * 50,
                                        y: player.y2 + (player.y2 - lastPos.y) * 1.2 + Math.sin(player.moveDir) * 50,
                                    };

                                    for (let i = 0; i < spikes.length; i++) {
                                        if (fgdo(spikes[i], newPos) < spikes[i].scale + player.scale + 5 && !traps.inTrap) {
                                            found = true;
                                            spikenear = false;
                                            spik = spikes[i];
                                            break;
                                        }
                                    }
                                    for (let i = 0; i < spikes.length; i++) {
                                        if (fgdo(spikes[i], player) < spikes[i].scale + player.scale + 35 && traps.inTrap) {
                                            spikenear = true;
                                            found = false;
                                            spik = spikes[i];
                                            break;
                                        }
                                    }

                                    if (player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit && !spikenear && !found) {
                                        sendAutoGather();
                                        my.waitHit = 1;
                                        game.tickBase(() => {
                                            sendAutoGather();
                                            my.waitHit = 0;
                                        }, 1);
                                    } else if (player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit && spikenear) {
                                        sendAutoGather();
                                        my.waitHit = 1;
                                        game.tickBase(() => {
                                            sendAutoGather();
                                            my.waitHit = 0;
                                        }, 1);
                                    }
                                }
                            }
                            if (clicks.middle && !traps.inTrap) {
                                if (!instaC.isTrue && player.reloads[player.weapons[1]] == 0) {
                                    if (my.ageInsta && player.weapons[0] != 4 && player.weapons[1] == 9 && player.age >= 9 && enemy.length) {
                                        instaC.bowMovement();
                                    } else {
                                        instaC.rangeType();
                                    }
                                }
                            }
                            if (macro.t && !traps.inTrap) {
                                if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && (player.weapons[1] == 15 ? (player.reloads[player.weapons[1]] == 0) : true) && (player.weapons[0] == 5 || (player.weapons[0] == 4 && player.weapons[1] == 15))) {
                                    instaC[(player.weapons[0] == 4 && player.weapons[1] == 15) ? "kmTickMovement" : "tickMovement"]();
                                }
                            }
                            if (macro["."] && !traps.inTrap) {
                                if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && ([9, 12, 13, 15].includes(player.weapons[1]) ? (player.reloads[player.weapons[1]] == 0) : true)) {
                                    instaC.boostTickMovement();
                                }
                            }
                            if (player.weapons[1] && !clicks.left && !clicks.right && !traps.inTrap && !instaC.isTrue && !(useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8)) {
                                if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                                    if (!my.reloaded) {
                                        my.reloaded = true;
                                        let fastSpeed = items.weapons[player.weapons[0]].spdMult < items.weapons[player.weapons[1]].spdMult ? 1 : 0;
                                        if (player.weaponIndex != player.weapons[fastSpeed] || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[fastSpeed]);
                                        }
                                    }
                                } else {
                                    my.reloaded = false;
                                    if((!nearspiker&&!IsautoRuby)){
                                        if (player.reloads[player.weapons[0]] > 0) {
                                            if (player.weaponIndex != player.weapons[0] || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[0]);
                                            }
                                        } else if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] > 0) {
                                            if (player.weaponIndex != player.weapons[1] || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[1]);
                                            }
                                        }
                                    }
                                }
                            }
                            if (!instaC.isTrue && !traps.replaced
                                //&& !traps.inTrap
                               ) {
                                if(traps.inTrap){
                                    retrappable=true;
                                }
                                traps.autoPlace();
                            }
                            if (!instaC.isTrue && configs.autoPlace) {
                                preplacer();
                            }
                            if (!instaC.isTrue && configs.autoOneFrame && autoOneFrameToggled) {
                                autoOneFrame();
                            }
                            if (!instaC.isTrue && configs.adxtick) {
                                adxtick();
                            }
                            if (!macro.q && !macro.f && !macro.v && !macro.h && !macro.n) {
                                packet("D", getAttackDir());
                            }
                            function getKnockbackSetupPositions(botDistance_=40,closesp=300) {
                                // Enemy's center position
                                const enemyPos = { x: near.x2, y: near.y2 };
                                // Define how close the bot should be to the enemy (tweak as needed)
                                const botDistance = player.scale + botDistance_;

                                let chosenSpike = null;
                                let minSpikeDist = Infinity;

                                // Loop over game objects to find a valid spike (damaging object)
                                for (let obj of gameObjects) {
                                    if (obj.dmg && obj.active && obj.isTeamObject(player)) {
                                        const spikePos = { x: obj.x, y: obj.y };
                                        // Calculate the distance from the enemy to the spike
                                        const spikeDist = UTILS.getDist(spikePos, enemyPos, 0, 0);
                                        // Must be at least 300 units away from the enemy
                                        if (spikeDist < closesp) continue;
                                        // If this spike is closer than any other valid spike, pick it
                                        if (spikeDist < minSpikeDist) {
                                            minSpikeDist = spikeDist;
                                            chosenSpike = spikePos;
                                        }
                                    }
                                }

                                // If no spike meets the criteria, return an empty array
                                if (!chosenSpike) return [];

                                // Calculate vector from enemy to the chosen spike
                                const dx = chosenSpike.x - enemyPos.x3;
                                const dy = chosenSpike.y - enemyPos.y3;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist === 0) return [];

                                // Determine the bot's position so it's directly in front of the enemy,
                                // meaning on the opposite side of the enemy from the spike.
                                const botPos = {
                                    x: enemyPos.x - (dx / dist) * botDistance,
                                    y: enemyPos.y - (dy / dist) * botDistance
                                };

                                return [botPos, chosenSpike];
                            }
                            _things.enemyKBI=_things.enemy&&_things.enemy.enemy&&(antiKnockBackPredict())
                            _things.getKnockbackSetupPositions=getKnockbackSetupPositions();
                            _things.stealT=(_things.enemy.enemy&&_things.enemy.enemy.skinIndex==45)||_things.enemy&&_things.enemy.enemy&&_things.enemy.enemy.health<=30;
                            _things.stealM=!unsafeWindow.autoInsta&&_things.enemy&&_things.enemy.enemy&&_things.enemy.enemy.health<=49;
                            function dodgeKBI() {
                                const spike = _things.enemyKBI;
                                const en    = _things.enemy.enemy;
                                if (!spike || !en || traps.inTrap) return false;   // no dodge right now

                                const px = player.x2, py = player.y2;
                                const sx = spike.x,  sy = spike.y;
                                const ex = en.x,     ey = en.y;

                                // 1) base away angle
                                const baseAngle = Math.atan2(py - sy, px - sx);
                                const spread    = Math.PI / 4;    // ±45°
                                const offsets   = [0, +spread, -spread];
                                const safeDist  = spike.scale + player.scale + 10;

                                // 2) pick the spoke that lands farthest from the enemy
                                let best = { dist: -Infinity, x: px, y: py };
                                offsets.forEach(off => {
                                    const ang   = baseAngle + off;
                                    const candX = sx + Math.cos(ang) * safeDist;
                                    const candY = sy + Math.sin(ang) * safeDist;
                                    const d2e   = Math.hypot(candX - ex, candY - ey);
                                    if (d2e > best.dist) best = { dist: d2e, x: candX, y: candY };
                                });
                                const wep    = items.weapons[enemy.primaryIndex] || { range: 0 };
                                const range  = wep.range;

                                // 2) account for both scales (so circles actually just touch)
                                const minDist = range + (player.scale*2);

                                // 3) add your buffer (10–20px is chill)
                                const buffer   = 20;

                                // 4) that’s your safe distance
                                const safeDist_ = minDist// + buffer;
                                if(getDistance(px,py,ex,ey)>safeDist_)return;
                                console.log('moving')
                                // 3) send ONE direct-move packet along that green spoke
                                if(typeof bestEsc!=typeof thisdoesnt&&typeof bestEsc == typeof 1){
                                    //_things.packet(_things.moveKey, bestEsc, 1);
                                    //lastMoveDir=bestEsc
                                    bestEsc=null;
                                    if(!diddoge){
                                        chat('anti KBI test')}
                                    diddoge=1
                                    return true;
                                }else return diddoge=(diddoge?(stop(),false):false);
                            }
                            _things.pathVisual=null
                            let chainPush=false
                            let chainDir=null
                            if(typeof _things.autoPushChain.moveDir==typeof 0){
                                chainPush=true
                                chainDir=_things.autoPushChain.moveDir+Math.PI
                                //_things.packet('9',_things.autoPushChain.moveDir+Math.PI,1)
                            }else chainPush=false
                            !function(){
                                if(_things.my.autoPush2&&autoGo){
                                    isMovingAuto = 0;
                                    clicks.left=0
                                    targetPos = null;
                                    obss = [];
                                    return;
                                }
                                //_things.pathVisual=null
                                let haspole=_things.player.weapons[0]==5
                                let hasham=_things.player.weapons[1]==10
                                let isReady=!player.weapons.some(e=>player.reloads[e])&&_things.player.reloads[53]==0
                                let UseGM=(autoGo?gameObjects:liztobj)
                                /*.map(e=>{
                                if(e.name&&e.name.includes('port')&&!e.oScale){
                                    console.log('Updated gameOBJ',e)
                                    e.ignoreCollision=false
                                    e.oScale=e.getScale
                                    e.getScale=function(){
                                        return 200
                                    }
                                }
                                return e
                            })*/
                                if(addPlayerTooObst){
                                    UseGM=[...UseGM,...players]
                                }
                                //if(chainPush)return (_things.packet('9',_things.autoPushChain.moveDir+Math.PI,1),packet('9',_things.autoPushChain.moveDir+Math.PI,1), [targetPos, offsetPos_, obss] = [null, 0, UseGM])
                                // Reset/Initial states
                                isMovingAuto = 0;
                                targetPos = null;
                                obss = [];

                                // Save player position if available
                                if (player) {
                                    GM_setValue(player.id, { x: player.x, y: player.y });
                                }
                                // Early returns and main checks
                                if(autoJoinMain){
                                    joinTeam()//(GM_getValue('Mclan'))
                                }
                                !function(){
                                    delete _things.m
                                    const primaryId = player.weapons[0];
                                    const primRange = items.weapons[primaryId].range + player.scale * 1.8;
                                    let mustKill//=(closestEnemy.shameTimer>0||closestEnemy.skinIndex==45||closestEnemy.shameCount>=5)
                                    let closestEnemy=_things.enemy.enemy;
                                    if(!closestEnemy)return;
                                    let closeObjs = getObjectsInLineOfSight(closestEnemy, _things.player)
                                    if(closestEnemy)mustKill=(closestEnemy.shameTimer>0||closestEnemy.skinIndex==45||closestEnemy.shameCount>=5);
                                    _things.stealT=_things.stealT||mustKill
                                    //_things.stealM=_things.stealM||mustKill
                                    if(closestEnemy&&_things.stealT&&player.reloads[53]==0){buyEquip(53,0)}

                                    if(player.reloads[primaryId]==0&&closestEnemy.health<(closestEnemy.health<items.weapons[primaryId].dmg)&&_things.player.skinIndex !== 11&&near.dist2 <= items.weapons[primaryId].range + player.scale * 1.8&&closestEnemy.skinIndex !== 11){
                                        clicks.left=true
                                    }
                                }()
                                if (!autoGo && isMain) {
                                    GM_setValue('mainPos', { x: player.x3, y: player.y3 });
                                    GM_setValue('Mclan', _things.player.team);
                                    return;
                                }
                                if(!millDone)return;
                                ;(!GM_getValue('middle'))&&(my.autoAim = false);
                                clicks.left = false;
                                if(RealPush&&!_things.enemy.enemy)RealPush=false;
                                if (!autoGo || my.autoPush || RealPush || traps.inTrap) {
                                    //console.log({autopush:my.autoPush,RealPush,intrap:traps.inTrap})
                                    return;
                                }
                                const spike = _things.enemyKBI;
                                if (spike&&false) {
                                    const primaryId = player.weapons[0];
                                    const primRange = items.weapons[primaryId].range + player.scale * 1.8;
                                    const distToSpike = getDistance(player.x, player.y, spike.x, spike.y);

                                    // if in primary‑weapon range → break it
                                    state_='breakingKBI'
                                    if (distToSpike <= primRange&&player.reloads[primaryId]==0) {
                                        const attackDir = Math.atan2(spike.y - player.y, spike.x - player.x);
                                        buyEquip(player.reloads[primaryId] === 0 ? 40 : 6, 0)
                                        selectWeapon(primaryId);
                                        _things.packet(_things.atkKey, 1, attackDir, 1);
                                        _things.packet(_things.atkKey, 0, attackDir, 1);
                                        return;  // done breaking
                                    }
                                    state_='towardsKBI'
                                    const offsetDist = items.weapons[player.weapons[0]].range + player.scale * 1.2; // tweak as needed
                                    const nextPos = getBreakOffset({ x: player.x, y: player.y }, spike, player.scale*1.8);

                                    // else dash over to it
                                    isMovingAuto = 1;
                                    targetPos   = nextPos;
                                    offsetPos_  = null;
                                    obss        = getObstaclesNearPlayer(player, _things.liztobj);
                                    return;
                                }
                                useSpam = GM_getValue('useSpam') || false;
                                farmAi = GM_getValue('farmAi') || false;
                                isMain = false;
                                // Initial toggles
                                //clicks.left = false;

                                clicks.right = false;
                                IsautoRuby=false;
                                var breakerS=GM_getValue('breaker')
                                // Check for turret item
                                const hasTurret =(_things.player.items.includes(22)||_things.player.items.includes(17))
                                state_=""
                                // Determine main reference position
                                const stayFlag = !GM_getValue('stay');
                                const fID = GM_getValue('fID');
                                const mainPosValue = GM_getValue('mainPos');
                                var m;
                                if(stayFlag){
                                    if(fID){
                                        if(findPlayerBySID(fID)){
                                            m=findPlayerBySID(fID)
                                            state_="findPlayerBySID(fID)"
                                        }else if(GM_getValue(fID)){
                                            m=GM_getValue(fID)
                                            state_="findPlayerBySID(fID)"
                                        }else{
                                            state_="FID-player"
                                            m=player;
                                        }
                                    }else{
                                        state_="mainPosValue"
                                        m=mainPosValue
                                    }
                                }
                                else{
                                    state_="player"
                                    m=player;
                                }
                                _things.m=m;
                                delete _things.enemy2
                                if (!isNaN(Number(GM_getValue('k')))&&GM_getValue(GM_getValue('k'))) {
                                    let t=findPlayerBySID(GM_getValue('k'));
                                    let tt=GM_getValue(GM_getValue('k'));
                                    if(t&&!t.death){
                                        state_='Kill'
                                        GM_setValue('breaker',false)
                                        _things.enemy2=t
                                    }else {
                                        state_='Search'
                                        GM_setValue('breaker',true)
                                        let{x,y}=GM_getValue(GM_getValue('k'))
                                        m={x,y}
                                    }
                                }

                                // Offsets/directions
                                const offset = toRad(random([0, 0, -20, 20, -25, 25]));
                                const closestEnemy = _things.enemy2||_things.enemy.enemy;
                                let mustKill//=(closestEnemy.shameTimer>0||closestEnemy.skinIndex==45||closestEnemy.shameCount>=5)
                                //if(closestEnemy)mustKill=(closestEnemy.shameTimer>0||closestEnemy.skinIndex==45||closestEnemy.shameCount>=5);
                                //_things.stealT=_things.stealT||mustKill
                                _things.stealM=_things.stealM||mustKill
                                // Breaker checks and chat
                                breaker = GM_getValue('breaker') || false;
                                if (!breakk && breakk !== breaker && closestEnemy) {
                                    sendChat('Sorry but I gotta blast');
                                } else if (breakk && breakk !== breaker && closestEnemy) {
                                    sendChat('Time for Some action :p');
                                }
                                breakk = GM_getValue('breaker');
                                // Weapons / damage logic
                                const playerWeapons = player.weapons;
                                const primaryWeapon = weapons.find((w) => w.id === playerWeapons[0]);
                                const secondaryWeapon = weapons.find((w) => w.id === playerWeapons[1]);
                                const weaponToUse = primaryWeapon.dmg < 9 && secondaryWeapon
                                ? secondaryWeapon
                                : primaryWeapon;

                                // Find current weapon index
                                const currentIndex = _things.player.weapons.indexOf(_things.player.weaponIndex);

                                // Filter objects from _things.liztobj
                                const activeObjects = _things.liztobj.filter(
                                    (tmp) => tmp.active && _things.liztobj.includes(tmp) && tmp.render
                                );

                                // Filter out certain items
                                let list_ = activeObjects.filter((e) => e.id && !e.name.includes('mill'));
                                const anyButTrapAndSpike_ = list_.filter(
                                    (e) => !(
                                        e.name.includes('pike') ||
                                        e.name.includes('rap')
                                    )
                                );

                                list_ = list_.filter((e) => !e.name.includes('mill'));
                                const anyButTrapAndSpike = list_.filter(
                                    (e) => !(
                                        e.name.includes('pike') ||
                                        e.name.includes('rap')
                                    )
                                );


                                const list__ = activeObjects.filter(
                                    (targetItem) => targetItem.id && !(
                                        targetItem.name.includes('pike') ||
                                        targetItem.name.includes('trap')
                                    )
                                );

                                // Avoid portals if "weaponGrind" not checked
                                const avoidPort = getEl("weaponGrind").checked
                                ? []
                                : list_.filter((obj) => obj.name.includes('port'));

                                list_ = list_.filter((e) => !e.name.includes('port'));

                                const hasRanged = secondaryWeapon&&secondaryWeapon.projectile !== undefined;
                                const closeItem = findClosestList(player.x, player.y, list_);

                                // For item-breaking logic
                                const itemsToBreak = list_.filter((item) => {
                                    const distanceToMain = getDistance(m.x, m.y, item.x, item.y);
                                    return distanceToMain <= 500;
                                });
                                const itemsToBreak_ = list__.filter((item) => {
                                    const distanceToMain = getDistance(player.x, player.y, item.x, item.y);
                                    return distanceToMain <= 500;
                                });

                                // Obstacles
                                const obstacles = getObstaclesNearPlayer(player, _things.liztobj);
                                const obstacles2 = getAllObstaclesNearPlayer(player, _things.liztobj);

                                // Enemy calculations
                                const targetDirEnemy = closestEnemy && (closestEnemy.targetDir + offset);
                                const distanceToEnemy =
                                      closestEnemy && getDistance(player.x, player.y, closestEnemy.x, closestEnemy.y);
                                const maxWeaponRange = 100 + 98;

                                // Shield checks
                                autoShield =
                                    GM_getValue('shield') &&
                                    _things.player.weapons[1] === 11 ||
                                    false;

                                // Space check
                                let hasSpace = true;
                                const possibleObjs = activeObjects.filter((e) => !!e.id);
                                if (possibleObjs.length) {
                                    const closest = findClosestList(
                                        _things.player.x,
                                        _things.player.y,
                                        possibleObjs
                                    );
                                    let othersFar = _things.enemy_.every(e => {
                                        let tr;
                                        if (typeof e.dist2 !== "number") tr = false;
                                        else tr = e.dist2 > 190;
                                        return tr;
                                    });


                                    hasSpace =
                                        (getDistance(_things.player.x, _things.player.y, closest.x, closest.y) >
                                         190)&&othersFar
                                }
                                if (
                                    _things.liztobj.some(
                                        (obj) => obj.active&&obj.blocker && getDistance(player.x, player.y, obj.x, obj.y) < 500
                                    )
                                ) {
                                    // Gather all blockers in range
                                    const blockersInRange = _things.liztobj.filter(
                                        (obj) => obj.blocker &&obj.active&& getDistance(player.x, player.y, obj.x, obj.y) < 500
                                    );
                                    const targetBlock = findClosestList(player.x, player.y, blockersInRange);

                                    // Calculate direction/distance
                                    const dir = getDirection(player, targetBlock);
                                    const dist = getDistance(player.x, player.y, targetBlock.x, targetBlock.y);

                                    // Use the same melee logic from itemsToBreak
                                    const melee =
                                          weapons
                                    .filter((e) => e.type === 0)
                                    .find((w) => w.id === playerWeapons[1]) ||
                                          weapons.find((w) => w.id === playerWeapons[0]);
                                    const range = melee.range + 30;
                                    // Decide which weapon ID to use (mirroring the item-break logic)
                                    const usePrime = 0; // keep logic consistent
                                    var usedID =
                                        usePrime&&player.weapons[0]!=8
                                    ? player.weapons[0]
                                    : _things.player.weaponIndex === 10
                                    ? 10
                                    : _things.player.weapons[1] === 10
                                    ? 10
                                    : _things.player.weapons[0];

                                    if (dist <= range) {
                                        // Attack the blocker
                                        selectWeapon(usedID);
                                        _things.packet(_things.moveKey, null, 1);

                                        if (!player.reloads[usedID]) {
                                            buyEquip(player.reloads[usedID] === 0 ? 40 : 6, 0);
                                            _things.packet(_things.atkKey, 1, dir, 1);
                                            _things.packet(_things.atkKey, 0, dir, 1);
                                        }
                                    } else {
                                        // Pathfind or move closer
                                        isMovingAuto = 1;
                                        [targetPos, offsetPos_, obss] = [targetBlock, 0, UseGM];
                                    }

                                    return;
                                }
                                autoRuby&&closestEnemy&&(getEl("weaponGrind").checked = false);
                                // ----------- Auto Ruby Logic -----------
                                if (player.skins[40]&&autoRuby &&hasTurret &&_things.player.age >= 8 &&(hasSpace || getEl("weaponGrind").checked) &&!closestEnemy
                                   ) {
                                    IsautoRuby=true
                                    getEl("weaponGrind").checked = true;
                                    stop();

                                    // Precompute some references
                                    const rubyIndex = gameLoopState.rubyIndex;
                                    let wantedSkinIndex = player.reloads[player.weapons[rubyIndex]] === 0 ? 40 : 6;
                                    let canHit = player.reloads[player.weapons[rubyIndex]] === 0;
                                    hasPoleNHammer=hasham&&haspole
                                    let sMax=hasham?primaryGrindVariant:3
                                    let pMax=haspole?secondaryGrindVariant:2
                                    let sDone=player.secondaryVariant>=hasham||!!secondaryWeapon.req || secondaryWeapon.id == 11
                                    //if(!!secondaryWeapon.req || secondaryWeapon.id == 11)
                                    let pDone=player.primaryVariant>=pMax||primaryWeapon.id==8||(haspole && hasham && !grindPole);
                                    if(!sDone){
                                        gameLoopState.rubyIndex=1
                                    }else if(!pDone){
                                        gameLoopState.rubyIndex=0;
                                    }
                                    const equippedWeapon = _things.player.weapons[gameLoopState.rubyIndex];
                                    if(sDone&&pDone){
                                        IsautoRuby=false;
                                        getEl("weaponGrind").checked = false;
                                        autoRuby = false;
                                    }
                                    if (equippedWeapon !== _things.player.weaponIndex) {
                                        selectWeapon(equippedWeapon);
                                    }
                                    else if (canHit) {
                                        if (_things.player.skinIndex !== wantedSkinIndex) {
                                            buyEquip(wantedSkinIndex, 0);
                                        }
                                        _things.packet(_things.atkKey, 1, rubyDir, 1);
                                        _things.packet(_things.atkKey, 0, rubyDir, 1);
                                    }
                                    return;
                                }
                                else if(player.age>=8&&autoRuby){
                                    console.log('Waiting...',{
                                        skin40:player.skins[40],hasTurret,grindOrSpace:(hasSpace || getEl("weaponGrind").checked),
                                        isNear:!closestEnemy
                                    })
                                }

                                // Closest objects in line of sight if there is an enemy
                                let closeObjs = [];
                                if (closestEnemy) {
                                    closeObjs = getObjectsInLineOfSight(closestEnemy, _things.player);
                                }
                                if(closestEnemy&&_things.stealT&&player.reloads[53]&&_things.enemy.enemy.dist2<=700){buyEquip(53,0)}
                                if(!closeObjs.length&&closestEnemy&&_things.stealT&&hasRanged&&!instaC.isTrue){_things.aimAt(_things.enemy.enemy);instaC.rangeType()}
                                // Check enemy states and try to shield if necessary
                                if (closestEnemy) {
                                    enemy.forEach((e) => {
                                        // Check if enemy has ranged weapon
                                        let w = weapons.find((weapon) => weapon.id === e.primaryIndex && weapon.req);
                                        if (w && w.name) {
                                            const sameDir = e.reloads[w.id] === 0 &&
                                                  e.dir.toFixed(1) === getDirection(e, player).toFixed(1);
                                            w = sameDir ? w : null;
                                        }
                                        my.autoAim = false;

                                        // If there's a threat, aim shield
                                        if (w) {
                                            let shieldDir = getDirection(player, e);
                                            packet('D', shieldDir);
                                            setAim = true;
                                        }
                                    });
                                }


                                let moved = false;

                                // ---------- Avoid portals logic ----------
                                avoidPort.forEach((portalObj) => {
                                    // (Note: This block immediately returns in original code, but left in place.)
                                    return;
                                    const portDist = getDistance(player.x, player.y, portalObj.x, portalObj.y);
                                    const portDirection = getDirection(player, portalObj);

                                    if (portDist < 300) {
                                        const moveDir = _things.player.moveDir;
                                        let angleDifference = portDirection - moveDir;

                                        // Normalize angleDifference
                                        if (angleDifference > Math.PI) {
                                            angleDifference -= 2 * Math.PI;
                                        } else if (angleDifference < -Math.PI) {
                                            angleDifference += 2 * Math.PI;
                                        }

                                        // Adjust direction to avoid portal
                                        let escapeDir = angleDifference > 0
                                        ? moveDir - 0.5
                                        : moveDir + 0.5;

                                        // Keep angle in [0, 2π]
                                        escapeDir = (escapeDir + 2 * Math.PI) % (2 * Math.PI);
                                        moved = true;

                                        _things.packet(_things.moveKey, escapeDir, 1);
                                        return;
                                    }
                                });

                                //autoChat = false;
                                clicks.middle = false;
                                const testing = true;
                                let hasPlat = _things.player.items.includes(15);

                                function enemyDistanceLogic() {
                                    // Use fixed thresholds: 300 is too close, 600 is too far.
                                    let distanceToEnemy = getDistance(player.x, player.y, closestEnemy.x, closestEnemy.y);

                                    if (distanceToEnemy < 500) {
                                        // Enemy too close: set target so enemy ends up ~600 away.
                                        let angleFromEnemy = getDirection(closestEnemy, player);
                                        let newTargetPos = {
                                            x: closestEnemy.x + Math.cos(angleFromEnemy) * 600,
                                            y: closestEnemy.y + Math.sin(angleFromEnemy) * 600
                                        };
                                        [targetPos, offsetPos_, obss] = [newTargetPos, 0, UseGM];
                                        isMovingAuto = 1;
                                    } else if (distanceToEnemy > 550) {
                                        // Enemy too far: move in until enemy is ~600 away.
                                        let angleToEnemy = getDirection(player, closestEnemy);
                                        let moveDistance = distanceToEnemy - 600;
                                        let newTargetPos = {
                                            x: player.x + Math.cos(angleToEnemy) * moveDistance,
                                            y: player.y + Math.sin(angleToEnemy) * moveDistance
                                        };
                                        [targetPos, offsetPos_, obss] = [newTargetPos, 0, UseGM];
                                        isMovingAuto = 1;
                                    } else {
                                        // Enemy is in the optimal zone; hold position and shoot.
                                        clicks.middle = true;
                                        _things.packet(_things.moveKey, null, 1);
                                        isMovingAuto = 0;
                                        targetPos = null;
                                    }
                                }
                                // ---------- AutoBow logic ----------
                                if (autoBow && closestEnemy && !breaker) {
                                    // ----- OBSTACLE BREAK LOGIC (unchanged) -----
                                    if (closeObjs.length) {
                                        const targetObstacle = findClosestList(player.x, player.y, closeObjs);
                                        const obsDir = getDirection(player, targetObstacle);
                                        const obsDist = getDistance(player.x, player.y, targetObstacle.x, targetObstacle.y);

                                        const meleeWeapon = weapons.filter(e => e.type === 0)
                                        .find(w => w.id === playerWeapons[1]) || weapons.find(w => w.id === playerWeapons[0]);
                                        const breakRange = (secondaryWeapon&&secondaryWeapon.id === 10 ? secondaryWeapon.range + 30 : meleeWeapon.range + 30);
                                        const usedBreakID = (_things.player.weaponIndex === 10 || _things.player.weapons[1] === 10)
                                        ? 10 : player.weapons[0];

                                        if (obsDist <= breakRange) {
                                            selectWeapon(usedBreakID);
                                            _things.packet(_things.moveKey, null, 1);
                                            if (!player.reloads[usedBreakID]) {
                                                buyEquip(player.reloads[usedBreakID] === 0 ? 40 : 6, 0);
                                                _things.packet(_things.atkKey, 1, obsDir, 1);
                                                _things.packet(_things.atkKey, 0, obsDir, 1);
                                            }
                                        } else {
                                            isMovingAuto = 1;
                                            [targetPos, offsetPos_, obss] = [targetObstacle, 0, UseGM];
                                        }
                                    } else {
                                        // ----- PLATFORM & MOVEMENT LOGIC -----
                                        // Filter safe platforms: only those at least 300 units from the enemy.
                                        let safePlatforms = list_.filter(e => e.name.includes("platform") &&
                                                                         getDistance(e.x, e.y, closestEnemy.x, closestEnemy.y) >= 300);
                                        let nearestPlat = safePlatforms.length ? findClosestList(player.x, player.y, safePlatforms) : null;

                                        if (nearestPlat) {
                                            let platDist = getDistance(player.x, player.y, nearestPlat.x, nearestPlat.y);
                                            // If we're not yet on the platform (platform is 60-160 units away), move toward it.
                                            if (platDist > 60 && platDist < 160) {
                                                isMovingAuto = 1;
                                                [targetPos, offsetPos_, obss] = [nearestPlat, 0, UseGM];
                                            }
                                            // If we're already on the platform (within 60 units), stop moving and shoot.
                                            else if (platDist <= 60) {
                                                isMovingAuto = 0;
                                                targetPos = null;
                                                clicks.middle = true;
                                                _things.packet(_things.moveKey, null, 1);
                                            }
                                            // If the platform is too far (≥160), fall back to enemy distance logic.
                                            else {
                                                enemyDistanceLogic();
                                            }
                                        } else {
                                            // No safe platforms available.
                                            if (_things.player.items.includes(15)) {
                                                // Place new platforms in a quad formation.
                                                _things.quad(_things.player.getItemType(22))
                                            }
                                            enemyDistanceLogic();
                                        }
                                    }

                                    // ----- STOP MOVEMENT WHEN TARGET REACHED -----
                                    if (targetPos) {
                                        let distToTarget = getDistance(player.x, player.y, targetPos.x, targetPos.y);
                                        if (distToTarget < 10) {  // threshold (10 units, tweak as needed)
                                            isMovingAuto = 0;
                                            targetPos = null;
                                            _things.packet(_things.moveKey, null, 1); // stop moving
                                        }
                                    }
                                }



                                else if (farmAi && _things.closeAI && autoBow) {
                                    const ai = _things.closeAI.ai;
                                    // Treat the AI as a player target
                                    let distanceToAI = getDistance(player.x, player.y, ai.x, ai.y);

                                    if (distanceToAI < 300) {
                                        // AI is too close – move so that the AI ends up ~600 away.
                                        let angleFromAI = getDirection(ai, player);
                                        let newTargetPos = {
                                            x: ai.x + Math.cos(angleFromAI) * 600,
                                            y: ai.y + Math.sin(angleFromAI) * 600
                                        };
                                        isMovingAuto = 1;
                                        targetPos = newTargetPos;
                                        _things.packet(_things.moveKey, null, 1);
                                    } else if (distanceToAI > 400) {
                                        // AI is too far – move in until it's ~600 away.
                                        let angleToAI = getDirection(player, ai);
                                        let moveDistance = distanceToAI - 600;
                                        let newTargetPos = {
                                            x: player.x + Math.cos(angleToAI) * moveDistance,
                                            y: player.y + Math.sin(angleToAI) * moveDistance
                                        };
                                        isMovingAuto = 1;
                                        targetPos = newTargetPos;
                                        _things.packet(_things.moveKey, null, 1);
                                    } else {
                                        // AI is in the sweet spot – hold position and shoot.
                                        clicks.middle = true;
                                        isMovingAuto = 0;
                                        targetPos = null;
                                        _things.packet(_things.moveKey, null, 1);
                                    }
                                }


                                else if (closestEnemy && !breaker && !onlybreaker && !autoBow) {
                                    let near2 = { inTrap: false };
                                    let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, closestEnemy, 0, 2) <= (closestEnemy.scale + e.getScale() + 5)).sort(function (a, b) {
                                        return UTILS.getDist(a, closestEnemy, 0, 2) - UTILS.getDist(b, closestEnemy, 0, 2);
                                    })[0];
                                    if (nearTrap) {
                                        near2.trap=nearTrap
                                        _things.nearTrap=nearTrap
                                        near2.inTrap = true;
                                    } else {
                                        near2.inTrap = false;
                                    }
                                    isMovingAuto = 1;
                                    //autoChat = 1;

                                    // Enemy has a weapon with range?
                                    const enemyWeaponId = closestEnemy.primaryIndex || 5;
                                    const enemyWeaponRange = weapons.find((e) => e.id === enemyWeaponId).range + 25;
                                    const inEnemyRange = distanceToEnemy <= enemyWeaponRange;
                                    const mustShield =
                                          distanceToEnemy <= maxWeaponRange &&
                                          inEnemyRange > maxWeaponRange &&
                                          _things.player.weapons[1] === 11;

                                    shielding = mustShield;

                                    // If wearing a certain skin (45), retreat
                                    if (_things.player.skinIndex === 45 || player.shameCount>=5) {
                                        [targetPos, offsetPos_, obss] = [closestEnemy, distanceToEnemy + 300, UseGM];
                                        return;
                                    }
                                    if(chainPush){
                                        _things.packet('9',chainDir)
                                        return;
                                    }
                                    let tek=getKnockbackSetupPositions(near2.inTrap?20:(near2.scale*1.8)+(unsafeWindow.newD||0),near2.inTrap?300:600);
                                    _things.getKnockbackSetupPositions=tek
                                    near2.spam=false
                                    let weaponsF = [4, 5].includes(player.primaryIndex)
                                    && player.reloads[player.primaryIndex] !== 0;

                                    // Now weaponsF is strictly true/false, no “undefined” weirdness.

                                    // Check if _all_ weapons are fully reloaded:
                                    let allReloaded = _things.player.weapons.every(
                                        weaponId => _things.player.reloads[weaponId] === 0
                                    );

                                    // Finally, compute shouldbackUp:
                                    let shouldbackUp = unsafeWindow.autoInsta
                                    ? (!allReloaded && [15, 9, 12, 13].includes(player.weapons[1]))
                                    : (player.shame >= 4 || weaponsF);
                                    if(player.weapons[0]==5&&false){
                                        console.log({
                                            shouldbackUp,
                                            poleLoaded:!player.reloads[5],
                                            shouldClearShame:player.shame>=4,
                                            hasHammeer:hasham
                                        })
                                    }
                                    if (shouldbackUp) {
                                        // Bot isn't fully reloaded – move away from the enemy.
                                        let angleAway = Math.atan2(player.y2 - closestEnemy.y, player.x2 - closestEnemy.x);
                                        // Use a reasonable distance, like 400, instead of 999 if that's too extreme.
                                        let targetX = closestEnemy.x + Math.cos(angleAway) * 400;
                                        let targetY = closestEnemy.y + Math.sin(angleAway) * 400;
                                        [targetPos, offsetPos_, obss] = [{ x: targetX, y: targetY }, null, UseGM];
                                    }
                                    else if (near2.inTrap) {
                                        near2.spam=false;
                                        const trap  = nearTrap;
                                        const en    = _things.enemy.enemy;
                                        const trapR = trap.getScale();    // trap radius
                                        const posR  = player.scale;       // player radius

                                        // 1️⃣ compute “just‐touch” spot behind trap (pos1)
                                        const behindAng = en.dir + Math.PI;
                                        const touchDist = trapR + posR;   // exact tangency
                                        const pX = trap.x + Math.cos(behindAng) * touchDist;
                                        const pY = trap.y + Math.sin(behindAng) * touchDist;
                                        _things.pos1 = { x: pX, y: pY, scale: posR };
                                        _things.trap  = { x: trap.x, y: trap.y, scale: trapR };

                                        // 2️⃣ distance checks
                                        const dTrap  = getDistance(player.x2, player.y2, trap.x, trap.y);
                                        const dEnemy = getDistance(player.x2, player.y2, en.x,   en.y);
                                        if (dTrap > 220 || dEnemy > 220) {
                                            // — far: just go straight, clear any curve path
                                            [ targetPos, offsetPos_, obss ] = [
                                                { x: pX, y: pY },
                                                null,
                                                UseGM
                                            ];
                                            _things.path = [];  // no render
                                            near2.spam=!(_things.getKnockbackSetupPositions&&getKnockbackSetupPositions.length)

                                        } else {
                                            near2.spam=false
                                            [ targetPos, offsetPos_, obss ] = [
                                                null,
                                                null,
                                                UseGM
                                            ];
                                            const en=_things.enemy.enemy
                                            // ── 1) in your `else if(near2.inTrap){…}` block, after you have pX,pY:
                                            const enX      = en.x, enY = en.y;
                                            const p0       = { x: player.x2, y: player.y2 };
                                            const p2       = { x: pX, y: pY };                   // pos1
                                            const arcR     = player.scale * 2;                      // enemyRadius*2
                                            // angles from enemy→player & enemy→pos1
                                            const a0       = Math.atan2(p0.y - enY, p0.x - enX);
                                            const a2       = Math.atan2(p2.y - enY, p2.x - enX);
                                            // P₁ = point on that big circle at angle = a0
                                            const p1       = {
                                                x: enX + Math.cos(a0) * arcR,
                                                y: enY + Math.sin(a0) * arcR
                                            };
                                            let delta = a2 - a0;
                                            delta = ((delta + Math.PI) % (2 * Math.PI)) - Math.PI;

                                            // then split into ~16 steps, preserving sign
                                            _things.arcStep  = delta / 16;
                                            _things.arcAngle = a0;
                                            // stash for render + movement
                                            _things.pathVisual = { p0, p1, p2, a0, a2, arcR };
                                            // close: slam two direct‐move packets and skip pathfinder
                                            targetPos  = null;
                                            offsetPos_ = null;
                                            obss       = UseGM;

                                            const v = _things.pathVisual;
                                            if (v) {
                                                let ang    = _things.arcAngle;
                                                const Δ     = v.a2 - v.a0;
                                                const step  = _things.arcStep;

                                                // 1️⃣ if we haven’t reached the end‐angle, advance by one step
                                                if ((Δ > 0 && ang < v.a2) || (Δ < 0 && ang > v.a2)) {
                                                    ang = Math.abs(ang + step - v.a2) < Math.abs(step)
                                                        ? v.a2
                                                    : ang + step;

                                                    _things.arcAngle = ang;

                                                    // 2️⃣ compute the next arc point around the enemy
                                                    const next = {
                                                        x: v.p0.x, y: v.p0.y  // default fallback
                                                    };
                                                    const ex = en.x, ey = en.y;  // unpack enemy
                                                    next.x = ex + Math.cos(ang) * v.arcR;
                                                    next.y = ey + Math.sin(ang) * v.arcR;

                                                    // 3️⃣ send JUST ONE packet toward that next arc point
                                                    const dir = getDirection(
                                                        { x: player.x2, y: player.y2 },next
                                                    );
                                                    console.log({dir,next,dist:UTILS.getDistance(player.x2,player.y2,next.x,next.y)})
                                                    if(UTILS.getDistance(player.x2,player.y2,next.x,next.y)>10){
                                                        toMove=["9", dir, 1]
                                                        packet("9", dir, 1)
                                                        lastMoveDir=dir
                                                    }else{
                                                        toMove=["9", null, 1]
                                                        packet("9", null, 1)
                                                        lastMoveDir=null
                                                        if (allReloaded && instaC.isTrue&&!useSpam) {
                                                            if (player.skins[40] && _random([0,0,1,1])) {
                                                                instaC.assistInsta(trap);
                                                            } else {
                                                                _things.instaC.hammerInsta(_random([0,1]));
                                                            }
                                                        }
                                                    }
                                                    //packet2(_things.moveKey, dir, 1);

                                                } else {

                                                    // 🔜 once arc is done, head to final P₂ normally
                                                    const dir = getDirection(
                                                        { x: player.x2, y: player.y2 },{ x: v.p2.x,       y: v.p2.y }
                                                    );
                                                    console.log({dir,next:{ x: v.p2.x,       y: v.p2.y }})
                                                    toMove=["9", UTILS.getDirect({ x: v.p2.x,       y: v.p2.y }, player, 0, 2), 1]
                                                    packet("9", UTILS.getDirect({ x: v.p2.x,       y: v.p2.y }, player, 0, 2), 1)
                                                    lastMoveDir=UTILS.getDirect({ x: v.p2.x,       y: v.p2.y }, player, 0, 2)
                                                    lastMoveDir=dir
                                                    packet2(_things.moveKey, dir, 1);

                                                    // clean up so we don’t re‐arc
                                                    delete _things.arcAngle;
                                                    delete _things.arcStep;
                                                }
                                            }

                                        }

                                    }


                                    else {
                                        near2.spam=true
                                        _things.pathVisual=null
                                        if(_things.getKnockbackSetupPositions&&getKnockbackSetupPositions.length){
                                            [targetPos, offsetPos_, obss] = [_things.getKnockbackSetupPositions[0], _things.enemy2?null:null, UseGM];
                                        }else
                                            // Pathfind toward or around the enemy
                                            if (!(distanceToEnemy < primaryWeapon.range + 150)) {
                                                [targetPos, offsetPos_, obss] = [calculateOffsetPosition(closestEnemy, player, primaryWeapon.range - 30), null, UseGM];
                                            }
                                        else if (distanceToEnemy > 60 && !my.autoPush) {
                                            [targetPos, offsetPos_, obss] = [calculateOffsetPosition(closestEnemy, player, -60), _things.enemy2?null:null, UseGM];
                                        }
                                        else {
                                            targetPos = null;
                                            isMovingAuto = false;
                                        }
                                    }
                                    // NEW: Check for objects (non-trap, non-spike) in the way
                                    let objectInWay = null;
                                    for (let obj of anyButTrapAndSpike_) {
                                        // If the object's distance to the enemy is within its effective size (scale * 1.8),
                                        // it's considered "in the way"
                                        if (UTILS.getDist(obj, closestEnemy, 0, 0) <= obj.getScale() * 1.8) {
                                            objectInWay = obj;
                                            break;
                                        }
                                    }
                                    var usedID = 0
                                    ? player.weapons[0]
                                    : _things.player.weaponIndex === 10
                                    ? 10
                                    : _things.player.weapons[1] === 10
                                    ? 10
                                    : _things.player.weapons[0];
                                    // If there's an object in the way and the bot has a hammer in secondary, hit it!
                                    let k=_things.canHit_()
                                    if(k.canHit&&player.reloads[usedID]==0){
                                        buyEquip(40)
                                        usedID=k.usedID
                                        objectInWay= _things.closeItem.item
                                        let attackDir = Math.atan2(objectInWay.y - player.y, objectInWay.x - player.x);
                                        selectWeapon(usedID);
                                        _things.packet(_things.atkKey, 1, attackDir, 1);
                                        _things.packet(_things.atkKey, 0, attackDir, 1);
                                        return;
                                    }
                                    // Attack logic
                                    if (distanceToEnemy <= maxWeaponRange) {
                                        const primaryWeapon = player.weapons[0];
                                        const secondaryWeapon = player.weapons[1];
                                        const inRange = near.dist2 <= items.weapons[primaryWeapon].range + player.scale * 1.8;

                                        if (
                                            !autoShield &&
                                            !autos.antibull &&
                                            !traps.inTrap &&
                                            (mustKill?mustKill:(unsafeWindow.autoInsta&&hasRanged)?
                                             near.shameCount<2:
                                             (useSpam && inRange && near2.spam)) &&
                                            _things.player.skinIndex !== 11 &&
                                            closestEnemy.skinIndex !== 11
                                        ) {
                                            // Engage attack
                                            clicks.left = 1;
                                            my.autoAim = true;
                                        } else if (
                                            autoShield &&
                                            closestEnemy &&
                                            _things.player.weapons[1] === 11 &&
                                            _things.player.weaponCode !== 11
                                        ) {
                                            // Switch to shield
                                            my.autoAim = true;
                                            clicks.left = 0;
                                            if (_things.player.weaponCode !== 11) {
                                                selectWeapon(player.weapons[1]);
                                            }
                                        } else {
                                            clicks.left = 0;
                                            my.autoAim = 0;
                                        }
                                    }
                                    else {
                                        // Out of range: switch back to primary weapon if holding shield
                                        if (_things.player.weaponCode === 11) {
                                            selectWeapon(player.weapons[0]);
                                        }
                                        clicks.left = 0;
                                        my.autoAim = false;
                                    }

                                    // Disable aim if trapped
                                    if (_things.traps.inTrap) {
                                        my.autoAim = false;
                                    }

                                    // ---------- Default: Move to main position or break items ----------
                                }
                                else if (m) {
                                    const usePrime = 0;
                                    // Set up weapon range as before.
                                    const melee = weapons.filter(e => e.type === 0)
                                    .find(w => w.id === playerWeapons[1]) ||
                                          weapons.find(w => w.id === playerWeapons[0]);
                                    const range = secondaryWeapon&&secondaryWeapon.id === 10 ? secondaryWeapon.range + 30 : melee.range + 30;
                                    var usedID = usePrime
                                    ? player.weapons[0]
                                    : _things.player.weaponIndex === 10
                                    ? 10
                                    : _things.player.weapons[1] === 10
                                    ? 10
                                    : player.weapons[0];

                                    // Helper: minimal angular difference (in radians)
                                    function angleDifference(a, b) {
                                        let diff = a - b;
                                        while (diff < -Math.PI) diff += 2 * Math.PI;
                                        while (diff > Math.PI) diff -= 2 * Math.PI;
                                        return diff;
                                    }

                                    // Check if an item is valid based on distance (weapon range) and if it's within ±90° of player.dir.
                                    function isItemValid(player, item, weaponRange) {
                                        const d = getDistance(player.x2, player.y2, item.x, item.y);
                                        if (d > weaponRange) return false; // Not in weapon range.
                                        const angleToItem = getDirection(player, item);
                                        if (Math.abs(angleDifference(player.dir, angleToItem)) > Math.PI / 2) return false; // Outside allowed cone.
                                        return true;
                                    }

                                    if (itemsToBreak.length > 0&&!nonBreak) {
                                        // Filter items that are within weapon range and within the allowed cone.
                                        let validItems = itemsToBreak.filter(item => isItemValid(player, item, range));

                                        if (validItems.length > 0) {
                                            // Cluster items by their attack angle.
                                            const angleThreshold = 0.2; // in radians
                                            let bestCluster = null;
                                            let bestCount = 0;
                                            let bestAngle = null;
                                            //console.log(validItems[0])
                                            for (let candidate of validItems) {
                                                const candidateAngle = getDirection(player, candidate);
                                                if (Math.abs(angleDifference(player.dir, candidateAngle)) > Math.PI / 2) continue;
                                                // Create a cluster of items near this candidate angle.
                                                let cluster = validItems.filter(item => {
                                                    const itemAngle = getDirection(player, item);
                                                    return Math.abs(angleDifference(candidateAngle, itemAngle)) <= angleThreshold;
                                                });
                                                if (cluster.length > bestCount) {
                                                    bestCount = cluster.length;
                                                    bestCluster = cluster;
                                                    bestAngle = candidateAngle;
                                                }
                                            }

                                            // Compute the centroid of the best cluster.
                                            let clusterCenter = { x: 0, y: 0 };
                                            for (let item of bestCluster) {
                                                clusterCenter.x += item.x;
                                                clusterCenter.y += item.y;
                                            }
                                            clusterCenter.x /= bestCluster.length;
                                            clusterCenter.y /= bestCluster.length;

                                            // Determine distance from player to the cluster center.
                                            let centerDistance = getDistance(player.x2, player.y2, clusterCenter.x, clusterCenter.y);
                                            let centerDistance2 = getDistance(player.x3, player.y3, clusterCenter.x, clusterCenter.y);
                                            if (!player.reloads[usedID]&&centerDistance2 <= range) {
                                                selectWeapon(usedID);
                                                buyEquip(player.reloads[usedID] === 0 ? 40 : 6, 0);
                                                _things.packet(_things.atkKey, 1, bestAngle, 1);
                                                _things.packet(_things.atkKey, 0, bestAngle, 1);
                                            }
                                            if (centerDistance <= range) {
                                                stop()
                                            } else {
                                                let k=_things.canHit_()
                                                if(k.canHit&&player.reloads[usedID]==0){
                                                    buyEquip(40)
                                                    usedID=k.usedID
                                                    let objectInWay= _things.closeItem.item
                                                    let attackDir = Math.atan2(objectInWay.y - player.y, objectInWay.x - player.x);
                                                    selectWeapon(usedID);
                                                    _things.packet(_things.atkKey, 1, attackDir, 1);
                                                    _things.packet(_things.atkKey, 0, attackDir, 1);
                                                    return;
                                                }
                                                isMovingAuto = 1;
                                                [targetPos, offsetPos_, obss] = [clusterCenter, 0, UseGM];
                                            }
                                        }
                                        else {
                                            // Fallback: use original logic with the closest item.
                                            const targetItem = findClosestList(player.x, player.y, itemsToBreak);
                                            let centerDistance2 = getDistance(player.x3, player.y3, targetItem.x, targetItem.y);
                                            const dir = getDirection(player, targetItem);
                                            const dist = getDistance(player.x, player.y, targetItem.x, targetItem.y);
                                            if (!player.reloads[usedID]&&centerDistance2<range) {
                                                selectWeapon(usedID);
                                                buyEquip(player.reloads[usedID] === 0 ? 40 : 6, 0);
                                                _things.packet(_things.atkKey, 1, dir, 1);
                                                _things.packet(_things.atkKey, 0, dir, 1);
                                            }
                                            if (dist <= range) {
                                                stop()
                                            } else {
                                                let k=_things.canHit_()
                                                if(k.canHit&&player.reloads[usedID]==0){
                                                    buyEquip(40)
                                                    usedID=k.usedID
                                                    let objectInWay= _things.closeItem.item
                                                    let attackDir = Math.atan2(objectInWay.y - player.y, objectInWay.x - player.x);
                                                    selectWeapon(usedID);
                                                    _things.packet(_things.atkKey, 1, attackDir, 1);
                                                    _things.packet(_things.atkKey, 0, attackDir, 1);
                                                    return;
                                                }
                                                isMovingAuto = 1;
                                                [targetPos, offsetPos_, obss] = [targetItem, 0, UseGM];
                                            }
                                        }
                                    }

                                    else {
                                        // Move toward main position `m`
                                        const distanceToMain = getDistance(player.x, player.y, m.x, m.y);
                                        const desiredDir = getDirection(player, m);
                                        //console.log(m,":",distanceToMain,obstacles2)
                                        if (distanceToMain <=(autoRuby?500:GM_getValue('r',300))) {
                                            // Stop if close enough
                                            stop()
                                        } else {
                                            // Use pathfinding or direct offset
                                            isMovingAuto = 1;
                                            //console.log(m,m, 500, obstacles2);
                                            let farOut=Math.min(((config.maxScreenWidth / (10/9)) * 1.3)-1,distanceToMain)/2
                                            ;[targetPos, offsetPos_, obss] = [m, farOut, UseGM];
                                            let k=_things.canHit_()
                                            if(k.canHit&&player.reloads[usedID]==0){
                                                buyEquip(40)
                                                usedID=k.usedID
                                                let objectInWay= _things.closeItem.item
                                                let attackDir = Math.atan2(objectInWay.y - player.y, objectInWay.x - player.x);
                                                selectWeapon(usedID);
                                                _things.packet(_things.atkKey, 1, attackDir, 1);
                                                _things.packet(_things.atkKey, 0, attackDir, 1);
                                                return;
                                            }
                                        }
                                    }
                                }

                            }()
                            target=[targetPos,offsetPos_,obss]
                            if(autoGo&&!target[0])lastMoveDir=null
                            let hatChanger = function() {
                                if(IsautoRuby)return;
                                if (my.anti0Tick > 0) {
                                    buyEquip(6, 0);
                                }
                                else {
                                    if (clicks.left || clicks.right) {
                                        if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                            buyEquip(13, 1);
                                        } else {
                                            if (clicks.left) {
                                                buyEquip(player.reloads[player.weapons[0]] == 0 ? getEl("weaponGrind").checked ? 40 : 7 : player.empAnti ? 22 : player.soldierAnti ? 6 : (getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : near.dist2 <= 450 ? (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6 : biomeGear(1, 1), 0);
                                            } else if (clicks.right) {
                                                buyEquip(player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 ? 40 : player.empAnti ? 22 : player.soldierAnti ? 6 : (getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : near.dist2 <= 450 ? (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6 : biomeGear(1, 1), 0);
                                            }
                                        }
                                    } else if (traps.inTrap) {
                                        if (traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                            buyEquip(40, 0);
                                        } else {
                                            if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                                console.log('1',game.tick,player.bullTimer,config.serverUpdateRate)
                                                let lastHat=player.skinIndex
                                                buyEquip(7, 0);

                                                buyEquip(13, 1);

                                            } else {
                                                buyEquip((player.empAnti || near.dist2 > 450 || !enemy.length) ? 22 : 6, 0);
                                            }
                                        }
                                    }
                                    else if (nearspiker) {
                                        if (info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                            buyEquip(40, 0);
                                            if (near.dist2 > 300 && (!player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                                buyEquip(6, 0);
                                            }
                                        }
                                        else {
                                            if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                                buyEquip(7, 0);
                                                console.log('2',game.tick,player.bullTimer,config.serverUpdateRate)
                                            } else {
                                                buyEquip(22, 0);
                                            }
                                        }
                                    }
                                    else {
                                        if (player.empAnti || player.soldierAnti) {
                                            buyEquip(player.empAnti ? 22 : 6, 0);
                                            buyEquip(13, 1);
                                        } else {
                                            if (player.skins[7]&&((player.shameCount > 0 && (((game.tick - player.bullTick) % config.serverUpdateRate))<1 && player.skinIndex != 45) || (my.reSync,false))) {
                                                buyEquip(7, 0);
                                                buyEquip(13, 1);
                                                console.log('3',game.tick,player.bullTimer,config.serverUpdateRate,((game.tick - player.bullTick) % config.serverUpdateRate),player.bullTick% config.serverUpdateRate,config.serverUpdateRate%player.bullTick)
                                            } else {
                                                if (near.dist2 <= 450) {
                                                    buyEquip((getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6, 0);
                                                } else {
                                                    biomeGear(1);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let hatChanger2 = function() {
                                if (my.anti0Tick > 0) {
                                    buyEquip((_things.player.moveDir!=undefined||isMovingAuto)?12:6, 0);
                                } else {
                                    if (clicks.left || clicks.right) {
                                        if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                            buyEquip(13, 1);
                                        } else {
                                            if (clicks.left) {
                                                let buyValue;

                                                if (player.reloads[player.weapons[0]] == 0) {
                                                    if (getEl("weaponGrind").checked) {
                                                        buyValue = 40;
                                                    } else {
                                                        buyValue = 7;
                                                    }
                                                } else if (player.empAnti) {
                                                    buyValue = 22;
                                                } else if (player.soldierAnti) {
                                                    buyValue = 6;
                                                } else if (getEl("antiBullType").value == "abreload" && near.antiBull > 0) {
                                                    buyValue = 11;
                                                } else if (near.dist2 <= 450) {
                                                    if (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) {
                                                        buyValue = 11;
                                                    } else {
                                                        buyValue = 6;
                                                    }
                                                } else {
                                                    buyValue = biomeGear(1, 1);
                                                }

                                                buyEquip(buyValue, 0);
                                            } else if (clicks.right) {
                                                buyEquip(player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 ? 40 : player.empAnti ? 22 : player.soldierAnti ? 6 : (getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : near.dist2 <= 450 ? (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6 : biomeGear(1, 1), 0);
                                            }
                                        }
                                    }
                                    else if (traps.inTrap) {
                                        if (traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                            buyEquip(40, 0);
                                        } else {
                                            if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                                buyEquip(7, 0);
                                                buyEquip(13, 1);

                                            } else {
                                                buyEquip((player.empAnti || near.dist2 > 450 || !enemy.length) ? 22 : 6, 0);
                                            }
                                        }
                                    }
                                    else if (nearspiker) {
                                        if (info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                            buyEquip(40, 0);
                                            if (near.dist2 > 300 && (!player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                                buyEquip(6, 0);
                                            }
                                        }
                                        else {
                                            if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                                buyEquip(7, 0);
                                            } else {
                                                buyEquip(22, 0);
                                            }
                                        }
                                    }
                                    else {
                                        if (player.empAnti || player.soldierAnti) {
                                            buyEquip(player.empAnti ? 22 : 6, 0);
                                            buyEquip(13, 1);
                                        } else {
                                            if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                                buyEquip(7, 0);
                                                buyEquip(13, 1);
                                            } else {
                                                if (near.dist2 <= 450) {
                                                    buyEquip((getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6, 0);
                                                } else {
                                                    biomeGear(1);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let accChanger = function() {
                                //if(my.autoPush2)return;
                                let NearHasOneFrame = near.primaryVariant >= 1 && near.weapons[0] == 5
                                let PolOrKat = player.weapons[0] === 4 || player.weapons[0] === 5
                                let canSafeHitback = PolOrKat && !traps.inTrap && player.shameCount <= 4 && !NearHasOneFrame && !antispiketicked && !safewalking
                                if (instaC.can && player.checkCanInsta(true) >= 100) {
                                    // buyEquip(19, 1);
                                } else if (clicks.left) {
                                    setTimeout(() => {
                                        buyEquip(19, 1);
                                    }, 100);
                                } else if (clicks.right) {
                                    setTimeout(() => {
                                        buyEquip(19, 1);
                                    }, 50);
                                } else if (near.dist2 <= 350 && !traps.inTrap && player.weapons[0] == 7) {
                                    buyEquip(11, 1);
                                } else if (near.dist2 <= 350 && !traps.inTrap) {
                                    buyEquip(19, 1);
                                } else if (near.dist2 <= 350 && !traps.inTrap && configs.HKH && player.skinIndex == 11) {
                                    buyEquip(21, 1);
                                } else {
                                    traps.inTrap ? buyEquip(19, 1) : buyEquip(11, 1);
                                }
                            };

                            let wasdGears = function() {
                                if (my.anti0Tick > 0) {
                                    buyEquip(6, 0);
                                } else {
                                    if (clicks.left || clicks.right) {
                                        if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                        } else {
                                            if (clicks.left) {
                                                buyEquip(player.reloads[player.weapons[0]] == 0 ? getEl("weaponGrind").checked ? 40 : 7 : player.empAnti ? 22 : 6, 0);
                                            } else if (clicks.right) {
                                                buyEquip(player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 ? 40 : player.empAnti ? 22 : 6, 0);
                                            }
                                        }
                                    } else if (near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap) {
                                        if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                        } else {
                                            buyEquip(player.reloads[player.weapons[0]] == 0 ? 7 : player.empAnti ? 22 : 6, 0);
                                        }
                                    } else if (traps.inTrap) {
                                        if (traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                            buyEquip(40, 0);
                                        } else {
                                            if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                                buyEquip(7, 0);
                                            } else {
                                                buyEquip(player.empAnti ? 22 : 6, 0);
                                            }
                                        }
                                    } else {
                                        if (player.empAnti) {
                                            buyEquip(22, 0);
                                        } else {
                                            if ((player.shameCount > 0 && ((game.tick - player.bullTick) % config.serverUpdateRate) === 0 && player.skinIndex != 45) || my.reSync) {
                                                buyEquip(7, 0);
                                            } else {
                                                buyEquip(6, 0);
                                            }
                                        }
                                    }
                                }
                                if (clicks.left || clicks.right) {
                                    if (clicks.left) {
                                        buyEquip(0, 1);
                                    } else if (clicks.right) {
                                        buyEquip(11, 1);
                                    }
                                } else if (near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap) {
                                    buyEquip(0, 1);
                                } else if (traps.inTrap) {
                                    buyEquip(0, 1);
                                } else {
                                    buyEquip(11, 1);
                                }
                            }

                            if (storeMenu.style.display != "block" && !instaC.isTrue && !instaC.ticking) {
                                if (useWasd) {
                                    wasdGears();
                                } else {
                                    hatChanger();
                                    accChanger();
                                }
                            }
                            //lastMoveDir = getSafeDir();
                            //packet("33", lastMoveDir, 1);
                            if (player.alive && inGame && configs.safeWalk) safeWalk();
                            //_things.autoPushVisual()
                            if (configs.autoPush && enemy.length && !traps.inTrap && !instaC.ticking) {
                                autoPush();
                            } else {
                                if (my.autoPush) {
                                    my.autoPush = false;
                                    packet("9", lastMoveDir||undefined, 1);
                                    retrappable = false;
                                }
                            }

                            if (!my.autoPush && pathFind.active) {
                                const pathfindLoop = () => {
                                    return;
                                    Pathfinder();
                                    game.tickBase(() => pathfindLoop(), 1);
                                };
                                pathfindLoop();
                            }

                            if (!my.autoPush||!my.autopush2) {
                                retrappable = false;
                            }
                            if ((!my.autoPush||my.autoPush2) && targetPos&&!!0) {
                                unsafeWindow.can = 0;
                                pathFind.active = true;

                                // 1️⃣ compute your escapePos once
                                const escapePos = calculateOffsetPosition(
                                    { x: player.x2, y: player.y2 },
                                    targetPos,
                                    offsetPos_
                                );

                                // 2️⃣ only regenerate path when needed
                                if (shouldRepath()) {
                                    // feed new target into our cached A*
                                    Pathfinder(escapePos, 0, 0);
                                }

                                // 3️⃣ step along the cached path
                                followPath();
                            }

                            if(!0&&!(my.autoPush||my.autoPush2)&&targetPos){
                                unsafeWindow.can=0
                                //setTimeout(()=>unsafeWindow.can=1,100)
                                pathFind.active = true;
                                let escapePos
                                //for(let i=offsetPos_;i>0;i++){
                                escapePos = calculateOffsetPosition({x:player.x2,y:player.y2}, targetPos, offsetPos_);
                                SendPathWithObstacles(escapePos, obss);

                                try {
                                    Pathfinder(escapePos, 0, 0);
                                    if (pathFind.array.length > 0&&!(secPacket >= 90)) {
                                        const nextStep = pathFind.array[1];
                                        const moveTarget = {
                                            x: (player.x2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * nextStep.x),
                                            y: (player.y2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * nextStep.y)
                                        };
                                        _things.packet(_things.moveKey, UTILS.getDirect(moveTarget, player, 0, 2), 1);
                                        // break;
                                    }
                                } catch (error) {
                                    console.error("Pathfinding error:", error);
                                    //break;
                                }
                                ///}
                            }
                            if (instaC.ticking) {
                                instaC.ticking = false;
                            }
                            if (instaC.syncHit) {
                                instaC.syncHit = false;
                            }
                            if (player.empAnti) {
                                player.empAnti = false;
                            }
                            if (player.soldierAnti) {
                                player.soldierAnti = false;
                            }
                            if (my.anti0Tick > 0) {
                                my.anti0Tick--;
                            }
                            if (traps.replaced) {
                                traps.replaced = false;
                            }
                            if (traps.antiTrapped) {
                                traps.antiTrapped = false;
                            }
                        }
                        unsafeWindow.canGO=!unsafeWindow.canGO
                        if(!millDone&&autoGo){
                            lastMoveDir=millAngle_
                            toMove[1]=millAngle_
                            packet("9",millAngle_,1)
                        }
                        if(unsafeWindow.canGO&&player.moveDir!=toMove[1]&&autoGo&&!traps.inTrap&&(targetPos||_things.autoPushChain.moveDir)){
                            if(_things.autoPushChain.moveDir)toMove[1]=_things.autoPushChain.moveDir+Math.PI;
                            lastMoveDir=toMove[1];packet(...toMove)
                        }
                    }
                    if (botSkts.length) {
                        botSkts.forEach((bots) => {
                            if (true) {
                                bots[0].ssend("player", player, near, botIDS);
                            }
                        });
                    }
                }

                //antipush
                /*   for(var i1 = 0; i1 < liztobj.length; i1++) {
                if (liztobj[i1].active && liztobj[i1].health > 0 && UTILS.getDist(liztobj[i1], player, 0, 2) < 150) { // || liztobj[i1].buildHealth <= items.weapons[nearEnemy.weaponIndex].dmg)

                    if(liztobj[i1].name.includes("spike") && liztobj[i1]){
                        if(liztobj[i1].owner.sid != player.sid && clicks.left == false && tmpObj.reloads[tmpObj.secondaryIndex] == 0){
                            selectWeapon(player.weapons[1])
                            buyEquip(40, 0);
                            packet("D", UTILS.getDirect(liztobj[i1], player, 0, 2))
                            tracker.draw1.active = true;
                            tracker.draw1.x = gameObjects[i1].x;
                            tracker.draw1.y = gameObjects[i1].y;
                            tracker.draw1.scale = gameObjects[i1].scale;
                            game.tickBase(() => {
                                buyEquip(6, 0);
                            }, 1);
                        }
                    }
                }
            }*/
                // UPDATE LEADERBOARD:
                function updateLeaderboard(data) {
                    lastLeaderboardData = data;
                    return;
                    UTILS.removeAllChildren(leaderboardData);
                    let tmpC = 1;
                    for (let i = 0; i < data.length; i += 3) {
                        (function(i) {
                            UTILS.generateElement({
                                class: "leaderHolder",
                                parent: leaderboardData,
                                children: [
                                    UTILS.generateElement({
                                        class: "leaderboardItem",
                                        style: "color:" + ((data[i] == playerSID) ? "#fff" : "rgba(255,255,255,0.6)"),
                                        text: tmpC + ". " + (data[i+1] != "" ? data[i+1] : "unknown")
                                    }),
                                    UTILS.generateElement({
                                        class: "leaderScore",
                                        text: UTILS.sFormat(data[i+2]) || "0"
                                    })
                                ]
                            });
                        })(i);
                        tmpC++;
                    }
                }

                // LOAD GAME OBJECT:
                function loadGameObject(data) {
                    for (let i = 0; i < data.length;) {
                        objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4],
                                          data[i + 5], items.list[data[i + 6]], true, (data[i + 7] >= 0 ? {
                            sid: data[i + 7]
                        } : null));
                        // sid, x, y, dir, s, type, data, setSID, owner
                        /*let dist = UTILS.getDist({
                        x: data[i + 1],
                        y: data[i + 2]
                    }, player, 0, 2);
                    let aim = UTILS.getDirect({
                        x: data[i + 1],
                        y: data[i + 2]
                    }, player, 0, 2);
                    find = findObjectBySid(data[i]);
                    if (data[i + 6] == 15) {
                        if (find && !find.isTeamObject(player)) {
                            if (dist <= 100) {
                                traps.dist = dist;
                                traps.aim = aim;
                                traps.protect(aim);
                            }
                        }
                    }*/
                        i += 8;
                    }
                }

                // ADD AI:
                function loadAI(data) {
                    for (let i = 0; i < ais.length; ++i) {
                        ais[i].forcePos = !ais[i].visible;
                        ais[i].visible = false;
                    }
                    if (data) {
                        let tmpTime = performance.now();
                        for (let i = 0; i < data.length;) {
                            tmpObj = findAIBySID(data[i]);
                            if (tmpObj) {
                                tmpObj.index = data[i + 1];
                                tmpObj.t1 = (tmpObj.t2 === undefined) ? tmpTime : tmpObj.t2;
                                tmpObj.t2 = tmpTime;
                                tmpObj.x1 = tmpObj.x;
                                tmpObj.y1 = tmpObj.y;
                                tmpObj.x2 = data[i + 2];
                                tmpObj.y2 = data[i + 3];
                                tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 4] : tmpObj.d2;
                                tmpObj.d2 = data[i + 4];
                                tmpObj.health = data[i + 5];
                                tmpObj.dt = 0;
                                tmpObj.visible = true;
                            } else {
                                tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1]);
                                tmpObj.x2 = tmpObj.x;
                                tmpObj.y2 = tmpObj.y;
                                tmpObj.d2 = tmpObj.dir;
                                tmpObj.health = data[i + 5];
                                if (!aiManager.aiTypes[data[i + 1]].name)
                                    tmpObj.name = config.cowNames[data[i + 6]];
                                tmpObj.forcePos = true;
                                tmpObj.sid = data[i];
                                tmpObj.visible = true;
                            }
                            i += 7;
                        }
                    }
                }

                // ANIMATE AI:
                function animateAI(sid) {
                    tmpObj = findAIBySID(sid);
                    if (tmpObj) tmpObj.startAnim();
                }

                // GATHER ANIMATION:
                function gatherAnimation(sid, didHit, index) {
                    tmpObj = findPlayerBySID(sid);
                    if (tmpObj) {
                        tmpObj.startAnim(didHit, index);
                        tmpObj.gatherIndex = index;
                        tmpObj.gathering = 1;
                        if (didHit) {
                            let tmpObjects = objectManager.hitObj;
                            objectManager.hitObj = [];
                            game.tickBase(() => {
                                // refind
                                tmpObj = findPlayerBySID(sid);
                                let val = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1) * (tmpObj.skinIndex == 40 ? 3.3 : 1);
                                tmpObjects.forEach((healthy) => {
                                    healthy.health -= val;
                                });
                            }, 1);
                        }
                    }
                }

                // WIGGLE GAME OBJECT:
                function wiggleGameObject(dir, sid) {
                    tmpObj = findObjectBySid(sid);
                    if (tmpObj) {
                        tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir);
                        tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir);
                        if (tmpObj.health) {
                            //tmpObj.damaged = Math.min(255, tmpObj.damaged + 60);
                            objectManager.hitObj.push(tmpObj);
                        }
                    }
                }

                // SHOOT TURRET:
                function shootTurret(sid, dir) {
                    tmpObj = findObjectBySid(sid);
                    if (tmpObj) {
                        if (config.anotherVisual) {
                            tmpObj.lastDir = dir;
                        } else {
                            tmpObj.dir = dir;
                        }
                        tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI);
                        tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI);
                    }
                }

                // UPDATE PLAYER VALUE:
                function updatePlayerValue(index, value, updateView) {
                    if (player) {
                        player[index] = value;
                        if (index == "points") {
                            if (configs.autoBuy) {
                                autoBuy.hat();
                                autoBuy.acc();
                            }
                        } else if (index == "kills") {
                            if (configs.killChat) {
                                // helper to grab a random element or fallback
                                function randomChoice(arr, fallback) {
                                    return (Array.isArray(arr) && arr.length)
                                        ? arr[Math.floor(Math.random() * arr.length)]
                                    : fallback;
                                }

                                // split by words into ≤30-char chunks and send each 300 ms apart
                                function sendSplit(msg) {
                                    const words = msg.split(' ');
                                    const chunks = [];
                                    let cur = '';

                                    for (const w of words) {
                                        const next = cur ? `${cur} ${w}` : w;
                                        if (next.length <= 30) {
                                            cur = next;
                                        } else {
                                            chunks.push(cur);
                                            cur = w;
                                        }
                                    }
                                    if (cur) chunks.push(cur);

                                    chunks.forEach((chunk, i) => {
                                        setTimeout(() => sendChat(chunk), i * 501);
                                    });
                                }

                                const killFeedLines = [
                                    v => `Annihilated ${v}`,
                                    v => `Yeeted ${v} no cap`,
                                    v => `GG, ${v} got clapped`,
                                    v => `${v} got skibidi'd`,
                                    v => `${v} sent to Ohio`,
                                    v => `Fanum taxed ${v}`,
                                    v => `Deleted ${v} ez`,
                                    v => `${v}? L bozo`,
                                    v => `Gyat ${v} down bad`,
                                    v => `Skill diff'd ${v}`,
                                    v => `${v} was sus`,
                                    v => `${v} packed like lunch`,
                                    v => `RIP ${v}, uninstall`,
                                    v => `${v} folded hard`,
                                    v => `Blendered ${v}`,
                                    v => `Executed ${v}`,
                                    v => `Lagspiked ${v}`,
                                    v => `Recycled ${v}`,
                                    v => `Dusted ${v}`,
                                    v => `${v} got ratioed`,
                                    v => `Free spawn to ${v}`,
                                    v => `Shadow realmed ${v}`,
                                    v => `Juul pod'd ${v}`,
                                ];

                                const roastLines = [
                                    "You good or just lag?",
                                    "Get better fr",
                                    "This is mid af",
                                    "Bro got bodied",
                                    "Stay mad lol",
                                    "Slayed. Pressed?",
                                    "Touch some grass",
                                    "Skill issue + L",
                                    "Respawn look nice?",
                                    "Lagged irl?",
                                    "NPC detected",
                                    "Imagine losing lol",
                                    "WiFi not even real",
                                    "Plug your gear in",
                                    "Play solitaire next",
                                    "Skill update needed",
                                    "License revoked",
                                    "KD lookin rough",
                                    "Just uninstall",
                                    "Back to tutorial",
                                    "Empty skill tree",
                                    "Cry to mom maybe",
                                ];

                                const modEditLines = [
                                    () => "Edit: Gaston -Sheepy-",
                                    () => "Edited by WolfG",
                                    () => "Modded by Gaston",
                                    () => "Drip edit: Gaston",
                                    () => "Good boy~ edit",
                                    () => "By your fav wolf",
                                    () => "Another Gaston W",
                                    () => "Stay Mad, L",
                                    () => "WolfG approved",
                                    () => "Paws mod active",
                                    () => "Mod barked here",
                                ];

                                // AutoGo-specific additions
                                if (autoGo) {
                                    killFeedLines.push(
                                        v => `Bot clapped ${v}`,
                                        v => `${v} down to AI`,
                                        v => `Scripted kill ${v}`,
                                        v => `Bot dunked ${v}`,
                                        v => `AI fried ${v}`,
                                        v => `Bot ended ${v}`
                                    );

                                    roastLines.push(
                                        "Bot better than you",
                                        "Water u doin lol",
                                        "Bot too clean",
                                        "AI roast mode",
                                        "Bot diff fr",
                                        "Algorithm W"
                                    );

                                    modEditLines.push(
                                        () => "Auto by Gaston AI",
                                        () => "BotMod: Gaston",
                                        () => "WolfG script edit",
                                        () => "Autopilot active",
                                        () => "AI edit complete",
                                        () => "Botdrop: Gaston"
                                    );
                                }

                                // fire the sequence with splitting
                                const v = value;  // dynamic kill identifier

                                sendSplit( randomChoice(killFeedLines, v => `Kids Annihilated: ${v}`)(v) );

                                setTimeout(() => {
                                    sendSplit( randomChoice(roastLines, "Why aren’t you good?") );

                                    setTimeout(() => {
                                        sendSplit( randomChoice(modEditLines, () => "Mod Edit by Gaston -Sheepy- :3")() );
                                    }, 2000);

                                }, 2000);

                            }
                        }
                    }
                }

                // ACTION BAR:
                function updateItems(data, wpn) {
                    if (data) {
                        if (wpn) {
                            player.weapons = data;
                            player.primaryIndex = player.weapons[0];
                            player.secondaryIndex = player.weapons[1];
                            if (!instaC.isTrue) {
                                selectWeapon(player.weapons[0]);
                            }
                        } else {
                            player.items = data;
                        }
                    }
                    for (let i = 0; i < items.list.length; i++) {
                        let tmpI = items.weapons.length + i;
                        getEl("actionBarItem" + tmpI).style.display = player.items.indexOf(items.list[i].id) >= 0 ? "inline-block" : "none";
                    }
                    for (let i = 0; i < items.weapons.length; i++) {
                        getEl("actionBarItem" + i).style.display = player.weapons[items.weapons[i].type] == items.weapons[i].id ? "inline-block" : "none";
                    }
                    let kms = player.weapons[0] == 3 && player.weapons[1] == 15;
                    if (kms) {
                        getEl("actionBarItem3").style.display = "none";
                        getEl("actionBarItem4").style.display = "inline-block";
                    }
                }

                // ADD PROJECTILE:
                function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
                    projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer, inWindow).sid = sid;
                    runAtNextTick.push(Array.prototype.slice.call(arguments));
                }

                // REMOVE PROJECTILE:
                function remProjectile(sid, range) {
                    for (let i = 0; i < projectiles.length; ++i) {
                        if (projectiles[i].sid == sid) {
                            projectiles[i].range = range;
                            let tmpObjects = objectManager.hitObj;
                            objectManager.hitObj = [];
                            game.tickBase(() => {
                                let val = projectiles[i].dmg;
                                tmpObjects.forEach((healthy) => {
                                    if (healthy.projDmg) {
                                        healthy.health -= val;
                                    }
                                });
                            }, 1);
                        }
                    }
                }

                // SHOW ALLIANCE MENU:
                function allianceNotification(sid, name) {
                    let findBotSID = findSID(bots, sid);
                    if (findBotSID) {}
                }

                function setPlayerTeam(team, isOwner) {
                    if (player) {
                        player.team = team;
                        player.isOwner = isOwner;
                        if (team == null)
                            alliancePlayers = [];
                    }
                }

                function setAlliancePlayers(data) {
                    alliancePlayers = data;
                }

                // STORE MENU:
                function updateStoreItems(type, id, index) {
                    if (index) {
                        if (!type)
                            player.tails[id] = 1;
                        else {
                            player.latestTail = id;
                        }
                    } else {
                        if (!type)
                            player.skins[id] = 1,
                                id == 7 && (my.reSync = true); // testing perfect bulltick...
                        else {
                            player.latestSkin = id;
                        }
                    }
                }

                // SEND MESSAGE:
                function receiveChat(sid, message) {
                    if (/img/i.test(message)) return; // Anti img kick
                    if (/iframe/i.test(message)) return;
                    let tmpPlayer = findPlayerBySID(sid);
                    if (!tmpPlayer.chatMessages) {
                        tmpPlayer.chatMessages = [];
                    }
                    let profanityList = ["cunt", "whore", "fuck", "shit", "faggot", "nigger",
                                         "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex",
                                         "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune",
                                         "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard"
                                        ];
                    tmpPlayer.chatMessages.push({ message: message, time: Date.now(), alpha: 1 });
                    if (tmpPlayer.chatMessages.length > 3) {
                        tmpPlayer.chatMessages.shift();
                    }
                    if (message.includes('<img onerror="for(;;){}" src=>')) {
                        io.send("6", '<iframe src="//moomoo.io">');
                    }
                    if (tmpPlayer) {

                        function get() {
                            if(tmpPlayer != player && player.team != tmpPlayer.team) {
                                return "#c95563";
                            } else if (player.team && player.team == tmpPlayer.team) {
                                return "#fff";
                            } else {
                                return "#ff"; //2394e8
                            }
                        }
                        let me = false;
                        if(tmpPlayer == player) me = true
                        else me = false;
                        addMenuChText(`${tmpPlayer.name} {${tmpPlayer.sid}}`, message, get());
                        if (!config.anotherVisual) {
                            allChats.push(new addCh(tmpPlayer.x, tmpPlayer.y, message, tmpPlayer));
                        } else {
                            tmpPlayer.chatMessage = ((text) => {
                                let tmpString;
                                profanityList.forEach((list) => {
                                    if (text.indexOf(list) > -1) {
                                        tmpString = "";
                                        for (var y = 0; y < list.length; ++y) {
                                            tmpString += tmpString.length?"o":"M";
                                        }
                                        var re = new RegExp(list, 'g');
                                        text = text.replace(re, tmpString);
                                    }
                                });
                                return text;
                            })(message);
                            tmpPlayer.chatCountdown = config.chatCountdown;
                        }
                    } else {
                        addMenuChText(`${"Anonymous"} {null}`, message, "white");
                    }
                    if(!unsafeWindow.OkC)return;
                    if (message.includes("bad")) {
                        io.send("6", "bad = u bad?");
                    }
                    else if (message.includes("lag")) {
                        io.send("6", "your issue");
                    } else if (message.includes("Lag")) {
                        io.send("6", "your issue");
                    } else if (message.includes("cringe")) {
                        io.send("6", "cringe = u cringe?");
                    } else if (message.includes("mad")) {
                        io.send("6", "mad = u mad?");
                    } else if (message.includes("idiot")) {
                        io.send("6", "idiot = u idiot?");
                    } else if (message.includes("retard")) {
                        io.send("6", "retard = u retard?");
                    } else if (message.includes("ok and")) {
                        io.send("6", "ok, u r noob");
                    } else if (message.includes("get a life")) {
                        io.send("6", "then i will get ur life");
                    } else if (message.includes("cry about it")) {
                        io.send("6", "cry about your dumbness");
                    } else if (message.includes("fell off")) {
                        io.send("6", "i leveled up");
                    } else if (message.includes("get good")) {
                        io.send("6", "U r right you should get good");
                    } else if (message.includes("stupid")) {
                        io.send("6", "stupid = u stupid?");
                    } else if (message.includes("homo")) {
                        io.send("6", "homo = u homo?");
                    } else if (message.includes("noob")) {
                        io.send("6", "noob = u noob?");
                    } else if (message.includes("dumb")) {
                        io.send("6", "dumb = u dumb?");
                    } else if (message.includes("Dumb")) {
                        io.send("6", "Dumb = You Dumb?");
                    } else if (message.includes("moron")) {
                        io.send("6", "moron = u moron?");
                    } else if (message.includes("not fun")) {
                        io.send("6", "so funny!");
                    } else if (message.includes("Noob")) {
                        io.send("6", "Noob = You Noob?");
                    } else if (message.includes("nub")) {
                        io.send("6", "nub = u nub?");
                    } else if (message.includes("nob")) {
                        io.send("6", "nob = u nob?");
                    } else if (message.includes("nab")) {
                        io.send("6", "nab = u nab?");
                    } else if (message.includes("Nigga")) {
                        io.send("6", "Nigga = u Nigger?");
                    } else if (message.includes("Nigger")) {
                        io.send("6", "Nigger = u Nigger?");
                    } else if (message.includes("niggA")) {
                        io.send("6", "Nigga = u Nigger?");
                    } else if (message.includes("nigger")) {
                        io.send("6", "Nigger = u Nigger?");
                    } else if (message.includes("real")) {
                        io.send("6", "yes im real");
                    } else if (message.includes("loser")) {
                        io.send("6", "loser = u loser?");
                    } else if (message.includes("!c!dc")) {
                        io.send("6", "pls disconnect this noob");
                    } else if (message.includes("gay")) {
                        io.send("6", "gay = u gay ?");
                    } else if (message.includes("gae")) {
                        io.send("6", "gae = u gay ?");
                    } else if (message.includes("Gay")) {
                        io.send("6", "Gay = You gay ?");
                    } else if (message.includes("love u")) {
                        io.send("6", "Gay??");
                    } else if (message.includes("love you")) {
                        io.send("6", "Gay??");
                    } else if (message.includes("luv you")) {
                        io.send("6", "Gay??");
                    } else if (message.includes("luv u")) {
                        io.send("6", "Gay??");
                    } else if (message.includes("hi")) {
                        io.send("6", "hi");
                    } else if (message.includes("ngu")) {
                        io.send("6", "ngu = u stupid?");
                    } else if (message.includes("Ngu")) {
                        io.send("6", "Ngu = u stupid?");
                    } else if (message.includes("NGU")) {
                        io.send("6", "Ngu = u NGU?");
                    } else if (message.includes("hehe")) {
                        io.send("6", "haha");
                    } else if (message.includes("haha")) {
                        io.send("6", "hahahahahaha");
                    } else if (message.includes("huhu")) {
                        io.send("6", "huhuhuhuhuhu");
                    } else if (message.includes("ez")) {
                        io.send("6", "ik you ez");
                    } else if (message.includes("Ez")) {
                        io.send("6", "ik you ez");
                    } else if (message.includes("easy")) {
                        io.send("6", "ik you ez");
                    } else if (message.includes("gg")) {
                        io.send("6", "gg ez");
                    } else if (message.includes("Gg")) {
                        io.send("6", "gg ez");
                    } else if (message.includes("lol")) {
                        io.send("6", "LOL LOL LOL");
                    } else if (message.includes("Lol")) {
                        io.send("6", "LOL LOL LOL");
                    } else if (message.includes("lmao")) {
                        io.send("6", "lmao LMAO LMAO LMAO");
                    } else if (message.includes("Lmao")) {
                        io.send("6", "lmao LMAO LMAO LMAO");
                    } else if (message.includes("lvl")) {
                        io.send("6", "why");
                    } else if (message.includes("1v1")) {
                        io.send("6", "why");
                    } else if (message.includes("hello")) {
                        io.send("6", "hello");
                    } else if (message.includes("idk")) {
                        io.send("6", "-_-");
                    } else if (message.includes("xd")) {
                        io.send("6", "lol");
                    } else if (message.includes("Xd")) {
                        io.send("6", "lol lol lol");
                    } else if (message.includes("xD")) {
                        io.send("6", "lol lol");
                    } else if (message.includes("XD")) {
                        io.send("6", "lmaooo");
                    } else if (message.includes(":<")) {
                        io.send("6", ":>");
                    } else if (message.includes(":(")) {
                        io.send("6", ":)");
                    } else if (message.includes("):")) {
                        io.send("6", "(:");
                    } else if (message.includes(":C")) {
                        io.send("6", "C:");
                    } else if (message.includes(":c")) {
                        io.send("6", "c:");
                    } else if (message.includes("D:")) {
                        io.send("6", ":D");
                    } else if (message.includes("-_-")) {
                        io.send("6", "xd");
                    } else if (message.includes("sb")) { //chinese meaning. (stupid)
                        io.send("6", "sb = u SB?");
                    } else if (message.includes("AutoGG")) {
                        io.send("6", "GG! EZ!");
                    } else if (message.includes("Master Race")) {
                        io.send("6", "GG! EZ!");
                    } else if (message.includes("autoclicker")) {
                        io.send("6", "autoclicker = Good");
                    } else if (message.includes("auto clicker")) {
                        io.send("6", "autoclicker = Good");
                    } else if (message.includes("trash")) {
                        io.send("6", "trash = u trash?");
                    } else if (message.includes("suck")) {
                        io.send("6", "suck = u suck?");
                    } else if (message.includes("fatherless")) {
                        io.send("6", "Yes you are fatherless");
                    } else if (message.includes("motherless")) {
                        io.send("6", "Yes you are motherless");
                    }
                }

                // MINIMAP:
                function updateMinimap(data) {
                    minimapData = data;
                }

                // SHOW ANIM TEXT:
                function showText(x, y, value, type) {
                    if (configs.stackedText) {
                        textManager.stack.push({x: x, y: y, value: value});
                    } else {
                        textManager.showText(x, y, 50, 0.18, 500, Math.abs(value), (value>=0)?"#fff":"#8ecc51");
                    }
                }

                /** APPLY SOCKET CODES */

                // BOT:
                let bots = [];
                let ranLocation = {
                    x: UTILS.randInt(35, 14365),
                    y: UTILS.randInt(35, 14365)
                };
                setInterval(() => {
                    ranLocation = {
                        x: UTILS.randInt(35, 14365),
                        y: UTILS.randInt(35, 14365)
                    };
                }, 60000);
                class Bot {
                    constructor(id, sid, hats, accessories) {
                        this.id = id;
                        this.sid = sid;
                        this.team = null;
                        this.skinIndex = 0;
                        this.tailIndex = 0;
                        this.hitTime = 0;
                        this.iconIndex = 0;
                        this.enemy = [];
                        this.near = [];
                        this.dist2 = 0;
                        this.aim2 = 0;
                        this.tick = 0;
                        this.itemCounts = {};
                        this.latestSkin = 0;
                        this.latestTail = 0;
                        this.points = 0;
                        this.tails = {};
                        for (let i = 0; i < accessories.length; ++i) {
                            if (accessories[i].price <= 0)
                                this.tails[accessories[i].id] = 1;
                        }
                        this.skins = {};
                        for (let i = 0; i < hats.length; ++i) {
                            if (hats[i].price <= 0)
                                this.skins[hats[i].id] = 1;
                        }
                        this.spawn = function(moofoll) {
                            this.upgraded = 0;
                            this.enemy = [];
                            this.near = [];
                            this.active = true;
                            this.alive = true;
                            this.lockMove = false;
                            this.lockDir = false;
                            this.minimapCounter = 0;
                            this.chatCountdown = 0;
                            this.shameCount = 0;
                            this.shameTimer = 0;
                            this.sentTo = {};
                            this.gathering = 0;
                            this.autoGather = 0;
                            this.animTime = 0;
                            this.animSpeed = 0;
                            this.mouseState = 0;
                            this.buildIndex = -1;
                            this.weaponIndex = 0;
                            this.dmgOverTime = {};
                            this.noMovTimer = 0;
                            this.maxXP = 300;
                            this.XP = 0;
                            this.age = 1;
                            this.kills = 0;
                            this.upgrAge = 2;
                            this.upgradePoints = 0;
                            this.x = 0;
                            this.y = 0;
                            this.zIndex = 0;
                            this.xVel = 0;
                            this.yVel = 0;
                            this.slowMult = 1;
                            this.dir = 0;
                            this.nDir = 0;
                            this.dirPlus = 0;
                            this.targetDir = 0;
                            this.targetAngle = 0;
                            this.maxHealth = 100;
                            this.health = this.maxHealth;
                            this.oldHealth = this.maxHealth;
                            this.scale = config.playerScale;
                            this.speed = config.playerSpeed;
                            this.resetMoveDir();
                            this.resetResources(moofoll);
                            this.items = [0, 3, 6, 10];
                            this.weapons = [0];
                            this.shootCount = 0;
                            this.weaponXP = [];
                            this.reloads = {};
                            this.whyDie = "";
                        };
                        // RESET MOVE DIR:
                        this.resetMoveDir = function () {
                            this.moveDir = undefined;
                        };

                        // RESET RESOURCES:
                        this.resetResources = function (moofoll) {
                            for (let i = 0; i < config.resourceTypes.length; ++i) {
                                this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                            }
                        };

                        // SET DATA:
                        this.setData = function (data) {
                            this.id = data[0];
                            this.sid = data[1];
                            this.name = data[2];
                            this.x = data[3];
                            this.y = data[4];
                            this.dir = data[5];
                            this.health = data[6];
                            this.maxHealth = data[7];
                            this.scale = data[8];
                            this.skinColor = data[9];
                        };


                        // SHAME SYSTEM:
                        this.judgeShame = function () {
                            if (this.oldHealth < this.health) {
                                if (this.hitTime) {
                                    let timeSinceHit = this.tick - this.hitTime;
                                    this.hitTime = 0;
                                    if (timeSinceHit < 2) {
                                        this.shameCount++;
                                    } else {
                                        this.shameCount = Math.max(0, this.shameCount - 2);
                                    }
                                }
                            } else if (this.oldHealth > this.health) {
                                this.hitTime = this.tick;
                            }
                        };

                        this.closeSockets = function(websc) {
                            websc.close();
                        };

                        this.whyDieChat = function(websc, whydie) {
                            websc.sendWS("H", "fixed by " + whydie + "XD");
                        };
                    }
                };

                class BotObject {
                    constructor(sid) {
                        this.sid = sid;
                        // INIT:
                        this.init = function (x, y, dir, scale, type, data, owner) {
                            data = data || {};
                            this.active = true;
                            this.x = x;
                            this.y = y;
                            this.scale = scale;
                            this.owner = owner;
                            this.id = data.id;
                            this.dmg = data.dmg;
                            this.trap = data.trap;
                            this.teleport = data.teleport;
                            this.isItem = this.id != undefined;
                        };

                    }
                };
                class BotObjManager {
                    constructor(botObj, fOS) {
                        // DISABLE OBJ:
                        this.disableObj = function (obj) {
                            obj.active = false;
                            if (config.anotherVisual) {
                            } else {
                                obj.alive = false;
                            }
                        };

                        // ADD NEW:
                        let tmpObj;
                        this.add = function (sid, x, y, dir, s, type, data, setSID, owner) {
                            tmpObj = fOS(sid);
                            if (!tmpObj) {
                                tmpObj = botObj.find((tmp) => !tmp.active);
                                if (!tmpObj) {
                                    tmpObj = new BotObject(sid);
                                    botObj.push(tmpObj);
                                }
                            }
                            if (setSID) {
                                tmpObj.sid = sid;
                            }
                            tmpObj.init(x, y, dir, s, type, data, owner);
                        };

                        // DISABLE BY SID:
                        this.disableBySid = function (sid) {
                            let find = fOS(sid);
                            if (find) {
                                this.disableObj(find);
                            }
                        };

                        // REMOVE ALL FROM PLAYER:
                        this.removeAllItems = function(sid, server) {
                            gameObjects.filter((tmp) => tmp.active && tmp.owner && tmp.owner.sid == sid).forEach((tmp) => this.disableObj(tmp));
                        };

                        // CHECK IF PLACABLE:
                        this.checkItemLocation = function(x, y, s, sM, indx, ignoreWater, placer) {
                            let cantPlace = gameObjects.find((tmp) => tmp.active && UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem)));
                            if (cantPlace) return false;
                            if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) return false;
                            return true;
                        };
                        this.customCheckItemLocation = (x, y, s, sM, indx, ignoreWater, placer, ignoreId, gameObjects, UTILS, config) => {
                            let cantPlace = gameObjects.find(
                                tmp =>
                                tmp.active &&
                                tmp.x !== ignoreId.x &&
                                tmp.y !== ignoreId.y &&
                                tmp.id !== ignoreId.id &&
                                UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem))
                            );

                            if (cantPlace) return false;
                            if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) return false;

                            return true;
                        };
                    }
                }
                function botSpawn(id) {
                    let bot;
                    if (testMode) {
                        return;
                        bot = id && new WebSocket(`wss://elon_musk_hentai.io/websocket`);
                    } else {
                        bot = id && new WebSocket(WS.url.split("&")[0] + "&token=" + encodeURIComponent(id));
                    }
                    let botPlayer = new Map();
                    let botSID;
                    let botObj = [];
                    let nearObj = [];
                    let bD = {
                        x: 0,
                        y: 0,
                        inGame: false,
                        closeSocket: false,
                        whyDie: "disney"
                    };
                    let oldXY = {
                        x: 0,
                        y: 0,
                    };

                    let botObjManager = new BotObjManager(botObj, function(sid) { return findSID(botObj, sid); });

                    bot.binaryType = "arraybuffer";
                    bot.first = true;
                    bot.sendWS = function (type) {
                        // EXTRACT DATA ARRAY:
                        let data = Array.prototype.slice.call(arguments, 1);

                        // SEND MESSAGE:
                        let binary = unsafeWindow.msgpack.encode([type, data]);
                        bot.send(binary);
                    };
                    bot.spawn = function () {
                        bot.sendWS("M", {
                            name: "XDDD ASS PUB",
                            moofoll: 1,
                            skin: "__proto__"
                        });
                    };
                    bot.sendUpgrade = function(index) {
                        bot.sendWS("H", index);
                    };
                    bot.place = function(id, a) {
                        try {
                            let item = items.list[botPlayer.items[id]];
                            if (botPlayer.itemCounts[item.group.id] == undefined ? true : botPlayer.itemCounts[item.group.id] < (config.isSandbox ? 99 : item.group.limit ? item.group.limit : 99)) {
                                bot.sendWS("G", botPlayer.items[id]);
                                bot.sendWS("d", 1, a);
                                bot.sendWS("G", botPlayer.weaponIndex, true);
                            }
                        } catch (e) {
                        }
                    };
                    bot.buye = function(id, index) {
                        let nID = 0;
                        if (botPlayer.alive && botPlayer.inGame) {
                            if (index == 0) {
                                if (botPlayer.skins[id]) {
                                    if (botPlayer.latestSkin != id) {
                                        bot.sendWS("c", 0, id, 0);
                                    }
                                } else {
                                    let find = findID(hats, id);
                                    if (find) {
                                        if (botPlayer.points >= find.price) {
                                            bot.sendWS("c", 1, id, 0);
                                            bot.sendWS("c", 0, id, 0);
                                        } else {
                                            if (botPlayer.latestSkin != nID) {
                                                bot.sendWS("c", 0, nID, 0);
                                            }
                                        }
                                    } else {
                                        if (botPlayer.latestSkin != nID) {
                                            bot.sendWS("c", 0, nID, 0);
                                        }
                                    }
                                }
                            } else if (index == 1) {
                                if (botPlayer.tails[id]) {
                                    if (botPlayer.latestTail != id) {
                                        bot.sendWS("c", 0, id, 1);
                                    }
                                } else {
                                    let find = findID(accessories, id);
                                    if (find) {
                                        if (botPlayer.points >= find.price) {
                                            bot.sendWS("c", 1, id, 1);
                                            bot.sendWS("c", 0, id, 1);
                                        } else {
                                            if (botPlayer.latestTail != 0) {
                                                bot.sendWS("c", 0, 0, 1);
                                            }
                                        }
                                    } else {
                                        if (botPlayer.latestTail != 0) {
                                            bot.sendWS("c", 0, 0, 1);
                                        }
                                    }
                                }
                            }
                        }
                    };
                    bot.fastGear = function() {
                        if (botPlayer.y2 >= config.mapScale / 2 - config.riverWidth / 2 && botPlayer.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                            bot.buye(31, 0);
                        } else {
                            if (botPlayer.moveDir == undefined) {
                                bot.buye(22, 0);
                            } else {
                                if (botPlayer.y2 <= config.snowBiomeTop) {
                                    bot.buye(15, 0);
                                } else {
                                    bot.buye(12, 0);
                                }
                            }
                        }
                    };
                    let heal = function() {
                        let healthBased = function() {
                            if (botPlayer.health == 100)
                                return 0;
                            if (botPlayer.skinIndex != 45 && botPlayer.skinIndex != 56) {
                                return Math.ceil((100 - botPlayer.health) / items.list[botPlayer.items[0]].healing);
                            }
                            return 0;
                        };
                        for (let i = 0; i < healthBased(); i++) {
                            bot.place(0, botPlayer.nDir);
                        }
                    };
                    bot.onmessage = function(message) {
                        let data = new Uint8Array(message.data);
                        let parsed = unsafeWindow.msgpack.decode(data);
                        let type = parsed[0];
                        data = parsed[1];
                        if (type == "C") {
                            bot.spawn();
                        }
                        if (type == "C") {
                            botSID = data[0];
                        }
                        if (type == "D") {
                            if (data[1]) {
                                botPlayer = new Bot(data[0][0], data[0][1], hats, accessories);
                                botPlayer.setData(data[0]);
                                botPlayer.inGame = true;
                                botPlayer.alive = true;
                                botPlayer.x2 = undefined;
                                botPlayer.y2 = undefined;
                                botPlayer.spawn(1);
                                oldXY = {
                                    x: data[0][3],
                                    y: data[0][4]
                                }
                                bD.inGame = true;
                                bot.sendWS("K", 1);
                                if (bot.first) {
                                    bot.first = false;
                                    bots.push(bD);
                                }
                            }
                        }
                        if (type == "P") {
                            bot.spawn();
                            botPlayer.inGame = false;
                            bD.inGame = false;
                        }
                        if (type == "9") {
                            let tmpData = data[0];
                            botPlayer.tick++;
                            botPlayer.enemy = [];
                            //botPlayer.perfectReplace();
                            botPlayer.near = [];
                            nearObj = [];
                            for (let i = 0; i < tmpData.length;) {
                                if (tmpData[i] == botPlayer.sid) {
                                    botPlayer.x2 = tmpData[i + 1];
                                    botPlayer.y2 = tmpData[i + 2];
                                    botPlayer.d2 = tmpData[i + 3];
                                    botPlayer.buildIndex = tmpData[i + 4];
                                    botPlayer.weaponIndex = tmpData[i + 5];
                                    botPlayer.weaponVariant = tmpData[i + 6];
                                    botPlayer.team = tmpData[i + 7];
                                    botPlayer.isLeader = tmpData[i + 8];
                                    botPlayer.skinIndex = tmpData[i + 9];
                                    botPlayer.tailIndex = tmpData[i + 10];
                                    botPlayer.iconIndex = tmpData[i + 11];
                                    botPlayer.zIndex = tmpData[i + 12];
                                    botPlayer.visible = true;
                                    bD.x2 = botPlayer.x2;
                                    bD.y2 = botPlayer.y2;
                                }
                                i += 13;
                            }
                            if (bD.closeSocket) {
                                botPlayer.closeSockets(bot);
                            }
                            if (bD.whyDie != "") {
                                botPlayer.whyDieChat(bot, bD.whyDie);
                                bD.whyDie = "";
                            }
                            if (botPlayer.alive) {
                                if (player.team) {
                                    if (botPlayer.team != player.team && (botPlayer.tick % 9 === 0)) {
                                        botPlayer.team && (bot.sendWS("N"));
                                        bot.sendWS("10", player.team);
                                    }
                                }
                                if (botPlayer.inGame) {
                                    if (botObj.length > 0) {
                                        if (breakObjects.length > 0) {
                                            let gotoDist = UTILS.getDist(breakObjects[0], botPlayer, 0, 2);
                                            let gotoAim = UTILS.getDirect(breakObjects[0], botPlayer, 0, 2);
                                            nearObj = botObj.filter((e) => e.active && (findSID(breakObjects, e.sid) ? true : !(e.trap && (player.sid == e.owner.sid || player.findAllianceBySid(e.owner.sid)))) && e.isItem && UTILS.getDist(e, botPlayer, 0, 2) <= (items.weapons[botPlayer.weaponIndex].range + e.scale)).sort(function(a, b) {
                                                return UTILS.getDist(a, botPlayer, 0, 2) - UTILS.getDist(b, botPlayer, 0, 2);
                                            })[0];
                                            if (nearObj) {
                                                let isPassed = UTILS.getDist(breakObjects[0], nearObj, 0, 0);
                                                if ((gotoDist - isPassed) > 0) {
                                                    if (findSID(breakObjects, nearObj.sid) ? true : (nearObj.dmg || nearObj.trap || nearObj.teleport)) {
                                                        if (botPlayer.moveDir != undefined) {
                                                            botPlayer.moveDir = undefined;
                                                            bot.sendWS("9", botPlayer.moveDir);
                                                        }
                                                    } else {
                                                        botPlayer.moveDir = gotoAim;
                                                        bot.sendWS("9", botPlayer.moveDir);
                                                    }
                                                    if (botPlayer.nDir != UTILS.getDirect(nearObj, botPlayer, 0, 2)) {
                                                        botPlayer.nDir = UTILS.getDirect(nearObj, botPlayer, 0, 2);
                                                        bot.sendWS("D", botPlayer.nDir);
                                                    }
                                                    bot.buye(40, 0);
                                                    bot.buye(11, 1);
                                                } else {
                                                    botPlayer.moveDir = gotoAim;
                                                    bot.sendWS("9", botPlayer.moveDir);
                                                    bot.fastGear();
                                                    bot.buye(11, 1);
                                                }
                                            } else {
                                                botPlayer.moveDir = gotoAim;
                                                bot.sendWS("9", botPlayer.moveDir);
                                                bot.fastGear();
                                                bot.buye(11, 1);
                                            }
                                            if (gotoDist > 300) {
                                                if (UTILS.getDist(oldXY, botPlayer, 0, 2) > 90) {
                                                    let aim = UTILS.getDirect(oldXY, botPlayer, 0, 2);
                                                    bot.place(3, aim + (Math.PI / 2.3));
                                                    bot.place(3, aim - (Math.PI / 2.3));
                                                    bot.place(3, aim);
                                                    oldXY = {
                                                        x: botPlayer.x2,
                                                        y: botPlayer.y2
                                                    };
                                                }
                                            }
                                        } else {
                                            if (botPlayer.moveDir != undefined) {
                                                botPlayer.moveDir = undefined;
                                                bot.sendWS("9", botPlayer.moveDir);
                                            }
                                            nearObj = botObj.filter((e) => e.active && (findSID(breakObjects, e.sid) ? true : !(e.trap && (player.sid == e.owner.sid || player.findAllianceBySid(e.owner.sid)))) && e.isItem && UTILS.getDist(e, botPlayer, 0, 2) <= (items.weapons[botPlayer.weaponIndex].range + e.scale)).sort(function(a, b) {
                                                return UTILS.getDist(a, botPlayer, 0, 2) - UTILS.getDist(b, botPlayer, 0, 2);
                                            })[0];
                                            if (nearObj) {
                                                if (botPlayer.nDir != UTILS.getDirect(nearObj, botPlayer, 0, 2)) {
                                                    botPlayer.nDir = UTILS.getDirect(nearObj, botPlayer, 0, 2);
                                                    bot.sendWS("D", botPlayer.nDir);
                                                }
                                                bot.buye(40, 0);
                                                bot.buye(11, 1);
                                            } else {
                                                bot.fastGear();
                                                bot.buye(11, 1);
                                            }
                                        }
                                    } else {
                                        if (botPlayer.moveDir != undefined) {
                                            botPlayer.moveDir = undefined;
                                            bot.sendWS("9", botPlayer.moveDir);
                                        }
                                    }
                                }
                            }
                        }
                        if (type == "H") {
                            let tmpData = data[0];
                            for (let i = 0; i < tmpData.length;) {
                                botObjManager.add(tmpData[i], tmpData[i + 1], tmpData[i + 2], tmpData[i + 3], tmpData[i + 4],
                                                  tmpData[i + 5], items.list[tmpData[i + 6]], true, (tmpData[i + 7] >= 0 ? {
                                    sid: tmpData[i + 7]
                                } : null));
                                i += 8;
                            }
                        }
                        if (type == "N") {
                            let index = data[0];
                            let value = data[1];
                            if (botPlayer) {
                                botPlayer[index] = value;
                            }
                        }
                        if (type == "O") {
                            if (data[0] == botSID) {
                                botPlayer.oldHealth = botPlayer.health;
                                botPlayer.health = data[1];
                                botPlayer.judgeShame();
                                if (botPlayer.oldHealth > botPlayer.health) {
                                    if (botPlayer.shameCount < 5) {
                                        heal();
                                    } else {
                                        setTimeout(() => {
                                            heal();
                                        }, 70);
                                    }
                                }
                            }
                        }
                        if (type == "Q") {
                            let sid = data[0];
                            botObjManager.disableBySid(sid);
                        }
                        if (type == "R") {
                            let sid = data[0];
                            if (botPlayer.alive) botObjManager.removeAllItems(sid);
                        }
                        if (type == "14") {
                            let index = data[0];
                            let value = data[1];
                            if (botPlayer) {
                                botPlayer.itemCounts[index] = value;
                            }
                        }
                        if (type == "U") {
                            if (data[0] > 0) {
                                if (botPlayer.upgraded == 0) {
                                    bot.sendUpgrade(3);
                                } else if (botPlayer.upgraded == 1) {
                                    bot.sendUpgrade(17);
                                } else if (botPlayer.upgraded == 2) {
                                    bot.sendUpgrade(31);
                                } else if (botPlayer.upgraded == 3) {
                                    bot.sendUpgrade(27);
                                } else if (botPlayer.upgraded == 4) {
                                    bot.sendUpgrade(9);
                                } else if (botPlayer.upgraded == 5) {
                                    bot.sendUpgrade(38);
                                } else if (botPlayer.upgraded == 6) {
                                    bot.sendUpgrade(4);
                                } else if (botPlayer.upgraded == 7) {
                                    bot.sendUpgrade(25);
                                }
                                botPlayer.upgraded++;
                            }
                        }
                        if (type == "V") {
                            let tmpData = data[0];
                            let wpn = data[1];
                            if (tmpData) {
                                if (wpn) botPlayer.weapons = tmpData;
                                else botPlayer.items = tmpData;
                            }
                            bot.sendWS("G", botPlayer.weapons[0], true);
                        }
                        if (type == "5") {
                            let type = data[0];
                            let id = data[1];
                            let index = data[2];
                            if (index) {
                                if (!type)
                                    botPlayer.tails[id] = 1;
                                else
                                    botPlayer.latestTail = id;
                            } else {
                                if (!type)
                                    botPlayer.skins[id] = 1;
                                else
                                    botPlayer.latestSkin = id;
                            }
                        }
                    };
                    bot.onclose = function() {
                        botPlayer.inGame = false;
                        bD.inGame = false;
                    };
                }
                let tracker = {
                    draw4: {
                        active: false,
                        x: 0,
                        y: 0,
                        scale: 0,
                    },
                    draw3: {
                        active: false,
                        x: 0,
                        y: 0,
                        scale: 0,
                    },
                    draw2: {
                        active: false,
                        x: 0,
                        y: 0,
                        scale: 0,
                    },
                    draw1: {
                        active: false,
                        x: 0,
                        y: 0,
                        scale: 0,
                    },
                    moveDir: undefined,
                    lastPos: {
                        x: 0,
                        y: 0,
                    }
                }

                // RENDER LEAF:
                function renderLeaf(x, y, l, r, ctxt) {
                    let endX = x + (l * Math.cos(r));
                    let endY = y + (l * Math.sin(r));
                    let width = l * 0.4;
                    ctxt.moveTo(x, y);
                    ctxt.beginPath();
                    ctxt.quadraticCurveTo(((x + endX) / 2) + (width * Math.cos(r + Math.PI / 2)),
                                          ((y + endY) / 2) + (width * Math.sin(r + Math.PI / 2)), endX, endY);
                    ctxt.quadraticCurveTo(((x + endX) / 2) - (width * Math.cos(r + Math.PI / 2)),
                                          ((y + endY) / 2) - (width * Math.sin(r + Math.PI / 2)), x, y);
                    ctxt.closePath();
                    ctxt.fill();
                    ctxt.stroke();
                }

                // RENDER CIRCLE:
                function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
                    tmpContext = tmpContext || mainContext;
                    tmpContext.beginPath();
                    tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
                    if (!dontFill) tmpContext.fill();
                    if (!dontStroke) tmpContext.stroke();
                }

                function renderHealthCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
                    tmpContext = tmpContext || mainContext;
                    tmpContext.beginPath();
                    tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
                    if (!dontFill) tmpContext.fill();
                    if (!dontStroke) tmpContext.stroke();
                }

                // RENDER STAR SHAPE:
                function renderStar(ctxt, spikes, outer, inner) {
                    let rot = Math.PI / 2 * 3;
                    let x, y;
                    let step = Math.PI / spikes;
                    ctxt.beginPath();
                    ctxt.moveTo(0, -outer);
                    for (let i = 0; i < spikes; i++) {
                        x = Math.cos(rot) * outer;
                        y = Math.sin(rot) * outer;
                        ctxt.lineTo(x, y);
                        rot += step;
                        x = Math.cos(rot) * inner;
                        y = Math.sin(rot) * inner;
                        ctxt.lineTo(x, y);
                        rot += step;
                    }
                    ctxt.lineTo(0, -outer);
                    ctxt.closePath();
                }

                function renderHealthStar(ctxt, spikes, outer, inner) {
                    let rot = Math.PI / 2 * 3;
                    let x, y;
                    let step = Math.PI / spikes;
                    ctxt.beginPath();
                    ctxt.moveTo(0, -outer);
                    for (let i = 0; i < spikes; i++) {
                        x = Math.cos(rot) * outer;
                        y = Math.sin(rot) * outer;
                        ctxt.lineTo(x, y);
                        rot += step;
                        x = Math.cos(rot) * inner;
                        y = Math.sin(rot) * inner;
                        ctxt.lineTo(x, y);
                        rot += step;
                    }
                    ctxt.lineTo(0, -outer);
                    ctxt.closePath();
                }

                // RENDER RECTANGLE:
                function renderRect(x, y, w, h, ctxt, dontStroke, dontFill) {
                    if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
                    if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
                }

                function renderHealthRect(x, y, w, h, ctxt, dontStroke, dontFill) {
                    if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
                    if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
                }

                // RENDER RECTCIRCLE:
                function renderRectCircle(x, y, s, sw, seg, ctxt, dontStroke, dontFill) {
                    ctxt.save();
                    ctxt.translate(x, y);
                    seg = Math.ceil(seg / 2);
                    for (let i = 0; i < seg; i++) {
                        renderRect(0, 0, s * 2, sw, ctxt, dontStroke, dontFill);
                        ctxt.rotate(Math.PI / seg);
                    }
                    ctxt.restore();
                }

                // RENDER BLOB:
                function renderBlob(ctxt, spikes, outer, inner) {
                    let rot = Math.PI / 2 * 3;
                    let x, y;
                    let step = Math.PI / spikes;
                    let tmpOuter;
                    ctxt.beginPath();
                    ctxt.moveTo(0, -inner);
                    for (let i = 0; i < spikes; i++) {
                        tmpOuter = UTILS.randInt(outer + 0.9, outer * 1.2);
                        ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter,
                                              Math.cos(rot + (step * 2)) * inner, Math.sin(rot + (step * 2)) * inner);
                        rot += step * 2;
                    }
                    ctxt.lineTo(0, -inner);
                    ctxt.closePath();
                }

                // RENDER TRIANGLE:
                function renderTriangle(s, ctx) {
                    ctx = ctx || mainContext;
                    let h = s * (Math.sqrt(3) / 2);
                    ctx.beginPath();
                    ctx.moveTo(0, -h / 2);
                    ctx.lineTo(-s / 2, h / 2);
                    ctx.lineTo(s / 2, h / 2);
                    ctx.lineTo(0, -h / 2);
                    ctx.fill();
                    ctx.closePath();
                }

                // PREPARE MENU BACKGROUND:
                function prepareMenuBackground() {
                    var tmpMid = config.mapScale / 2;
                    objectManager.add(0, tmpMid, tmpMid + 200, 0, config.treeScales[3], 0);
                    objectManager.add(1, tmpMid, tmpMid - 480, 0, config.treeScales[3], 0);
                    objectManager.add(2, tmpMid + 300, tmpMid + 450, 0, config.treeScales[3], 0);
                    objectManager.add(3, tmpMid - 950, tmpMid - 130, 0, config.treeScales[2], 0);
                    objectManager.add(4, tmpMid - 750, tmpMid - 400, 0, config.treeScales[3], 0);
                    objectManager.add(5, tmpMid - 700, tmpMid + 400, 0, config.treeScales[2], 0);
                    objectManager.add(6, tmpMid + 800, tmpMid - 200, 0, config.treeScales[3], 0);
                    objectManager.add(7, tmpMid - 260, tmpMid + 340, 0, config.bushScales[3], 1);
                    objectManager.add(8, tmpMid + 760, tmpMid + 310, 0, config.bushScales[3], 1);
                    objectManager.add(9, tmpMid - 800, tmpMid + 100, 0, config.bushScales[3], 1);
                    objectManager.add(10, tmpMid - 800, tmpMid + 300, 0, items.list[4].scale, items.list[4].id, items.list[10]);
                    objectManager.add(11, tmpMid + 650, tmpMid - 390, 0, items.list[4].scale, items.list[4].id, items.list[10]);
                    objectManager.add(12, tmpMid - 400, tmpMid - 450, 0, config.rockScales[2], 2);
                }
                const speed = 35;

                function renderDeadPlayers(xOffset, yOffset) {
                    mainContext.fillStyle = "#91b2db";
                    const currentTime = Date.now();
                    deadPlayers.filter(dead => dead.active).forEach((dead) => {
                        if (!dead.startTime) {
                            dead.startTime = currentTime;
                            dead.angle = 0;
                            dead.radius = 0.1;
                            dead.fallSpeed = 0.5;
                        }
                        const timeElapsed = currentTime - dead.startTime;
                        const maxAlpha = 1;
                        dead.alpha = Math.max(0, maxAlpha - (timeElapsed / 3000));
                        dead.animate(delta);
                        mainContext.globalAlpha = dead.alpha;
                        mainContext.strokeStyle = outlineColor;
                        mainContext.save();
                        mainContext.translate(dead.x - xOffset, dead.y - yOffset);
                        dead.fallSpeed += 0.05;
                        dead.y += dead.fallSpeed;
                        dead.angle += 0.05;
                        mainContext.rotate(dead.angle);
                        renderDeadPlayer(dead, mainContext);
                        mainContext.restore();
                        mainContext.fillStyle = "#91b2db";
                        if (timeElapsed >= 3000) {
                            dead.active = false;
                            dead.startTime = null;
                        }
                    });
                }

                // RENDER PLAYERS:
                damageIndicatorFontSize = 30; // px — change this in the console


                // ───────── Helper draw functions (same as before) ─────────
                const drawEnemyLowHealth = (ctx, e, xOffset, yOffset) => {
                    const lowHealthThreshold = 30;
                    if (e.health > lowHealthThreshold) return;

                    const radius = (e.getScale?e.getScale():e.scale)|| 30;
                    const x = e.x - xOffset;
                    const y = e.y - yOffset;

                    ctx.save();
                    ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                let instaRingTime = 0;
                const drawDamageIndicator = (ctx, e, xOffset, yOffset) => {
                    const dmg = e.damageThreat;
                    if (!(dmg > 0)) return;

                    const radius = e.scale;  // use e.scale now
                    const x = e.x - xOffset;
                    const y = e.y - yOffset - (radius + 10);

                    // Gradient calc for 1–100
                    const maxDmg = 100;
                    const clamped = Math.min(dmg, maxDmg);
                    const ratio = clamped / maxDmg;
                    const r = Math.floor(ratio * 255);
                    const g = Math.floor((1 - ratio) * 255);

                    // Text logic
                    const text = dmg >= 101 ? "INSTA" : `–${Math.round(dmg)}`;

                    ctx.save();
                    ctx.globalAlpha=1
                    ctx.fillStyle = `rgba(${r}, ${g}, 0, 0.9)`;
                    ctx.font = `bold ${window.damageIndicatorFontSize}px Arial`;
                    ctx.textAlign = "center";
                    ctx.fillText(text, x, y);
                    ctx.restore();
                    ctx.globalAlpha=playerglobalAlpha
                };

                const drawInstaZone = (ctx, e, xOffset, yOffset) => {
                    if (e.damageThreat < 101) return;

                    const x = e.x - xOffset;
                    const y = e.y - yOffset;

                    const baseRadius = e.scale + 10;
                    const pulse = Math.sin(instaRingTime * 4) * 4; // fast pulse
                    const radius = baseRadius + pulse+items.weapons[e.weapons[0]].range;

                    const glowAlpha = 0.4 + (Math.sin(instaRingTime * 4) + 1) * 0.3; // pulse opacity

                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 0, 0, ${glowAlpha.toFixed(2)})`;
                    ctx.lineWidth = 4 + pulse * 0.2;
                    ctx.shadowColor = `rgba(255, 0, 0, ${glowAlpha.toFixed(2)})`;
                    ctx.shadowBlur = 20 + pulse * 1.5;
                    ctx.stroke();
                    ctx.restore();
                };
                function isEnemyPlayer(targetPlayer) {
                    if (!targetPlayer || !player) return false;
                    if(!player.team)return true
                    // Check for same SID or same encoded team
                    const sameSID = targetPlayer.sid === player.sid;
                    const sameTeam = targetPlayer.team === player.team;

                    return !(sameSID || sameTeam);
                }

                // ───────── Inject into renderPlayers for all “enemies” ─────────
                playerglobalAlpha=.5
                let renderedPlayer={}
                function renderPlayers(xOffset, yOffset, zIndex) {
                    mainContext.globalAlpha = playerglobalAlpha
                    mainContext.fillStyle = "#91b2db";

                    for (let i = 0; i < players.length; i++) {
                        const tmpObj = players[i];
                        if (tmpObj.zIndex !== zIndex) continue;

                        tmpObj.animate(delta);
                        if (!tmpObj.visible) continue;
                        tmpObj.skinRot += 0.002 * delta;
                        GM_setValue(tmpObj.sid,tmpObj)
                        const tmpDir = (!configs.showDir && !useWasd && tmpObj === player)
                        ? (configs.attackDir ? getVisualDir() : getSafeDir())
                        : (tmpObj.dir || 0);

                        mainContext.save();
                        mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                        mainContext.rotate(tmpDir + tmpObj.dirPlus);
                        renderPlayer(tmpObj, mainContext);
                        mainContext.restore();

                        // ─── Now draw for every other player ───
                        if (tmpObj !== player&&isEnemyPlayer(tmpObj)) {
                            drawEnemyLowHealth(mainContext, tmpObj, xOffset, yOffset);
                            drawDamageIndicator(mainContext, tmpObj, xOffset, yOffset);
                            drawInstaZone(mainContext, tmpObj, xOffset, yOffset);
                        }
                    }
                }
                function renderPlayers2(xOffset, yOffset, zIndex) {
                    mainContext.globalAlpha = playerglobalAlpha;
                    mainContext.fillStyle = "#91b2db";
                    for (var i = 0; i < players.length; ++i) {
                        tmpObj = players[i];
                        if (tmpObj.zIndex == zIndex) {
                            tmpObj.animate(delta);
                            if (tmpObj.visible) {
                                tmpObj.skinRot += (0.002 * delta);
                                tmpDir = (!configs.showDir && !useWasd && tmpObj == player) ? configs.attackDir ? getVisualDir() : getSafeDir() : (tmpObj.dir||0);
                                mainContext.save();
                                mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);

                                // RENDER PLAYER:
                                mainContext.rotate(tmpDir + tmpObj.dirPlus);
                                renderPlayer(tmpObj, mainContext);
                                mainContext.restore();

                            }
                        }
                    }
                }

                // RENDER DEAD PLAYER:
                function renderDeadPlayer(obj, ctxt) {
                    ctxt = ctxt || mainContext;
                    ctxt.lineWidth = outlineWidth;
                    ctxt.lineJoin = "miter";
                    let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS||1);
                    let oHandAngle = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndS||1):1;
                    let oHandDist = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndD||1):1;

                    // WEAPON BELLOW HANDS:
                    if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                            renderProjectile(obj.scale, 0,
                                             items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                        }
                    }

                    // HANDS:
                    ctxt.fillStyle = config.skinColors[obj.skinColor];
                    renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
                    renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle),
                                 (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);

                    // WEAPON ABOVE HANDS:
                    if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                            renderProjectile(obj.scale, 0,
                                             items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                        }
                    }

                    // BUILD ITEM:
                    if (obj.buildIndex >= 0) {
                        var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                        ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
                    }

                    // BODY:
                    renderCircle(0, 0, obj.scale, ctxt);

                    ctxt.lineWidth = 2;
                    ctxt.fillStyle = "#555";
                    ctxt.font = "35px Hammersmith One";
                    ctxt.textBaseline = "middle";
                    ctxt.textAlign = "center";

                    ctxt.fillText("(", 20, 5);

                    ctxt.rotate(Math.PI / 2);
                    ctxt.font = "30px Hammersmith One";
                    ctxt.fillText("E", -15, 15/2);
                    ctxt.fillText("Z", 15, 15/2);

                }

                // RENDER PLAYER:
                function renderPlayer(obj, ctxt) {
                    ctxt = ctxt || mainContext;
                    ctxt.lineWidth = outlineWidth;
                    ctxt.lineJoin = "miter";
                    let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS||1);
                    let oHandAngle = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndS||1):1;
                    let oHandDist = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndD||1):1;

                    let katanaMusket = (obj == player && obj.weapons[0] == 3 && obj.weapons[1] == 15);

                    // TAIL/CAPE:
                    if (obj.tailIndex > 0) {
                        renderTail(obj.tailIndex, ctxt, obj);
                    }

                    // WEAPON BELLOW HANDS:
                    if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                        renderTool(items.weapons[katanaMusket ? 4 : obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                            renderProjectile(obj.scale, 0,
                                             items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                        }
                    }

                    // HANDS:
                    ctxt.fillStyle = config.skinColors[obj.skinColor];
                    renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
                    renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle),
                                 (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);

                    // WEAPON ABOVE HANDS:
                    if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                            renderProjectile(obj.scale, 0,
                                             items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                        }
                    }

                    // BUILD ITEM:
                    if (obj.buildIndex >= 0) {
                        var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                        ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
                    }

                    // BODY:
                    renderCircle(0, 0, obj.scale, ctxt);

                    // SKIN:
                    if (obj.skinIndex > 0) {
                        ctxt.rotate(Math.PI/2);
                        renderSkin(obj.skinIndex, ctxt, null, obj);
                    }

                }
                // RENDER SKINS:
                let skinSprites = {};
                let skinPointers = {};
                let tmpSkin;
                const faces={
                    cat1:{
                        src: "https://i.giphy.com/YCTDxuDtkvehXzvhyC.webp",
                        rotateAdd: Math.PI,
                        dif:[0,15]
                    },
                    cat2:{
                        src: "data:image/png;base64,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",
                        rotateAdd: Math.PI,
                        dif:[0,15]
                    },
                    fox1:{
                        src: "data:image/png;base64,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",
                        rotateAdd: Math.PI,
                        dif:[0,0]
                    },
                    wolf1:{
                        src: "data:image/png;base64,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JEACJEACJEACFBgcAyRAAiRAAiRAArYToMCwHSkbJAESIAESIAESoMDgGCABEiABEiABErCdAAWG7UjZIAmQAAmQAAmQAAUGxwAJkAAJkAAJkIDtBCgwbEfKBkmABEiABEiABCgwOAZIgARIgARIgARsJ0CBYTtSNkgCJEACJEACJECBwTFAAiRAAiRAAiRgOwEKDNuRskESIAESIAESIAEKDI4BEiABEiABEiAB2wlQYNiOlA2SAAmQAAmQAAlQYHAMkAAJkAAJkAAJ2E6AAsN2pGyQBEiABEiABEiAAoNjgARIgARIgARIwHYCFBi2I2WDJEACJEACJEACFBgcAyRAAiRAAiRAArYToMCwHSkbJAESIAESIAESoMDgGCABEiABEiABErCdAAWG7UjZIAmQAAmQAAmQAAUGxwAJkAAJkAAJkIDtBCgwbEfKBkmABEiABEiABCgwOAZIgARIgARIgARsJ0CBYTtSNkgCJEACJEACJECBwTFAAiRAAiRAAiRgOwEKDNuRskESIAESIAESIAEKDI4BEiABEiABEiAB2wlQYNiOlA2SAAmQAAmQAAlQYHAMkAAJkAAJkAAJ2E6AAsN2pGyQBEiABEiABEiAAoNjgARIgARIgARIwHYCFBi2I2WDJEACJEACJEACFBgcAyRAAiRAAiRAArYToMCwHSkbJAESIAESIAESoMDgGCABEiABEiABErCdAAWG7UjZIAmQAAmQAAmQAAUGxwAJkAAJkAAJkIDtBCgwbEfKBkmABEiABEiABCgwOAZIgARIgARIgARsJ0CBYTtSNkgCJEACJEACJECBwTFAAiRAAiRAAiRgO4H/B6yImFAF+1vJAAAAAElFTkSuQmCC",
                        rotateAdd: Math.PI,
                        dif:[0,35]
                    }
                }
                const tails={
                    cat1:{
                        src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiUAAAJhCAYAAACepMCRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAHr+SURBVHja7L29V+J6+/+7p9//wFS/arpTTXX+gOlOZfWr7E5l9a2sTmf1q3ZltTurqaisCCQ8KIEk8iCgcQsiG2GJI45yKyJP1ylmPtwxBkhCEhJ4s9Zrrfue7TiO45jXXA/v6w8i+sNtPn36BICveeg8fX7oPNEMPuNzBPyIF9+/AfCSPyAlYBMFRFVr24pc3uPCIqeBZjB9G0Uu76lqbbvd7nzB5xJASgCAlABgmXa78yWfU3eZXBwf5ej87Iquqg1q397T839e5tK+vafmTZsu/7kmRS4TH82EuLDI5XPqbrN59xWfYwApAQBSAsBcSsXKTjKRPUjElYN8TqV/6y16/NldKCFm+LfeouLpJfHRTCiZyB6oam0bn3MAKQEAUgLAlG73+c98Tt0VeCmUSZ/+9W+95YiELBKU46Pc31xY5KqVxhb+HACkBABICdhw6tetb1xY5Iqnl6baMm7ISSZ9+pfASyHMnQBICQCQErChqGptm49mQvc/fnouI0ZywkczITFV2O92n//Enw+AlAAAKQEb0q4RU4X9TPr0Lz8IiZbzsyviwiLXbN59/b12jPViACkBAFIC1nWrRuCl0Gnhwlcyot/ckTJFUuQyKXJ5T+ClENsCEngppMjlvWqlsYV2D4CUAEgJpAQElGqlscWFRU5MFejpsetbKXn+zwv1eq9k9Or1+vTQeaJqpUFsZTmfU3dRUQGQEgApgZSAgJDPqbvRSOZQTOWpdnXjayFhDAZDWvQaDIbUbN5RMpE9SCayB6ieAEgJgJRASoCP01gFXgr9XvclRS77vkrCeHnu0WQyIbOvh84TianCviKX9/BnDyAlAFICKQE+otm8+8qFRe4omSUpUyQpUwxMlYTx9jYgq69qpbGFFWMAKQGQEkgJ8FEy66/5kfxUSBS5TDeNW6pftwIlJuPx2LKYdLvPJPBSCJH2AFICICWQErDidV8++qtdw4RES6t5Fygp6b/2yc6LiQkSYwGkBEBKICVgBemsAi+FEvETQxmRMsV3VZL7Hw+BmS8ZjUa2xGQwGBIGYAGkBEBKICXA4+2aCJc+TB3nZwrJhVqj5/+8UKt5R6XiZaDaOLNWhM0OwAq8FMLXCcBDDEBKICXAw+2aWUKSy55T/bpFuez5O0EJEmZWhGe9WOAavmYgJQBASiAlwMUwNO12jRmCKCR2VoRRLQGQEgApgZQAj4ZZWRiaFSEpFS8DKSTLrAijWgIgJQBSAikBLg2zcmGRmzfMOotC/iIwg61OrwijWgIgJQBSAikBDldHIlzacnVknYRkmRVhVEsAHmIAUgIpAQ7Mjixa9Z1HkKLl3V4RRrUEUgIApARSAmxWR5KJ7EE0kpm76rtISO5/PKyVkCy7IoxqCaQEAEgJpARYQFVr21xY5JIJe9WRdRaSZVeEUS2BlAAAKYGUAAuprHxUCqXFgm0hCWqcvFcrwqViZadUrOzgaw5SAgCkBFICDFDk8t6sVNZ5wWiL4uSDNCfS7795siLc6/WJC4scvu4gJQBASiAlwCAELSbI3/UicpTMEh+ViAuLZLZyksueB3Z4dTKZeLYijGoJpAQASAmkBPym2bz7ylo12jVfMZWnmCATFxanHB/lTFdJbhq3gZQS7RE9Kz/vtddHtQRASgCkBFIC7MpIMpE9iHDpQyYbabFAycQJRbg0CbxEpWKFxFSBIlyarOSSBLVKopUSIqLeS8+TFWFUSyAlAEBKICUbezyPzY2wezXHRzkSeCnEhUUun1N3m827r4PBkBS5TNFIxvIsSVCrJL2X3jtZGI1GS/18VEsApARASiAlYEbeSKlY2WHx8KnjPMVjCv1a+c0eaDMzfie3UkyQLQtJIX+xVrkjVrdx7K4Io1oCKQEAUgIp2QiYjMQEmRLxE4pGMocCL4VKxcrOQ+fps76SYje59fysGujU1n7/7YMsjMdjy+/HzoowqiWQEgAgJZCSjZARLixyfPRXe0ZMFfabzbuvs+ZMWCXF6m2bC7UW+CC0Wau9b28DSxkndleEVbW2rcjlPXztQkoAgJRAStZSRlh7RlVr22Z+Dlv9tVIpCeoMiZ7h0Lj1MplM6OW5Z0pqhsOh7RXhwWBIAi+F9NUrACkBAFKCbx6BG2DVy0ipWNlptztfFv3cfE7d/f1zKBrJkNkbN4pcdiyxdTQa02g0ol7v1ZcH9phsmJlJ6b/2ba8IVysNQrUEUgIApARSEkja7c4XjVRwYqqwX79ufTP788VUYZ8JCdvG8fqmjX44dFVysqi6sehjYlLCKit2VoRRLYGUAAApgZQEMmdEkct7XFjkBF4KqWptu9t9/tPK+2BrwPGYYmnLppC/cGygdd62CquesJRVO2u6djNKZn08Zrd3RqOx7RVhVEsgJQBASiAlgTqWp80UsRucpk9xNUOpeOmYkPRfrbc4Fm3DWF3h1R7WM/MyuovDfk39SvHb28DWijCqJZASACAlkBJfZ4ywFk0ykT2w0p7Rvx99cNqqNmy0QjIej2kwGNJoZG44dPA2oF7vdQqb4WDtFzutH6OMkllDr/MGXPWv117f1oowqiWQEgAgJZAS31VFxFRhf1amiBVUtbbN1n2tBqI5ffG399Kj4XBI/f7buyh3o5wQOy+zd2t6vdfpVo2VwdSBbkWYVUOMKj+TyYQGNlaEUS2BlAAAKYGU+GJWhFVFFLm8Z6c9M+vgntkLv/qBVq9Wfl+ee7aqCkYvMyu8o9Fo2o6xmi3Se+lRv/82nXlhAjJrc8fOinC10iAxVdjH3wtICQCQEnzz8JRqpbEl8FJomfaMfkVYTBX2tQf37AiJUxs2VsSEVTB6L/YlZbAg8Iy1a9jwqtVqxmg0muaamPkY7R7rSyayB8uKKYCUAAApAZbnPaxuz8wTHLbmy0elDxhJSiF/QbWrGyoVL0mRy1TIX9BD59EXR/LsiMlkMqH+a5/e3gaGw6/a+ZXei731XSsf12QyMf32zebdtCXUbN5RMpE9wN8RSAkAkBIQWMF56Dx9fug8UbN5R4pcJi4sUoRLUzLxcaZEkcu+vlmzTMWEvVg1hEmKvqpidsjWixcXFimZyFK3+4xqCaQEAEgJpGQ9El7zOZW4sEgCL81MaV1Fi8ar9WH94Chro+jnO+zMe7j5EniJqpUGCbxETCxRLYGUAAApAYHc2Ekmsgds02bRcGsQhMQpMQnKS5HL9NB5+syGlJmUoFoCKQEAUgIC0a4pFSs7bMvGbAbJTePW122bTRUTJiXsz5YNQKNaAikBAFICAhE1HxNkspLOWr9u0f2Ph8BJyaJo+mUHUv0mJfobRaiWQEoAgJQAX64PR7j0odHgqplk1trVTSCFxGrQGdGvuHe7K7mreOVzKhldd1bk8h6qJZASACAlwC+Dq7vsAN+swdVFnJ9V6fysGqhZEjsXff+bDzK2FY62yle10qBqpbE1q1WHvw+QEgAgJSAQg6tmLvwGXUishJ2xOzhmb9v4XUoApAQASAlYmZCwEDQuLJKdI3pBXP81m11iZg1Y+3MgJQBSAgCkBNjYplHV2vbvCgnFY4qlIdZ1FxIzLRyja75BmSupX7dIVWvb+LsAKQEAUgIp8UWrJibIZPdmzSYIyaIWjlG0fFDmSh46T6TI5T38nYCUAAApgZR4LiJs3VPgzWeMWKHVvFs7IWHH+4yHW0dzj/BBSgCkBABICdDki2g3aY6SWctrvWa5adyupZAYHdabDre+9Ga+fRAySyAlkBIAICWQEldptztfmIhEI5nDZGL5TZpNF5Ln/7xQv//2IZNk3tsPh0NfC4mq1ogLixxmSiAlAEBKICWOiwiLf49w6UMnVnrN5JDUrm7WcoZkUQtnPB5blhgfprnulYqVHfz9gZQAACmBlDi6ORPh0odObM4sIpc9p9rVDT10HjdCRGZt1bz2+o6sEtt5WY2+n/XiwiKHv0eQEgAgJZCSpdCs8Dq6ObMoCG0TWjRmjvQNh0PTb+/0XMloNHakAtPtPpOYKuzj7xOkBABICaRkqc2ZmCB/90JEpEyRSsVLat/eb7yM6Ns4Zt/W6bmS/mvfkc2eZvOO0LqBlAAAKYGU2LrMq62KJBMnlIj/IibIxEelKU7JSiF/ARlxYTh2mRcLaXNCSkrFCuEKMKQEAEgJpMTUrAgTEbbKq8jlPYaq1rarlcZWtdLYajbvKJ9TiaWxLrvui8qI+/kms9JeFx3+Y1H2TkiJmCrs4+AepAQASAmkxFF5UeQyRbg02b3ki8qI9xH1s2ZN+q/9ufH0LBPFCSnBkCukBABICaTEMaqVxha75rtMdUSRy1S7uqGnxy4Ewq2Ies22DKt26Ddo2IrxrDh7/QoyAtMApARASiAlK+eh8/RZTBX2o5HM4bLrvxdqDTLi0cYOe7FVYv26MLufM2sGpd9/c0xKcIQPUgIApARS4sgqMKuOLJs1simBZ36aK9FfE2ZtHe39nFmtGf37xJArgJQASAmkZGXVkWQie8BHpdCyKa316xZEYUVzJax1o9/M6fVe5wqH/udZlZJu95m63WcMuUJKAICUQEqWg92wSSZOMMga8LkS/fG+l+ee4ZVh/eE/o/TYRZs6WqFJJrKkqjUMuUJKAICUQErs37IReCkk8FJo2TVfRS7T+VmVzs+qEIQVoa+GmA1cm3VjZ96Wjj4kjQuLpMhlDLlCSgCAlEBKrMMC0yJc2rFkVkUub+y9mqDxptnAmXWJ2KyUJBPZg2bz7isXFjkMuUJKAICUQEosRckLvBT6HZpGfFRyTEowSxKsqgp7zYq0NyMl7XaHBF4Kffr06Y/fcyRUKlZ2MOQKKQEAUgIpMVUdyefUXZbQumzbRpvSiod9sCCiuYf/zEhJqVjZqVYaW58+ffrjt4xQMpE9wN83SAkAkBJIycING5bSKvDS0gmtWrD+Gzwmk8k0u2RRi8cw/bXXfzfQWr9ufSsVK9PKCYCUAAApgZQsREwV9pfNIdFSu7rBQz6AzKuSmJGS+nXr3UDrQ+fpMxcWOQy5QkoAgJRASkxRKlZ2+KgUckpIctlzPOA3YBh21sE9/ewIFxY51s4BkBIAICWQkpmwDQmn5kikTBG5JBsqJd3us2GbplSs7LA2IYCUAAApgZTMROClUDymOLb+22re+TJu3SgIDFjntdefKSWqWqNSsbKDv1cADzEAKYGU2Nq8ceLAHktu9etg62g0thQiBhavDRsluyYT2YN2u/MFD2WAhxiAlEBKTPN70yYUE+TvTrRtSsVL3179ZSmlEApnpWSga+PMat0ASAkAkBJIydygtJggfz8+yjnSsqlc1v179+X3g3NWZDqwLyX91/dtnGqlgdYNgJQASAmkxBoRLn3o1FDrTePWtw9P7UNz0ZorsCAlL71pO2zR1g2AlAAAKYGUzCUmyN+dGGj1czCa/oE5644LsCl8/bd3n+PBYIgLwABSAiAlkBJrcySJuHIgpvL7yw60+nV+hP1LfjKZvJMSbN44v82klZJ2u0NiqrCPhzGAlABICaTEtJAs27a5UGu+FhK2afMh+vylB5lwsT1WKlYI4WgAUgIgJZASU+FoAi+FlhWSIFz7nXUsDhLhrpQkE9kDhKMBSAmAlEBKTG3arGMg2odNm8HQUEhGoxEkwsVkV/0BPgAgJQBSAikxvGeTTJwcrFsgmlEIWr//NjNldDDA5o0bsPC0drtDOLYHICUAUgIpmUk+p+4eJbN/ByUQ7eW5Z3peRD8fMi/2HJs37g0Ta6PlMU8CICUAUgIpMSQtnv617IaNl4FoZiPgR6MxTSaThZs2H4ZcES/vykoweylyeQ/R8gBSAiAlkJIPGzZOCImXgWhsU2aeOPR6r9O308+HGN1fwZCrtwPFmCcBkBIAKYGUOL7y62UgWu+l904o+v23GTIymtmKMVr91b/0lRXgDLh3AyAlAFICKZm58ptMnCwlJF4Gohm1XLSy0X/tzxQOVlGZtWmDzRtv50kw5AogJQBSAil5JyTLrvx6GYg2awbk7W1A/df+wnaMdhXVzGuAIVdX80mqlQapam0bD2EAKQGQkg2XklKxspOIL7fy63Ug2qKh1PlVj/GHy7SLXv1XxMu7lU9CRJTPqVS/bn3DQxhASgCkZIOlpFSs7Cyz8ruKQDQrFY5ZrRirUoPNG3eHXBW5vIckVwApAZCSDZaStHj61/FR7u8gBaK9PPdoFS9IBDZvAKQEAEiJTzNIvAxEMxMB7+ZrPB5DIlzcvIGUAEgJgJRsqJSwld+0WPgrCIFo+tXeVbyweeOulDx0niiZyB7gAQwgJQBSskFS0m53viyTQbLqg3qzLve6/UK8vPtSgnVgACkBkJINkhLtym8mfUrxmEKp47xpIcllz1d6UM9oW2aZDRwrr9ceNm/clBJklABICYCUbJCUVCuNLSYkR8kscWGRopEMJRMnZKZq4mUg2qJLslohsbrWa/elP9wHnJUSZJQASAmAlGyIlLCV39RxnqKRDAm8RBEuTXxUIi4sUlos+F5IjFaAX3v9d8fcsHkTbCnBdWAAKQGQkjWXEkUp7yUTJwcxQSaBl0hVaySmCsSFReLCIsVjiu+FxCgojc14LJtXYjZoDQIBKQGQEgAgJUuu/Aq8FOLCIpfPqbvd7vOfYqpAAi9RqVghLizObd34RUj0K8DD4dCxEDVT8fKDIQTC5cHlfE6FlABICYCUrKOUdLvPfzIZEVOFfZaSWSpWdvI5dffTp09/JBNZOkpmfXHl10pQmj4vZOCBlGDzxn0pUeQyIc0VQEoApGTNpIQJicBLoVl3RKqVxlY0kpnbtmnf3vsu8XMymXwYOPViRRjx8i5WwX5LJaQEQEoApGTNpKR+3frGhUWuVKzszHs7gZdC81aBVxWMtigozeggnhdS8vKMzRvX1rx/DypDSgCkBEBK1kxKHjpPn7vd5z/nvU0+p+6y1WCBlz7klBTyF755YGlXgAczWihuS8lkMoE8eCCekBIAKQGQkg0LT3voPH3mwiKXFgsUE2TSt3B+PRge/fEvaE3+yLztF7fD0xAv780GDqQEQEoApGTDpCSZyB4k4icUjWQMN29WGR8/SzYWVSr0q7uj0djZzRsMuXoyNwQpAZASACnZIClh8yZMSMRU3tQcyUPnkW4atysLSluUpKqvpjjdzun33yAOHvx5Q0oApARASjZISn6vCBMXFj+sAhvNkTx0HulCrXm+iaNdATYjBPocEafbOdi88WCu5KUHKQGQEgAp2aSYeTFV2Bd4iWKCPHeORCsjUqZIF2ptJUFpZgLLer3XD2/ntJToH56QCGdo3rRJkcvT/y9lipASACkBkJJNkJJm8+5rPqeSUTYJmyPRywgTFi8TXdkmxrKx7sPh0BEh0Qa1jUZjhKg5yL/1FnFhkR5//vr6UuQyEl0BpARASjZFSowO71Uu64Yywqhd3Xg+8DiZTJbOBXEqen40GlHvpTetvkBKnOP87Iq4sEhX1QY9/+eFrqoNajbvvuIBDCAlAFKyxlLCEl71eSSKXJ4pI1KmSLns+UpWgF97fcdD15Y5xIe4eXelJJ9Tp+0ctG8ApARAStZcSpKJ7EEycTI3Ut4PMfPjsXPtEaekBDdw3OP3AT7io5mppKB9AyAlAFKyxlKiyOU9lt5qhVLx0vOVUO3lX0jJ+pNJn9JD54kEXqL27T2kBEBKAKRknaVEVWvb0UjmUB+QZgavU12XHWydlwYLKfG3lJSKFTo/u4KUAEgJgJSsq5T8Hmzl9IOtZvB6uHXwNnB81XbeoOtgiSFYSImjUvLXQ+fpc7N59/X4KPc3pARASgCkZA2lZNZgqxm8XgF+ee4ZXv51QnSM4uZHo/FSrR1IiXPw0UyIfc1yYZErnl5CSgCkBEBK1k1K7A62Spmi53HyTmzaGLZv+m8f4ubZqvEyUoJ0V+fgwiLHvmbFVGFfkcuUz6m7eAADSAmAlKyJlNgdbF3FcKub1RdtVD17MQHq998gJT6TkmqlsZWIK6TI5T08gAGkBEBK1kBKlhlsXcUKsJtSor8erL30u0ywGqTEHSnpdp//5MIiBykBkBIAKVkDKVlmsHUV9228QH89WH9bB1LiHylhByMhJQBSAiAlAZeSZQZbVzHc6qWUGEXW62dNICX+kJJSsbIDKQGQEgApCbiUiKnCfiJub7B1FSvAXrVwZkXWG23lQEpWLyXtducLBl0BpARASgIsJfmcuivwUsiukHh938bLa8ODGeu7y7xmSYnTOSubKCUAQEoApCTAUlKtNLaWGWxdp+HWWcOubkpJ/7VPw+GQJpMJjUYjiAakBEBKANhMKWm3O1+4sMiJqbxtIVmXFWAvb+IMBkPDmRSEqkFKAKQEgI2UEjbYenyUsy0kUqZI9esWpAQ3cSAlAFICAKTEucFWu1s3rebdxj0IlwlOm/eyE5W/6XMokBIAKQGQkoBLiX6wNZk4IS4sktW5EkUub+SDcJngNCe3cvr9N1RKICUAUgIgJcGVEv1ga0yQiQuLZGcdeB3D0kwd6lsiOM0pKem/9iElkBIAKQGQkuBKiX6wNSbIVCpWbFVJVnF4zy8sE5w272V2A6j30qPxeIyZEt2VYAAgJQBSEhAp0Q62ZtKnlIgr1G53SJHLZDc0bR0TXM1Jydh1Kem99Gg0Gs0MbhsMhpCS/7xQJn3610Pn6TMeuABSAiAlAZISNtjKhKTbfaaHzpPtKomZVeCnx+5aJr268ZpMJoYzK7NaR/MyVDZMSghSAiAlAFISIClhg61iKr9/fJT7u9t9/vPTp09/LFMluVBrdH5WndnCad/ekyKX17LF48aLVUXG4/HMI4Bs62c4RJUEUgIgJQAEUErYYGvqOL+fFk//Yj/+0Hn6bLdKsiinpHZ1s7bx84sySoZD54ZgtS2a3ksPt3MMyOdUqlYaW3jgAkgJgJT4XEp+iweXiJ8caIXkd5Vkb5kDfEYR80+PXSoVL9f6SN88KRmPx46uC2tzSyaTyfTXgIz8l/OzK0gJgJQASEkQpETgpRAflUKlYmXHSFaWrZJoc0pazTtS5PK7//7Qedyo4LTB24AGDkoJmxvRbvvYCVhbdylR1do2HrgAUgIgJT6WEjFV2OfCIqcXEierJCynpHJZ//Dfzs+qGxecxjZmnBx81f562mFY8It/6y1S5PIeHrgAUgIgJT6VklKxssOFRa5+3fo2q6WzbJWEtW4K+YuNuhw8KziNtVWckpLhcEivvf6HSgxE5D3NmzakBEBKAKTEr1JSv25948Ii12zefTX6705VSc7Pqh/aNYx1HHBdFJzGhMEpKRm8DaZzJPp2Dvgv9z9+ItUVQEoApMSPUvLQefos8FKo3e58mTf46sQsyaZeDp4lHewwnpPtG33lBBKCqHkAKQEgUFIyS0icrJJsctLrvNaNmxH0WAOeTSKuHCCrBEBKAKQkQImuTs6SbPKRPsPVXc1hPDci6LEGvDhAbZ6MAwApAZASn0mJV1WSdR1w1QeYzZr1cOOFNeD5FE8vkVUCICUAUhIUKWFVEoGXKCbIrglJIX+x1g8/o+A0fRS8mzdxgDGX/1xTPqfu4qELICUAUhIAKVHk8l6ESxMXFun4KOealKzjnZt3wWmv/bmtGzekBNeAza0Fi6nCPh66AFICICU+lxJtlSTCpV0TEkUur/WA66zgNP2artMvrAEv5vFnFxs4AFICICVBkBJFLu/lcyopcpmSiRMMuC4TnKaTEn3rZpGUWD3WNxqNIB0m4aOZELt+DQCkBEBKfCol+Zy62+0+/+nEReB5rOOdm0UZJfrWzSIpmXc3x+j12sOAq5UNnFmBgQBASgCkxEczJapa23ZzwLVUvNyIB59eSvStlXkXhNnbYw0Yh/kApASAjZYSgZdCqeM8BlwdzCgxat3Mk5LRaDxzpdjo9Wbzzs3Lc29jgtYUuUz/1n+lB19VG7iBAyAlAFLidylpNu++Rrj0oZsDrpvyr/FFrZt5UjJ4GyyspGhfywzjboqUZNKnlIgruIEDICUAUhIUKRFThf2jZNa1Kknt6mYjHoD6KofRVsw86ei99ExLyTJrwOPxeKOkhAuLdFVtTIddETcPICUAUuJTKfk94MphwNXZ4DSj1o32bcbjseF8iFkpsSsVTJw2RUqOj3J/q2ptOxFXDh5/dimTPqX6desbHr4AUgIgJT6UklKxsqMfcHVy4PX8rLoxrRttcJpR60YrHfrVYVb5MCMls4THysrypkgJa9cocnnv/OyKzs+ukOwKICUAUuJXKRF4KRQT5OkqcDJx4miAWqt5tzFSog1OmxVoxt7mtdc3XO01IyXL3LmZTCYbKSUPnafPfDQT+rfeIoGXQnj4AkgJgJT4TErq161vXFjkmITEBJm4sEhOzZfksucbtXLKqhDzKhlvmkqF0e2aRVKyzJ0brQhtmpSwaknx9PJ/uLDIIUQNQEoApMRnUpJMZA+4sEjJxAnxUYm4sOholaR+3dooKWEZJbNaN0xKWAqrNsV12gJaEJ62zIDrYDDcaCn59OnTH1xY5BJxBXMlAFICICV+kxJVrW1zYZGikQyVihUSeImc3MJZ9zs3s6Rk3i2at7fBVEKM2jFGt3OcunPDWjebJCWJuHKgn6HiwiKHuRIAKQGQEp9JicBLIS4skqrWqNm8c7RKsgl3bowySrRVj1lSwkLPjPJG5knJMndu9NeLN2gl+C/9CvDv45OYKwGQEgAp8YuUVCuNLS4scuwWSDKRdbRK0r6930gpWTSE+vY2mL7NaDT+MH8yT0qWGXDVH/rbFCnJ59QP927Y1z7ySgCkBEBKfCIlzebdVzbs9zvR1TEh2bQBV23+hxk5YEIwGo0+zJ/MkpJlBlyNjgDOm3tZt3s31Upjy6hKiDs4AFICICUbkOi6KXdu9Pkji1o3TETYXIj2fy+SkoHNOzezhmfflnh/QaJ50za8d1OtNLYwVwIgJQBS4jMpeeg8fXYy0VWRyxs34MpmNsy0V7RzIUbVillSssyA62g03lgpefzZRS4JgJQASElQpESRy3uJ+AkGXB0ITjObZWJl9mPZAdeX556jF4aDGjWPXBIAKQGQEp9LidNVEilTpPsfDxspJWYHRxfJAFsrdmrAdVbuySZJSfH0ErkkAFICICV+lxKnqySl4uVGCgmrSDghL3opWXbAVX/4bxOlpHnTJjFV2McDF0BKAKTEp1LiRpWEDbg+PXY3ciXY7OzJIikZjcbT9NVlBlzZRtCmS8nzf16Ij2YwVwIgJQBS4lcpcbpKwioluez5xldNlq2UaGPolxlwHczJPNk0KSmeXv6P0WowAJASACnxgZQ4XSVBeJozbR6tlCwz4DqvdbOJUnL/4ye2cACkBEBK/CglpWJlJybI390SElRJlrufw4RhmQFX7UVgSMk03XUXA68AUgIgJT6TEi4scmmxgCqJD5lMJo4Ig/YiMKTkvwOvyUT2AA9eACkBkBKfSAmqJP6/n/Pa6zsiN5AS4wN9mC0BkBIAKfGJlLhdJdnEuzdOS8myx/L0F4GNXuPxeCM/v/c/fmITB0BKAKTED1LidpWEUb9uQTCWkJJlNm5mpcI6fU8naG2bfE6lx5+/zh9c/nP9v43u4QAAKQGQEg+lxO0qyabfv3FKSpx4H2ZfvZfe2n9Or6oN4sIi8dEM/VtvTaPn0cYBkBIAKVmRlFQrjS2Bl0JuCwmjdnVj6cEBifnvLIjbrZv3d3XGG1EpUeTyXrvd+SLwUkiRy3usjdNud77gQQwgJQBS4rGUCLwUSh3nySspKeQvTD80bhq39NB5hJQ4kE1idBF40Wtdh17vf/yk87MrKp5evssoyefUXT6aCbEfx7E+ACkBkBIPpaRaaWzxUe+qJAyzQnJ+VoWQ/I6Fd+MisJnXrDmW0Wi09IzLKqPlxVRhX5HLe/pWDauacGGRg5gASAmAlHgoJV5XScxeDL5Qa8g10UXQL1O1mHUR2FwbZzSzFTSZTAI5e2ImwTWfU3chJgBSAiAlHknJqqokUqZIrebd7zL6wwdBYUJipc0DKbEfK2/m1e+/zWwFTSYTR/JTvM4keeg8fV70d4RVTQReCpl5ewApAQBSYlNKVlUlYUFqhfwFSZniu5kRJiTay8Lgl5TYzSiZdxHY7GsymUxbNbPe3zLR9yuIladm8+6r2b8rrGpi5ecASAkAkBKTUtJs3n2NRjKHTADEVJ6cvgxsdehVKySKXIaMOCQl8y4CW3kNh8OFMfVByTc5P7siq2u/rGqSz6m7eEBDSgCAlDgoJclE9uAomZ1KQDSSoZggey4llcs6PT126fysutTa8CZIyapaN/pqyKKY+sFgGJhVYDsPJkUu7wm8hJVhSAkAkBInpKTZvPsa4dLTKkk8phAXFun4KOe5lLRv76dtHC3IJnFGSnq9V1rFa9n1ZS9Wgpc5wNdud76gYgIpAQBS4oCUaKskqeM8cWGRuLDouZAoctlQSC7UGkREh91B0kUXgd0VE3+Hr13+c/2/Zan0f/CwBZASAClZkZRoqySZ9ClFuDQJvLSS1o3ddWFUSpy7COz2y+8rw+3b+/8LYgIgJQBSsiIp0VZJBF6ifE6lZCK7ktbNrK0cSIjxBo2d6oofXpPJZLrSrF8t9kkr538l4icHeOgCSAmAlHgoJdoqyfFRjgReoofO00paN7PAGrBzmL0I7GU7x6+DsPc/fv6vTKb4fxCSBiAlAFLikZQocnkvmTihTPqUuLBI7XaHVLXmm9ZNLnsOmXD4qrBfX34Uk8efXVLk8h6ySACkBEBKXJaSh87TZy4scpn0KfFRKVQqVnZ+t3N807qpX7cgEw5h9SIwBmHfD8Cyvx8AQEoApMQFKVHk8l4ifkLJxMl0FbLbff7TL60bRS5jDdjhi8LalolfX+Px2JeDsM2b9v+dzZ7/f2jnAEgJgJQ4LCWsSvJ7/ZdjNzxUtbbtl9YN1oCdg10EHo3GSx3i83IQ1o+3cx5/dqmQV3fr161veCADSAmAlDgkJaxKEo1kDrXR2slE9sAvrRvt/RuwZOum/zZdxX1zKGLei9ebTyPqWZ4JqiYADzEAKVlSSliVJB5TSEwV9tmP/27dcH4QkvOzKmTC0dbNeFp5MLp7s+rsknkvdl/HjwmwmfTpX6pa28bDGVICAKTEppTkc+ouH5VI4KWQ9l96fmrdtG/vIRMO5ploKw5stkQ7XOr3ls5oNPZt4NpVtfH/iKn8PmuBAkgJAJASC1LChUWOC4ucvi/ul9YN1oDdjaPXDrqyNdwgtHQmkwn1X/tLRey7OWuSz6m7xeLlDuQEUgIApMSklJSKlR0uLHL6a6h+at0gLM2brBJtLsgq7+HYzTMZ+HDe5P7HT8rn1F2714YBpASAjZISLixyAi+F9H+x/NK6UeQyxMEDKdE/0PUtnSDkmfR6rzQYDH3Z1mnf3v9fmfTpX/mcuovKCaQEAEiJgZSwKkm73flidP+GtW5Y3PwqpKR2dQNxcPmIH2uBaBmPxzMzQ157fV9Ky2QyoX7/7Veuic3jhF5WTpAKCykBAFKikRIuLHL5nLqr/0ulbd2wK8HxmII14A2Pn583HOu3sDUi8uVhP62cnJ9d/b+p4/y+qta2UT2BlACw0VJSKlZ2WGrrvNZNPKYQFxZXEjOPsLTVbee8b42M6OW5F8j2jh/v5xgkw1I+p+6KKe8Epdm8+8q+B2hziQCkBICVSInAS6FZ3/xY60ZM5YkLi8SFRUqLhZWvASNi3ruWjrZVMy+iPijzJkH4vD/+7NK/9Rblc+pu6ji/n8+pu83m3VcnAtna7c4XJiHJRPagVKzsoH0EKQHAt4muRq2baCRDpWKFIlzacyEpFS/ffcPGbIm3aa+LklODNgjr1/s5C4Zj6fzsijLp07/4aCakyOW9aqWx1W53viwSlXa780VVa9tiqrAv8FKICQ6kAVICQKCkhLVufh/lo3a7s5IhV+0a8IVag5T49JhfkF5+vZ9jpc1z+c81FU8vp6Ii8FJIkct7DK2E1K9b3xB7DykBINBSkkxkD46S2elRPlWtbScTJysLS7tQaxh4hZQ4+vLzAKyZ6glrqXJhkRS5TKVihaqVxhYkBFICwFpJCWvdsH9psUN9qeP8StaAmZDg7g2kZBMHYGfxb71FxdNLSsR/DaHncyrhSjGkBIC1kxJVrW1HuDRpw9S8TnVV5DI9PXanQoJEV0jJpg/ALlotvvznmhS5vMeFRU5MFbBiDCkBYD2kJJnIHmhv4Dx0nj7zUSnk9RqwVkiQ6Aop8XIA9uW5ZxgmF4R5E10FZVrxhKBASgAInJSw1o32Rkf9uvXN69C0UvHy3f+vXNYhAT5k8Dag0WhEo9GIBm8DevuN9rhfkAZgtSIyGo1oPB4HSk60cyZ6xFRhn23tPHSePkNSICUA+F5KVLW2zYVFTjsol8+pu6u+EowB12BmnATxxdagtb+HoMkJq5owLv+5pvOzKzo/uyJFLlMmfTrd3GHXwcVUYZ9t75SKlZ1qpbFVrTS2ms27r5AYSAkAK5ESo2RHgZdCmfTpyoREn1UCgsGsuzlBGoDVt6cmk8nC7JYgb/QwibmqNqYSk8+pU4lJxJUDJjHJRPaASUw+p+4yiUEyLKQEQEockxKj6f0Ilz5cZZUEA67BDV8L+gDsa68/s9WzrnJiZbhWKzF8NENMViAlkBIAKXE0p0R7GyMmyN9XJSQYcA02k8kk0GIymUzm/h42XU4ef3bp/OyKWNIs0mIhJQBS4qqUrCI0Tb+Fg1s3AR6EHQxpE15m5ITF9jP6r33q9V4D+2ebz6nT4DbMm0BKAKTEEykRU4V9MZVfmZS0mncfDvKB4PDy3Jtu53xkvFFyMk/QxuMxDd4GgYq/Pz7Ksa0ecupgIKQEAEjJXLwOTdNSyF9QIX+BSgmGYQMpJ4PBkF6e/5t9Mms+ZdbPDcLhwMefXbqqNtgw7F/IRIGUAEiJa1KyitA0/e2bQv4CD+91Xh1+6a19a0crJ1ZnbIbDYeCuGv9bb1EmffrXps+X4CEGICUOS0m10thKxE9Wmk+C0LT15+1tsBFzJ4PB0HYCbtBu9DRv2sSFRQ5SAgCkZK2kpNW8w4N7I+Lqx4TX/FeQAtzat/ekTYWGlAAAKVlaSlZxGVgP5kk2ZyA26OvDnlVcArCCfHyU2/iNHDzEAKRkzaQE8ySbN1/S671Sr/e6tgOwTraC/PxnmUmfkpgq7ENKAICUrI2UYJ4E+SZ4zX6NRmNf/xkWTy//R+Cl0KZWTPAQA5ASh6VklevAmCfZ8Ij61z6sw+SciZ+3c37Hz4eMzldASgCAlARKSjBPgoh6vMzlmvg5dK19e0+JuHKQz6m7kBIAICWBlBLMk4BNWRV26uXnzZzHn11S5PKemCrsb0ryKx5iAFLioJSsOjgN8yQAq8LWX34/Dnh+dkUCL4Xa7c4XSAkAkBKrUoJ5EuArMRmNxjQYDKfH7Ky2eEaj8dpv9vh1M6d9e0/F08vpRWFICQCQksBICeZJwLt14RnXdM3ekyH6Fdm+KUO0o9HIT1s4lIgrBwIvhUrFys4mVEkgJQBS4rCUrDLNFfMkwNL6sInZE331wG7cO1aG7QWpbWJmCR5iAFKyJlLC5knufzxgtgQsfW3YqJ2xykOAo9HIsxbSqsXk/sdPev7PCylyea9UrOxASgCAlAROSlrNO2o170iRy5ASsNS14XkbKasKaGPDqP3XvidyMplMVpZlclVtEBcWiQuLhJVgACAltqVklWmulcv69H/Xrm7w0AW2VojNrMiuIgtFP+/hhZysUkzuf/wkRS6TwEuhaqWxBSkBAFISKCnRAikBVjd1rISJGWWhTCYTV2Vl3hBqr/dK/f4bDYdD07IRBDF5/s8LNW/alEmf/rUpcoKHGICUrKGUtG/v8bAFlq4NW33waqsU7MHde3HvarHZzRgz7aXhcGgpy2XVYrJJcoKHGICUOCglq46Yh5QAL9eN2VDoy3PvneC4Fd5m9zDh4G3wQZZ6L70PWS6LPu5ZK9aQE0gJAJCSOdz/eMCDE3iyVuxWquxkMvkwM2LnYvJkMjH8mNh2kfbHei+9uS0gP93LWVc5wUMMQErWUErwwARBj7sfDocfAtssS9Ng+GG1WSsdrMLD8lfY2y66H+SnC8PrJid4iAFIiUNSsuq7N3akBAmwwG3MDp/OWkvWVkucap+wKor25g37MSYqr73+3PkYqx9L/brl6hkIrZyoam0bUgIApGSlEfNWkl2fHrt0flbFlg7wps1jI9tEu/rrxkxHv//2rrVjVFnRz50sM/z69NilXPacpEyRzs+qdNO4nfmPgqfHLrVv7221YZs3bcrn1F0uLHJBDF7DQwxAStZMSkrFy7nftFjAGlaHgV/FRJ+oyqolTg+a9l/71O+/ffg4tYO786o9VsXk/sfD9O8ew0hQLtTa9L/Xr1u2c060cvLQefoMKQEAUuIbKWHVEf03RDwwwSqC2kajEb29DQxv8OhFgVVL3uYM1i6zDm3mkOGsOZPxeGxRFj6KibbKWb9uUal4+e7Hbxq3S4Wwaa8M+11O8BADkJI1kxKj6oe2OmKlqgKA0/Rf+x+2dvQPfKPqw3g8dkVKrDBrzsTqdeF5YjKLC7W21Mf++LNL52dXxEczoWQie+DXq8N4iAFIyRpLiVF1BFIC/NzemVV56L/2Vy4l8+ZMrH5sread5b/bF2qN2rf31L69p4fOo+3fw+U/15SIKwfJRPbAbxs7eIgBSIlDUlK/bn2Lx5SVSwnrQc+qjkBKgJ9XiOdlnxhdLvbLVtFkMjFsBc3jpnFr+++5Ipdtz5sw/q23SJHLe1xY5MRUYV9Va9vd7vOfkBIA1kBKVnkhWH8teF51BFIC/H652Mr8h5+OGdqRpmXEhM2FObHa/2+9RcXTS0rElQMuLHKKXN5T1dp2tdLY8rLVg4cYgJSsmZRYIZc9x4MQAIfmTPQrxlYyTJb9ezzrtET79p5qVzdUKl6+g0UCtG/vDaWmedOmy3+u6fzsijLp079YNQVSAgCkBOmvAPi8usPmTOy+D+0a8DLzZFoJsSo2WlExGpQtnl7+j9tigocYgJRASgAADg3rLvPznRATp4MYL9Qa1a5uqHnTpuZNm7iwyLk5d4KHGICUQEoAAD7BKzFJiwVKHecpdZynZOKEEvFf8FGJ+KhE0UjmkAuLHBcWuWQie6DI5T1FLu+5va2DhxiAlEBKAAA+4emxS4X8ha2/y0wyrIoGG2itVhpbD52nzw+dp8+r2sLBQwxASiAlAIA1EJMIlyYuLJKYKpCfRANSAiAlkBLTzJraBwAES0zSYoH4qERiqkBBEBBICYCUuCglqlrbTiYgJQAA58TEahy9lClSIn5CAi+F6tetb5ASADZUShS5vJc6zkNKAACOYedODpsviXDpw3xO3YWUAAApgZQAAFYqJjFB/s6FRc7vl4EhJQBSAimBlACwxmKSFgsUE+TvaN8AACkJFMse9QIAeIPVOzliKr+fFk//CtLQKx5iAFKy4VJSu7rBN3wAAiQmViLkM+lTSsSVg6CICR5iAFICKcE3ewAC2tK5adxS5bI+V1SYmHh57RdSAgCkxBEpuf/xgG/4AKyhqMQE+buq1rYhJQBASgIhJSwXAd/cAVjPOZSYIH8XeCnk9g0bSAkAkBJbXKi1DwmS+GYOwPoe+Usd54mPSiE/BqzhIQYgJQ5JSTKRPUiLhcBJSal4+SHSGi0cANb/+jALWEsmsgfN5t1XSAkAayQlXFjkgiYkTEr037CQXQLA5tzSOUpmKcKlDxW5vLfqoDU8xACkZMOlBIFqAEBMsidnlMuekyKX98RUfr9UrOysYo0YDzEAKYGUQEoA2LBk2Fz2nC7UGt00bumh8/jubdq395TPqcRHM6FkInvg5dwJHmIAUgIp8URK9N/4AAD+56raIEUu73FhkVPk8p7bsyd4iAFICaTkA63mnePf3FB9ASC4PP7s0uU/13R8lPtb4KWQqta2q5XGVrvd+eLkHAoeYgBSAinxJOX1pnGLb+4ArAHt23u6/OeaiqeXxEczxIVFjiGmCvuKXN6zO4+ChxiAlEBKPJESxNkDsG7zKT+JC4tTxFSBqpUGLRPMhocYgJRASjyRkgu1hhYOAGvIv/UWFU8vKRFXiAuLlM+pu3aHY/EQA5ASSIknUlIqXkJKANiA6snlP9fT4dhkInugqrVts8cA8RADkBIHpOSh8/SZj0qhTZISq6mvuew5pASAza2iHHBhkSsVKzv169a3WcOxeIgBSIlzUkLrIiXnZ9WF32zq1y1L35yQfwIAqihX1QYVTy8pkz79iw3Gsi0eSAmAlEBKZkbPL8ocsdLieeg8utYWAgAEl+ZNm87PrqbtHjFV2J9XSQHrBaQEUuKIlLSad5YEo317DykBAJj6XsEqKQIvhVi7Bw9wSAmkBFIyk8plfeHb6DNKpEyRKpd1fOMFAJgObPvd7vmfRFw5YEOzq7jJAyAlkBIfS0mpeGlJSmpXN6beLwAALKqiMEHJ59Rdt2PvAaQEUuIDCvmLaYXj6bFrOLRqRTAu1BqkBADg+NCsIpf3+GgmpMjlPbR5ICWQkjWVEilTnLnGe//jwbJglIqX794vAAA4vXqcz6m7ifjJQalY2UEFBVICKYlKdJTMUuo4vxZSwuZA9FJSv25ZlpJc9hxSAgDwbA6FbfPkc+qu2eA2AClZGylptztfBF6ieEyhdamYMJHQb8zYacVo3y+ySgAAXgqKdpMHggIp2QgpqVYaW4n4CfFRibiwuFZtHL2UFPIXlqSEZZRoKzBefEN66DziGzMA4F38/fFR7m+WhQIpgJSsvZREuDQlE1k6PsqtZbrr02PX9IaOPqPEzbs6TsTgAwA2a/6EtXcQ1AYpWVsp4cIiqWqN4jFlLdeDtYJhVkrYbIqVCHunKiVoFQEA5rV3WPVE4KUQqieQkrWSEj4qkSKX99rtzpdoJHO4LlKSy55/yBuxMrSq/zna9+c2CGsDAJit6OZz6i4fzYRUtbYNYYCUBF5KopEM5XPq7qdPn/7gwiKXFgtrtR6sX+01KyVsMFaLUfaJG1yoNXzDBQBYqp4UTy//h2WfoLUDKQmslHBhkaqVxtanT5/+UOTy3lEyS1KmSMdHOcqkT9dCShS5bFlK9CLj5QbOhVrDbAkAwBbnZ1eUiCsHilzeQ+4JpCSQUsK+cKuVxlZMkEnKFEngJUomTgItJe3b+w9bNGalRJtR4vWwa+3qBi0cAMBSsLXiZCJ7gLkTSEmQpIRjpb5u9/lPLixyUqZIbCsn6FKiH1g1KyWLNnrc7hN7OcMCAFjvrR3ICaQkUFKi/TGBl0JiKk/HRzniwiKJqeAmvdavW1S5rFuWEqPqipQpkiKXPVsLljJFZJYAAByjedOmfE7dFXgpxFr2AFLiKylhO+/aHysVKzuJ+AmlxQJxYZFYOyeoAWpGsyFWM0q0eDXrwaQK30wBAE7LCUuLhZxASnwlJYpc3lPk8p72x5rNu698VApJmSJxYTHQSa9GGzRmpMSo5aOtvnjxjaOQv5hePQYAADfSYhW5vAc5gZT4SkpKxcqO/se5sMhl0qfT+Pl1Sno1s9qrzyhZxVzJ+VkVLRwAgGeVk2Qie4BtHUjJyqXEyJDFVGH/+ChHMUGmZCJLAi+tlZQsWu2dVWHxcq6EiRFaOAAArwZiWUos5ARSsjIpMbo+qaq17XhMoWTihPI5lbiwGPjMEitSYjSHoqXVvHP9G0SreedpZQYAAFjl5Pgo93cykT3AdWJIiadSMot2u/MlwqUPU8d5UuQyKXI58JklVqTEKKNEixcZImwDx8skWQAA0OacJOLKgVGLH1ICKfFUSthciZjKk8BL1GzeUTSSWRspqVzWqVS8nBmGZuWujtsbOFKmSDeNW3yTBACsJL6ebWliGBZSslIpYZHzES5N3e4zCbwU6MwSs/MhszJKVrEazCo2aOEAAFa9qYM1YkjJSqWkft36JvAS8VGJHjpPVCpWKB5T1kpKjORiXkaJ1y0c7WwLWjgAAL/Mm2z60T9IyQqkhEXOJ+InVK00tticybpJiX6+ZF5GidctHO1qshfDtQCAza6GmG3pnJ9dER/NhDZ13gRSsgIpYZHzifgJ5XPq7qdPn/5IJrIH65ZZopeSeRklsw7+ufVNQitIF2oN3zgBAK4OtrJNy/OzK2retOnxZ3eunLDwtU27qQMpWZGUlIqVnV+zJIV9tiocE+Tv6ywl8zJK5iXHutFe0baSvMpHAQBsfJDaNM1b4CU6PspR8fSS/q23DCWledOmRFw5UOTyXrf7/CekBFLimpSwyHntfRyW9rquUrIoo2QWhfyFK2LidT4KAAD8nh2hZCJLqlqj+nWL8jn1naRcVRvTlg9r6WzKlg6kZEVSwiQkwqUPmQGLqcL+UTK7NlKiT0xdlFHitZhoPx60cAAAK8gqoWQiS83mHRERdbvPf9avW99KxcpOMpE9SMSVg3xO3b2qNujfeosy6dO/xFRhf50HYSElK5QSMVXY58Iisdjh+nXrGzvYtw7os0qcOALo1gaOV/koAAAwR06+GlXVmaTw0UyIC4vcOldNICUrlBJVrW1zYZG0X1xcWOTSYmHtpMRsRsmyibFWqFzWPc9HAQCAeSmviyLo2+3OF1Wtbeuv0ENKICVLS0m73fnChUVO+8WVz6m7ifjJ2kmJ2YySRZSKl459E6hftzzPRwEAgFlrw4m4wgZhuU3NK4GUrFBKWGVE4KWQ/jbOOkiJNi3VbEaJl4mvelFCCwcAsEp+D7Rq4TZp8wZS4gMpYbcP9Bkm6xA7r61qWMko8Wq25Omxu5KIewAAmLedw0czVCpWqN3ufKlWGluQEkiJZ1JSv25948Iipy3TlYqVnZggr5WU2MkomZf4eqHWHAlXU+Ty3OFcAABYRSvn+Cg3zbFC+wZS4pmUsMh57bAr+7GgS4m2HWI3o8TtGzn6j6uQv8A3RQCALyieXv6PwEuhTZotgZSsWEpYxLz+zkEykT1Yh8wSJzJK5l0iXja7RL+BI2WKrsbbAwCA1a0cPprZmAvCkBIfSEmpWNnRr3f9viQc+MwSJg1uvf+bxq1jh/lmhb4BAMAqad/eTy8IQ0ogJa5LSbN591U/7GqUWSKm8pRMnAQuat6pjBI3LgobrSqjhQMA8BuPP7uUz6m7yUT2YJ0HXyElPpASJiD6L7RfX4An76SEC4uBkxKnMkrcCFSbJUxo4QAA/MjlP9fEhUVuXa8HQ0p8IiViqrCvT/FrNu++RiOZd5klXFik46NcoALUnMwoWZSHYkdQ3GgLAQCAm+2cRFz5MIsIKYGUOCYlzebdV6NoYX1mSTSSoXhMCZSUOJlRMgtW2VDksuUqh9FmkFZ0AADAj+0cdqBvndo5kBKfSMm8IVithAi8RNFIJlBZJU5mlMxbD77/8WArXG3Wx+f0VWIAAHAjBVbgpZDRMT9ICaTEcR46T5+1mSWJ+AlxYZGCcrSvVLx0JaPEaD2YyYXVVeFZlRy0cAAAAUqBDalqbRtSAilxVUpYZgmbIzlKZokLixSUDBNFLruSUWLlGOAiWs27hbMqAAAQgBTYv4OeAgspCYCUqGptOybI36VMkVLHvzZwBF5ai0vCbsqQ2WoJa/sYvQ98swMAIAUWUgIpMVgZzqRPpxs4XFgk9v/B8sFqs95Hq3mHb3QAAKTAQkogJfqVYdayiXBpEngpUKvBq769s4hC/sLVi8QAAIAUWEjJ2kiJNrOEj0okpgq0DpeE/VItOT+rooUDAEAKLKQEUmKlhZMWC5SIn1A+pwYu3XVV2z/LbOCghQMAQAospARSYkA+p+4m4ieUTJyQqtYomchS6jgP+XAghn7WBg7LQME3NgAAUmAhJZASDe1250uESx+mjvOkyGUqFSuBSnf1c7Vk3n2eZY/+AQAAUmAhJWsnJSx2/vgoRwIvUbvdoQiXhnhYiKG3s4EjZYp0/+MB39QAAGuVAuvHdg6kJGBS8juzhLiwSIPBkAReIu1tHFC0vUUzL+QNLRwAwLqlwCbiyoHftnMgJQGTkm73+U8uLHLRSIYeOk9o4ThYLZkXh48WDgAgaLw89+i115/bzmFha36pmkBKAiYlLLOEC4vELgtHuPQhpGP56PlF14ytXh8GAIBV03vp0Wg0nisnrGrihyFYSEkApaR+3frGhUWOpfUJvBRCC2f56Pmbxu3cn1+/buGbHAAgkGIymUxoNBrRy3PPsKLSfXomKVP8P6u+nQMpCaCUsMwS1gssFSs7aOEsXy2Zt4EjZYpUyF/gGxwAILCtnNFoTERE/f7bh/8+HA5pNBpTqVjZWWXYGqQkoFLCUvo+ffr0x0Pn6TMXFjlIx/LR805s8QAAgF9hYqKvmvR6r8Re9esWCbwUarc7XyAlkBLTsfNcWOTY/08msge4hbN89Lwil9HCAQBshJhMJpN3VZPRaDQVk3a7s5K1YUhJQKWEzZKw89S/V4W/QzqWq5bM28CxElsPAABBEBMiouFwSL3eKw2HQ9K+ut1nSiayng7AQkoCLCVGcyaZ9CnEY4no+cplfeHPnTcsCwBYbiATn4fViMl4PKbxeEz612AwJDFV2PcqzwRSskZSIqYK+0fJLKRjiej5+nXLscvDAABrDIdDwyFM4B6TyYQWvQaDIZWKlR0v4ukhJWskJc3m3ddoJIPMkiWqJYs2cNhqMWZLAHCefv9t+hDE58O7rRyjConRq1ppkHZsAFICKTHVwkmLBUiHzej5p8eupWoLtnEAcLZ9w16j0dgwUwO4l2Ni5tVs3pHAS6Fm8+4rpARSshBkliwfPb9oAwdVEwC8aSdMJhPMmfhQTLrdZxJ4KaSqtW1ICaRkLsgsWb5asmgDB1UTANydK9G+RqMxPi9etc9e+2T21ev1SUwV9vM5dRdSAimZSzKRPcDAq/3o+Qu1Zvt9oWoCgDNzJRAT/4vJYDCkfE7ddTKaHlKyhlJSv25946NSCNJhL3p+0WE+VE0A8GauRP8AxOfHGwaDIVl5qWptW+ClkBObOZCSNZQSo4FXMZUngZcgISaqJWY2cOxUTe5/PNCFWjOVc9Jq3iEPBWCuRPd6exvg8+NZhsnIkpg4NQALKVlTKdEPvGbSp8SFRUod45rwouyRh86jo3koD51Hql+3pgO0hfyFKeE4P6uiHQQwV6J79V/7+BytIFzNzOuh80QCL4XYBXtICaRk7sBrNJJBtcRk9Pyqwtv068mF/AXaQQBzJfohS2zkrLSVtmgzR0wV9u1G00NK1lRKjAZek4kT4sIiIcdkcbXEzgaOE5s/s8TEaPYFgE19GGJV2J+Dr9r5H0Uu79kZgIWUrLGU6BNexVSeuLBIyDFZXL2wu4HjlpjksufTis6suz0AbFL8OTZyPBx8fRuQnVepWNlJJrIHVgZgISVrLCXskrB2jiTCpYkLi4TDffOj55fdwLHaOlokGvc/Ht6FulUu6xiEBRs7V/JfMRnhc+XTwVf2ql+3SOClULvd+QIpgZT8oaq17Zggf2cPs5ggExcWKZk4gYTMqZa0mncr+bXnzY7oxUSRy9Rq3uEbJtjIuRKsCvs38VX/arc7JPBSqH7d+gYp2XAp0a8HHx/liAuLFOHSkJA50fP3Px5W9uvPq4LoxQS5KABDloTLwh7x2uuT3Ve3+0zJRPZg0QAspGQDpCSfU3cT8f9WRriwSFxYJKS+zp/zWHV2yqx1YKMqjlNpsk+PXapd3aACAwIxV4JVYf8Hq+mrWmKqsK/I5T1IyQZLCVsPZnMkAi9RMpElPor14HnVErb1supVZaN5k5vGreHbF/IXdP/jYalvOiw8TpHLdKHWln5/ALg5V4KNHH/LopGYlIqVHTFV2DcagIWUbICUfPr06Q9FLu+xaslRMktiqkACL5GYQpjarOj587NqYD/+ZQdh9dKTy57TTeMWw7XAl3MlWjF5eYaYuN5a673Ssq9qpUECL4UeOk+fISUbKCXtdudLhEsfSpkipcUCcWGR8jmVYoIMCZnRPqlc1gMfCLfM+rBRNYZ9XjDDAvwa3qVfFX557lGv90q93is+pz5YE14UTQ8p2RAp0YepRSMZql+3EKY2Bz+0b5zg/Kxqu8IxK68FcgK8bOGMx2OLYjKaG/w1Ho/p7W1gWFXp999oNBrRYMZ/B//F6p/LrAFYgZdCqlrbhpRsmJQ0m3dfWbUkHlOoVKxQPqeSdggWrG/lx+4g7LwgOSYnaOsAv2VkmH1gjkYjensbzJxfGY1GGKJ1YRvn3dmAXp/EVGG/WmlsQUo2jGQie3B8lJteDX7oPBEXFvHg3qAcFjvVjUWx+4pcRgw+cI23362Cl+cevb0N6O1t8O5Y3Gg0pv5r3/IBOavzKpsmJ4sqRcts4hhVTLiwyFlJfw1qfD1kREP9uvWNVUu4sMh2x7EevIGDvFZXhc20s5zY/gHA6F/k+vRWNmw5HA5de1Aa/6t+9bMpXn0Mi34duymv84Zf7dzLgZQEGG30fEyQqVppULN5hzC1Db2MbGUQ1qyYIAYfuPEvdqPk1tdef+YRuWXWVv2+euxlWJy2OqQfInZaSoiIxFRhn82XQEo2REqqlcYWH5VCbDWYiEjgJdLeyAGbgxWBeOg8fkiUdWv7BwB9C8fq5o5b7ZzJZLLyz4XVz8cyQsjkj7XKWFvHjapUr9c3XBWGlKyxlLBqyVEyS1xYpF6vT9VKA2FqGz4IazbF1Sjq3slWEQB+SSD165XiXu/VUzHq99/erWezatGbA2vBs474JRPZA0jJBklJ/br1jY9KIT4qUbN5R4PBEOvBwPQgrNXbQIX8Bdo5YHXtDpfaOau6UswEwatqiZHcTSYTS4m7Vl+KXN5zso0DKfG5lLBqicBLlM+pRERUKlYQpgZMrw/Pirqf937RzgGrDGJzo52zqivFXreR7ATZ+amNAykJgJRUK40tLixyXFikT58+/dHtPv+pvZHDSB3nSf9jYDPC4xZt0lgVEylTdORwIACrTCLVv7ysWOjvz3haLXGpXeNFGwdSEgApYSmvXFikdrvzRX8jhyHwEgLWMAg78xtV7erG1vvEAxKscsXY6XaO1xkmbPPF66FbM6F0Tn5u8zl1N59TdyElGyIlzebdVy4scqx3p72Rw0gmThCwhvXhua2Xeamv8+ZX8IAEq1wzdrqd4+WqrnbGw8tqiZljfPpwu2XbYwIvhdg/nCElay4lrFqiLZFpb+RImSKJqTxxYREBa2DuHR07YoIBWLBu7RyvZky0my+LqiW93quj2SqLNppYoJ1Tg7ClYoUEXgpBSjZESli1hMX7Npt3X6ORzLtqSYRLUzSSwYMZzByEtRKuBjEB69zOGY/Hrqeu6o8N6qsl+qqN0yvMiz5fTmaZCLxEXFjklmnjQEoCJCWfPn36Q0wV9uvXrW/azRxtmFpMkIkLiwhYA3PXhyEmYF3aOU5Iymg0ck1O9G0UfbWEiN5VR4bD4YdIfjeP8Wklada1Zivx81xYJC4scnbbOJCSgEmJHlWtbccE+Tt7aLCgNawMg0XhaE+PXUvhahAT4Md2zuB3aqpTCbCj0YhGoxENh8NpImu///artWKzvTJPBPQBb0wMnJw/mRczPx6PDQPf7K4H/5YS220cSEnApeTTp09/cGGRY2FqmfTp9IsCAWtg0SCs1dRXiAnwWzuHVTjcDAj7MI9iURjmxd8bvU+njwq+PPdoMpnM3MjR3yYymxVjJC/5nDqtlihyeQ9SsoFSUipWduIxZfrAiEYyxIVFrAcDU+vDdsXkQq1BTICvcOu437JiYvSAZ5UQo8vG7O2dXCPu999oMpkYzuXMGvpdJCassqR9PXSeiIV9cmGR044bQEo2REoeOk+ftWFq8ZhCyUQW68HA9B2dVvPOteA2ALysnHj5Mpt5YtQ+YcJh9GP9/psrEfmj0Yje3gbUe+l9EBO7GzxMdrSvZCJL9esWiamC5TYOpGQNpISFqSUTJ9Nk12QiS8lEFuvBwPQgrJ3UV6tHAgHwcgXXm5j1V8N2iZmPyejHh8MhvTz3XEmiZTJiNDA8L7tFK0lGMyl6GWw270hMFaYR9FbaOJCSNZGSZvPuqzZMjQuLVK00sB4MLK0P169bS7WE8FAEfsCN2znzWhjamQwmFOxhPU9KZrWb+v23D78Hp/JL2PCu/nOlH3i1so7d672+y5H5HaRG3e7zn6ySb7aNAylZEylhYWrHR7lp5Hy10iCBl7AeDCy1Y+ysClu9XgzAOh2lYw9io4RU1jKxswU0b0tm2TaOUYtmkfj0XnqGw7JshVn7ey8VK1QqVnbYtXttxhakZEOkpFppbPFRKcQi5/M5lVS1hvVg4KuoewDWsY3jRgVm2a2fedkp+nmYwWBoOuXWqBL18tx7J4O/14M57UKGmCrsQ0o2SEpYmJqYypOYypPAS9O9cawHg1XnogDgNWaO0gXt5dSasNEMiZVjhfoBWCY0WhlU5PKetm1jJukVUrJmUlIqVnZYmFqES9ND54nyORXrwcA3abLA/6zLn5mZo3Sj0djTVWInovGd/Py4cdeHtZ6azTvS3mvDTMkGSok2TC0myFStNOih84T1YLDSIdpl2jlPj126adxCFjxkndpvZkLVnL6p47fwtnkzIk7c9mGfO1Z9YWFtv9eDD6xEzkNK1lBK8jl1NxE/oaNklsRUYbo3jvVgsOrANrvf+FrNO8plz+n8rIr1Yw+oXd2sTTCefr121pCqUXaHn1/6teNVDxazxFh9Zky10iCsBG+4lGjD1LiwSLMuCgOwiu0eu2Fr2uRZRS5T5bKO4DaXaDXv1qo6ZWbo9eW553n42rJHBP14KFG7Hs2GZ7UDr5CSDZQSth58lMxSNJIhVjpjQ7BSpkhiKk8sbA0Ar6lft5YWE+3cCto7zrdvzs+qGzX0ygY1l72U68dEWS/RD9COx2MqFSs7qlrbhpRssJSwMLV4TJnuimuHYNNiwXArh+WcAODXIdinx65hlooil6l2dYPBWocGXaVMca1uG81LJdW3RIIiJk4Ovbo5bPz7Hk4IUrLBUsIqI4n4ybvpZ+2NnAiXJu0hP5YEi7A1sIr7O06IifZYIORkOaRMce0qUOPx2DDgzOgwXVDExKkIerfbZ2KqsN9s3n2FlGywlFQrjS2Bl0Lafp4il/fYenBMkIkLi8QkhR3zQ9ga8Jrzs6pliXh67NL5WdXx9wv+KyXr1sJ57fWnGyezxEQ7QBoEMXHykrCbNP69NbUeDClZYylhlZFoJHPIAmza7c4XdiPnKPnrkrB2tkRM5T+ICgBeVU3s/Mv8Qq25Ij2bTql4SYpc3rgbOfpU0yCISRCqJS/PPeKjmdBD5+kzpGSDpaRUrOxwYZG0SXpsCJbNlUS49Ltv4NFIBuvDYKVVE6uzDGbEhK0lQ07MS4mUKa79CrY+mdSo8jDweWR9UKolxdPL6YwjpGRDpaTbff6TC4ucdsioft36xm7kRLg0cWHx3YBrMnFCfFTCAxKs/GqxlW94N41bROC7ICWbcP1ZLyZGlQf926xroJqb3P/4uXA9GFKy5lLC5ki4sMhpy2ZsPTgmyJRMZN9JCMs3wb0cELQNHStiksueI4htQYAa+zxtwu9XKx2zKg9WxGTWzMqmBKrNQn8PB1KygVLSbne+cGGRq1YaW/obOUfJLOVzKgm8RCzDRMoUiY9KHzZzAAjCcb/27f2HLJNF4oMQttlSImWKG/P50UrHrDkNs2IyGo3mtn3cOBZo9srvKrmqNuYOvEJKNkBK2ByJ/mw0Fxa5XyFqWSoVK++2bhLxkw+zJgCsklz23PRNFqOQNbR07EuJ3bC7IIvJvDkNs2Iyb8vHzKyK1WpLUGZL+Ggm1O0+/wkp2WApqV+3vul7eWw9mF0T1m7dpI7zH2ZNAPADF2rN1CDs/Y8HymXPLcfgYxD2Yyts3VaDzYrJvK0WM2LSe+lR76U3U0pYuJhR1YQFo1m9xxOETZx8Tp058Aop2RApYXMk2muNbD04JsjUbN6RIpeJZZiwIDWBx8ArCO4g7KKQtVnvG1WTX20w7edl037/7Prt/JXikakYeKM0Wf2FXv19HiYXVu/xBKFa0r69n5nwCinZICmpX7e+6U9IJxPZAz4qUalYmVZLtHMlyCwBfm/pLBpWtSMmy8Tgr6uUmG2drZuYLKo8zGuxaDdi9ALT670aXttl7087tDocvh/CDeJNHD2JuHJglPAKKdkgKZklKhEufZhMZImIKJnITjNKEvGTD+FqAAQxEfbpsWs6y8SJGPx1lJJNWA2elQJrJ4RNf8n35bn3TiiMpEQrQ/ofYz93UXWGzaL4/fN6+c/1u/wsSAmk5F1bhwuLxA75RSOZQ+1cSTSSwYMPBKKlU7u6mTtvYkdMNvWBrJeSQv4CszYWxUTfStGmw86TkllyxGZNzIS56dtDQcksgZRASljqK8dKaQIvhdhRPjZXol0XBiDIcfXarRKrQ7DrdDXXzKCw/nMA+bAuJvrsENaKsSol+p+7qI0ThPVgo8wSSAmkZLoezKah2SE/NleSTGRxpA+s1QqxlZA1vfBs0myF/ve/iXMly4qJUftnMplQv/9m6/1PJhN6exsYDs8GbeD1qtr4sIUDKYGUTNeDtYE2XFjk0mKBEvETyufUdwOwAAQtFdboYbqMmNg5HLgOUoKtJPPiwDAalO31Xm2v7r72+tOZkUUBbH4feG3f3pM+PwtSAil5l/qqbenEYwqljvOkyOV3A7AABHUYVp9MaidkbZPmTIw+h5COxfRefg21Dt4G74Zd9Vdz7b7/4XBIL8+9hevCw6H/Wzj6uRJICaTk3Xowmyt56Dx95sIix+7g1K9b0/s4Yir/Ls8EgKCFr2k3dZYRkwu1tlFSoshlSIcFMRm8DVwTA9YWWrSN4/d7OMdHub+16a6QEkjJu4vC2i+OXy2dXxeD2+3O9EgfExU2DAtAEIdhtcmw9z8ebGWZrPsArNHvF4m35nl57k1xU37mtnBszq54OOxK2vwsSAmkZCbN5t3XCJc+TMRPqFppUD6nTisk0UgGq8JgLahc1umh82g7ZG2dxcTo94rLyv4+JDgvK8WPnJ9dkfZYLKQEUrKwpROPKcxmp0f64jGFuLCIVWGwVnKybMVk3aoIyGwJTkVm3opwkDZwICWQkrlUK40tPvorXI0lvh4f5ej4KEdcWKR4TMEDDazdzEmpeGl7DXmdxGTWNhNEwH+8zQlU8/MWTvOmTYpc3oOUQEosJ74+dJ5IVWsUE+TpXAlu4wDwcV5Fv+WzTlKCYVd/ryIHbQvn8Wf33XE+SAmkxHTia7XSoF6vPxWRaCRDAi/hNg4ABg9uo4rJTeM2ULMns35/GHb17wHBIAapadeCISWQEtOJr4pcJiIiMVWgo2SW4jGF8jl1OmcCAJg/Y1IqXgZqKHbW7w3JrsGKurcba+8VmfTpXw+dp8+QEkiJpcRX/dG+46Mc5XMqgtUAmCMm2lYOm1UJgpg8PXZn/r6Q7OrjfJTeq6GU2E2Q9XotGFICKTEFC1NjNsuO9gm8RM3mHaolAMxp5VQu69S+vX+32eN3MdFfCUaya5CqJaNArQZr14IhJZASS+vB7AuHxdBHIxnqdp9RLQFgzfJN5kkJNnD8vyIcpNXgy3+uSVVr25ASSInl+zj5nLqrrZzEYwrVr1uolgCwZmIyT0qkTBEPf78HqhmsCPt1rkS7FgwpgZQsVTkReInyOXU6AItNHADsXTIOmpRgAyd4K8J+nSuBlEBKHKF+3frGR6WQwEvEqicRLn2IhwwAwT/ut0hKsIETvEA1P8+VsLVgSAmkZOlVYS4sEjvkp8jlvXhM+Y6HDAD2ou798pCoXd3M/Vjr1y08+APAeDwORF4JpARS4gj5nLrLhUWqX7e+aUUlLRbwkAHABjeN20BICdaCgxmo5ubF4mVIxJUDSAmkxJHhVy4scmwA9tOnT3+oam2bj0ohPGAAsIcfYuoXSQnWgoO5Ivza8+cdHBagBimBlDhyG0d7u4ANwR4f5fCAAcDBmHovuVBrgRvOBYsD1fw67JpJnxKkBFLiCKpa2+bCIsfmSrQVFBzrA8D+qvAqHxJmLiXjgR+gFeHB0NfH+fI5lZrNu6+QEkjJ0nS7z39yYZHTzpUwWYkJMoZeAQjg4CukZD0D1Uajsa9TXSElkBJHEFOFfe1ciba1g6RXAII3+JrLngdi9gVYXxGGlEBK1l5Kms27r/q5Em3yK9o4ANifL1nFw9/Mx4askmAGqvlxA4dFzUNKICWOZpZo50q0bZxoJINQNQACNF8SpPVlYG1F2I9x8yzVFVICKXF04FU/V8JQ5PJeIn5ygAcMAPbwMhdkUZorskqCv40DKYGUrL2UmFkddmJN+CiZpWgkQ2gJAeSXQErAegApgZSsbEtHTOWX/uYs8BIJvIQHFUAbxwXq163AHhIEkBJICaTE0hG/aCRzuGyVI5M+pWgkQzFBxsMKoI3jcZorpAQ4zf2Pn5RMZA8gJZASzykVKztOikkifoKHFUDaq6PrmVVICVjJUT5ICaRkZWLiRLCamMoTFxYJWShgk3BbBswEpzFBwsMUQEogJWuBmCrsQ0wAsEereefaw0GRy6Y/DjxMAaQEUrJWYhKPKUuLyVEyCzEBG0Uue77SjBJICYCUQErWVkyOktm/l/0mHY8pxIVFiscUPLQAhl5tDxw+QEoApARSsrlS4mQrJybIxIVF4qMSckzARgy9Pj12HX0wtJp3lj4GRM0DSAmkZKPFZF7OCdvI4cIiRbg0pcUCHl5goy4J3/94WEpUzK4Deyklbm8bAUgJpARSYltMWItmViUkkz6lCJcmMVUgLiySEymyAPgZrYTUrm6WauuYXQf2SkpuGreoxkBKICWQktWRz6m7fFQKzZKO46MccWGRopHMzKoJ28hR1RoJvEQxQUY7B6wtF2pt+o29cllfKsukkL/wlZSUipeolEBKICWQEn8HrLGhVi4szgxPSx3nSeAleug8UalYoQiXptRxHg8xsJawBzfLGLFbLbH667opJewGDx7YkBJICaRk5VQrja0Ilz6cVQ3hoxKJqQKJqQLxUclwfuQomSWBl+jTp09/NJt3XwVeCjmxggyAX2dLctlz20OwVjdv3JaSC7UGKYGUQEogJf6h3e58EXgplEycHMyaHalWGqSqtZnzI/GYQmKqsM/epyKX97iwyGHWBKzjbMkyK8M3jVvfSMlD5xFrxxvE488uCbwUgpRASgI1AKtv57DZkW73+U8mMAL/cR5F4KVQPqfusvfHqiYCL4WcuFoMgB/QD6laDVirXNYt/5o3jVtXjwLivg6uBENKICW+njPRS8TvFk1IOygb4dKH2vmR36vCh6ViZUf7PlW1ts2FRW7eNg8AQcZKJcPszRu3A9yeHrvTqHtICaQEUgIp8S3169a3mCB/17dzYoL8XZHLe9q3E3gppB2CzaRPiQuLXLN591X7Prvd5z/zOXWXC4tcIn4COQFrVz1xa8jVLSnRtpGsfPwAUgIpgZSsBEUu7/FRKcSGW1klRFVr21rZEFOFfW115Xe7h2u3O1/07/Oh8/SZzZvEBPk7gtfAOuaYODnk6paUsGFdt94/gJRASiAlrldN0mLBUDiqlcYWFxa5ZOJkmnMi8FKo233+c16riMkJ1ohB0DEz92FnyNUNaWBrwJCSzeL87IqqlcYWpARSslZVk1nC8dB5+pxMZA/YEKx+DmUWqlrbFngpxEelEOQErHMLh63frlpK9HMtreYdHtqQEkgJpCR4VROWQaJfAdanxbJ14Jggf5/1dkaZKQIvhSJc+vAomcWDDgQOp5Nc3di+0a4B4+AfpARSAilZiw0dLixyXFjktCvARtkn8ZjynY++XxVeRLN59zWZyB6wjR3MnYCgMK/ioM83WVVOiVG1xukryFbov/YhDB6hyGVqtztfICWQkrWj233+kw2s1q9b3+a1fSJc+pALi5x2QNYMD52nz0yA+KgUQhAbCNo1YS2t5t3KpUS7BmylwuOakPTfqN9/gzB4RCZ9Sg+dp8+QEkjJ2vLQefpstGVjNARrtCpsJQ4/mcgeRLj0IeQE+JVC/sLR0DSnpYSFpZn9mN3k5blHRES9lx6EwSOOj3J/d7vPf0JKICWorPxeHebCIvfQefq8zFwLkxPMnYAgzZXYnSdxUkq0a8CrzigZDodERJAFj+/efPr06Q9ICaQE6DZtSsXKzrx1YbNzJ6icgCCkuy4zT+KUlMxaR17FOnCv90pERKPRCLLg4d0bSAmkBMyomlQrja1lpER/XwfrxMAv1K9bjs6TOCUls+Lt3bqrM4/RaERERIO3AYTB4+A0SAmkBHgAWyc2OhQIgJdcqDXH8kmckhJ9WNoq14FZlYSIsHnjIf/WW5ASSAnwGu19HTwgwSowOm5nNMthdU5lGXmYJ0WrqpJgyHU1GSWQEkgJWMFGkP4eDwBeochlR+7d6Oc+7M5+GIWlrWrzRlslmUwmkAUPyedUYtuPkBJICVhRSwdXicGqN3Dq1y3XKjB214DntZq82LjBkOtKMkr+YpuPkBJICVhxyBsflUJOVk0iXJoiXJpigkzJxAlhyBbMmtNYZhV4WSmZFZY2byjX7VwS9nrDkKun8NHM9A4ZpARSAnyyihyPKd+dqJqIqTzFBJnq161vqlrbZum2fFQKxWMKHSWziMeHlCy9CryslCy6SuzlkOtgMHwnJa89DLmuYh0YUgIpAT67dhzh0ocxQaZl803EVJ7S4ulf+nmW+nXrW6lY2WH3e/ioFErEf1VT0EbaLClZJAVWyGXPHQlLW9WQ62QyeSclL88Ycl3FOjCkBFICfNjSUdXaNkuY5aNSiI9KJPASJeInU46SWUod56cYCYWYyu/rxcRo8LZaaWwpcnmPXUGOCfJ3t9s+qNSsDjaUen5WdfT9WjmcN28N2Osh1/5r/52QjMdjHOjzkMt/rkl7ewxSAikBPt/WYTd8qpXGFqNUrOwocnmPIfBSiN3w0cpMhEsfiqnCvtXQt1ltH6dmX2KCTFxYJIGXKJk4gaR4LCVOtm7MHPwzG5a2iiHX0Wj8TkqGw+FMIcGsifMUTy9JezgVUgIpAWssMw+dp8/LptNq2z7aCk4ifkLHRznbbZ9E/IS4sDglwqUpHlOWep/AnJQ42bqZNVdy/+PB8hqw10muvZf3A67zhlzH4zEqJS5v3kBKICUA2BaVaqWxlc+pu6ztI/BSyGrbJ5M+pZggk8BLJKYKpBefZOKEkOfivJQ43brRz4E8PXZnioWZBNmHzuNKBlyJiHq915kZJkb/DThziA9SAikBwFHa7c4XbdsnGskcmm37pI7zFOHSlExkD7RtJK30xASZjpJZVFEcaLO49b6ZTNSvW4aVkkVrwHaHZp1YA2aveUmvkBJnad/ev/s7DymBlADg6tDuorZPJn1KR8ksRSOZQ3aheV5lhr2faCRzmIijimJ3U8btzZ5Zg6pmwtq8micZvA0+CMloNJ6b9AqRcJaraoPyOXUXUgIpAcAXbR8uLHJiqrDPIqatDOOWipUd9j5YFcXuwGxaLBAflQyJCfJ06wmr0+bmVWaJhRkh8mqeRL8GTEQ0GAzntnggEu4OuUJKICUArEVFhq01a9tGZmdbxFSeuLDIqWptWzsgzKhft75VK40tbWtKK0Ko1ryvcuSy54ZiYXa41spqsVNrwNPLwP23mS0eoyoKWI7jo9zf2iFXSAmkBIC1nG3RBsQtWjvOpE8pEVcO7LSm8jl1N5nIHjARwmrz7EHVRWvAXuaTjMdjQynRz4xoqySzVoWBc0OukBJICQAbMdeSz6m7XFjkIlz6kK0d69o3fy0KmjMz5KvdGtrkmRX9w8fsNWIrWSdOV0mM2jO4h+NukqtRhhKkBFICwMZtCGlj9tnasZkEXDPUr1vf2EBuIn6ykS0cO2vAUqY4M9vEiyqJvj3zphuExeaNs5yfXb1LcoWUQEoA2Hj0a8fRSOZw1gaQnSqNmCrsR7j0YSJ+sjEDsvp5EjNhaVKmSIpcXmmVZKCrhOgHYSESzqLI5T2jAXdICaQEAPB7M4gNszpdnWFycpTMTrd6kon1FBX9oGrt6sZ2hcWrKgkRUf+1P62G9PtvC1eFwXLw0UzI6O8LpARSAgDwgGqlsaVdgWabPDFBNhyQZRkuQRISo0HVRWFpjFbzztWH4GtvdpWEiKj30qPRaGQoLwPMkzg+T6IPTYOUQEoAACuYaWm3O1+0LZ5SsbLD5k/0lRMuLFI8pgQqLdbOGrAXrRuWyjpPSljFxEz0PHB+ngRSAikBAPhkS0iRy3vRSOZQKyYsP+Uomf07CFKir3aYTY91u3WzqEoyGo2m67/6KslkMoFIuJBPopVzSAmkBADgQ0rFyo5WTFiOQ6lY2Ukd5/eDNE/Svr23LTNezpKwJNd5/w0i4RyPP7uG+SSQEkgJAMCHsG0grZR8+vTpj6Nk9m8/D8aWipe6En3Vdq6JVxs32mrIrNdrrw+ZcJB/6y2aN0wOKYGUAAB8hpgq7McE+btWSh46T5+ZrPj17o3VNWAvAtMWVUkWyQpEwlnyOfXDvRtICaQEABAAMdGXuX9dXPbnrR12IdhKWJrbgWlvBpeArbywdePOKnC3+/wnpARSAgAIWLCbfkPhofP0OSbI3/0oJeyh8/TYNb0G7Patm3ltGTOv3ksPIuEg7dv7mavAkBJICQAgoBUUv82WaOdJ6tct2+mvTjJveNXMi2WWAOconl7SosRkSAmkBAAQsBA2v4Wq1a9blteAjdJfnYJljizzwoCr8yTiysGsVWBICaQEABDQOHy/tXDYXIjZsDS3s0kWBaUteo3HiJV3o3Uj8FJo0dc3pARSAgAIGHzUP1s42jTWUvFy5QOui4LSzLz6r6iSrKJ1AymBlAAAAggXFjm/SMn5WZWe//NC9z8ebGea+GUFGFWS1bZuICWQEgAApMSReRIra8BuDbgOllwBRpVkta0bSAmkBAAAKVmKh86jpbA0txJcnRhuRZVkta0bSAmkBAAAKbENE4za1c3KqyTLDreiSrL61g2kBFICAAjg9o1fBl3ZBo3ZsDTtUKyj9236b0sLCSLl3bt1sygwDVICKQEABDinJCbIvmjd3DRuLa0Ba+/j+Cm5lYjoDZHybt262dUnE0NKICUAgDVKdPVLeNpD59F0WJoil10JS3OibYNZEnd4/Nkl/f0mSAmkBACwZvMkfoiZz2XPqX17v9IqSf91+UwSzJK4x+U/16TI5T1ICaQEALCmR/oE3h/zJJXLOp2fVVdaJXGibYMqyXweOo9LDbg2m3dfISWQEgAAWjeu55OsskriRNvGjSrJMg9xPwqJXZm0OuAKKYGUAAACRLf7/KdfWjcsyXVVVRIntm3cqJK0b+9dOzK4ClrNO88GXCElkBIAQIAoFSs7ftm6yWXPTa8Bay8IO8HLc8+Rto0bVRKnf6+r5OmxaztT5v7HT8sDrpASSAkAIGADrmmxQH66DmxGXpyuHIxGY19WSW4at2slJbWrG9t/dudnV5TPqbuQEkgJAGANUdXadkyQvwdJSNxIb31z4LaNW1USNwRslVQu654kuEJKICUAgIAh8FLITJVETOXJLzMnTl8C7vVeHRMSp6sk9evW9FryOsBC8ez83Ktqw9aAK6QEUgIACAD5nLo7r0qSSZ9SMnFCES5NXFikZOLEF1LSvr139EE5Ho8dk5Je79XR2QtFLrt202cVlIqXtqs+dtaAISWQEgBAQO7cRLj0oVH1Q0zlKSbI37mwyClyea/ZvPuqyOW91HHeNzdxnGI4HDomJKPRyPHZCylTXJvWTfv23vafn901YEgJpAQAEACSieyBXjKOklmKRjKHAi+F9OfgBV4Krbp94/QKsFOprW5USR46j6TI5bVq3VyoNdurwJn06V/VSmMLUgIpAQCsYdsmET85kDJFSosFiscU4sIil0xkZ5bHubDI+SFUzY/rv25USS7UmisDvasMS7N7ybl50yaBl0LLft1DSiAlAACfxskfH+WIj0ohLixypWJl56Hz9Hleq4ePrjaCvpC/cHX9dzKZLJXk6nSVhFWG1mnjxm7rxm5YGqQEUgIA8PkcCRcWOVYVMVsOr1+3vsVjyruZE6/nS+5/PDj2gBwYrP/2Xnq2c0qcrpKUipfTG0DrEpamyGVbrZtlwtIgJZASAIDP50jyOXXXas6Dqta2k4kTyqRPWavH000cJ+/bGK3/slwRu6+X556jw6BuiNiq14DtVn3yOXVXP98EKYGUAAA2GEUu7zEZ4cIieXm4z+ngMP0cCRMSu1klb28DV6okTmexrJJc9txW66Z9e+9YlQRSAikBAKxRwNrvKgt5fSPHyWqBfv1Xm7yqTXQ128aZTCaOVxTcSqxd5eE9KVO01bpxYuMGUgIpAQCs6TxK0sMKidNtG/3134GuwjEajWgymVCv9zozcv7XMOzYtSpJLnvu2vXjVYal2WndOLVxAymBlAAA1pDUcX7fy5wSJ7dtei/v138Hg6FhqmvvpTetqIzHY+r33+i1138nIW7GybPf+6oHXJ8eu45IEZuPsdO6cbpKAimBlAAA1oRC/mJXTOX3vQxJc7Jto61uGAmJflBVW0VhFZbhcPiu2uLk0T22ncJ+/w+dx5VKiVN5MGw+xmrrxo0qCaQEUgIAWAPq161vycSvoLUghqRp13+Hw6Gt68FsdoTJjVtx8n4YcK1c1h25LcSqJHZaN8dHub+drpJASiAlAIA1wOvQNCdj1bUbNaPR2Pb76PVeqffSczUoza1jg1aHUp2SIlYlsdq6WfYSMKQEUgIAWONV4LRY+Cvo6792hcSo4mKn2mImTp79/oMYcDYva8XK+3v82V36EjCkBFICAFjTOHov2zZOz5Gw9V8nhIQNwroZlLbqNeBS8dIxKdJuEVn5eednV6TI5T23vqYhJZASAEBAOT7K/e1l28bJBzIbSJ1MJtONmmVgGzhuBaWtukpSuaw79mdgd4vo/sdP4qOZ0LwbTJASSAkAYAOpVhpbXkqJ3UNt89Z/nRKS5/+80GAwdDwoTfvwXmWVhFVrnJAi/RaRlcqXIpf3nIqTh5RASgAAa3Ujx7u2TSF/4egcyWg0dlRI2E2c1557K8CrqpI8PXapkL9wbOPJ7nyMWyvAkBJICQBgDaokqWNvMkmcTi5lw6hObsf0X/uOrwCfn1VdW4G207Zx4s9BPx9jpXWTiCsH9evWN0gJpAQAAFZWJXFysJXNfTgZasbi552surBbMG6JmR2JcCLOn1VcrP7Znp9dkZgq7HvxtQ0pgZQAADBLYogTq6f69V+nheTluffhRo6TbRun7/us6s4Oq7hYbd14MdwKKYGUAAACSjymfA/aoT1WzXBaSFjrxs22zapmSbQJssve2dG3bay8Ty+GWyElkBIAAHJJPNm0Yeu/RvdsnGoJuSECq9y40SfILnNn5+mxO624WG3duJncCimBlAAA1iC91e0rwE7fdem99FwTEie5//HwoW2zqiqJNhtlWUHUbttY+X09/uwSH82E2u3OF0gJwDdgAMAHBN7dGzdOr/6yKonfhUS7drvqKol+yHaZKslN49bwz9lM6yafU3fzOXXX669xSAmkBAAQkEvAR8ns30ESEidbK15VJlZZJdEP2S5TJTGq/Jht3fxbb3mSSQIpgZQAANC6cT2LhG3FBEFIjOZI5l0CdnJFetGGjP5jMFs1mVX5MSNbq2rbQEogJQCAAMFH3WndKHJ5qRZBkJnV3pg1V3PTuHVtPfj+x8Pcj+H+x4PpdpJR5cds60aRy3uraNtASiAlAICA0G53viTizm/dOH31N0gYrcnOa28wgZlVQXE62Ez767BWjBl51FdbrLRuLv+59nzbBlICKQEABIxSsbKTOs47KiS57PnGCsm8eQujSoi2ouJF20ZbJWGtmEL+YmHlZFblx0zrpn17T3w0E+p2n/+ElEBKICUAgJmIqcI+hMR9ITGardE+6LWycP/jwZHPoVHFRisbrBWjvb1Tv259+FgXCcmiQLzjo9zf1Upja9Vf65ASSAkAwOdEI5lDJ3NIVnHHxe9CYrQCrH/Qs4f6/Y+HD5ULp4LNtNUMbcbIQ+eRnh670x9jH0vt6obat/dzf1+L1ouLp5f/o8jlPT98rUNKICUAAB/z0Hn6HBPk735Mag0SRjdt5g2WGlUe2rf3U7Fx4mqwUbAZE6P6detDZYvNnbD5kvOzKily2ZSQzJKo5k17Zeu/kBJICQAggPkkifjJ0u0ap4/rBa1CYhS1PmsAdFYrRFtpWbbaZPRrsCqJ/r/lsufvxOP8rDpz5XcWRhJ1XWt6emwPUgIpAQBs+JBr7epmY9s1Zlo2+lmLWUKiFYPzs+rSt22MPqba1Y2pj9cOD53HafumfXtPuew58VEp5Ic5EkgJpAQAEKDQNDGVt9Wq2dT8Ea1gLHrAa2c4zArBslUnoxwR1pJxQ0gK+Qtq397TTeN2+mvHY8p3v8yRQEogJQCANb13UypebryMmN1G0eaBmBWSZePnZ+WIVC7rllsyVqpl2t/bUTK78jwSSAmkBAAQQLiwyFl5+Gy6jJgJENOnm1ppmZg5ZmdVlBS5PDeF1YkVcPa/xVSeYoL8fdV5JJASSAkAIIBEuPShmWRWPw2ytm/vXUs+XTSrYbbakMue09Nj1/IMh93LwW7Nilghkz6lCJc+bDbvvvr16x1SAikBAPiUaqWxFY8p3xcJySoEQC8DN43b6Yoqe+DbfV92fj9mszqM1nuttMbsriO71ZqxIiTRSObQb4OtkBJICQAgAHS7z38KvBRKiwVTMxGrqIbMmoOw8zE9PXapdnVjK9xt1qXfeW0uO5ULu5/r87PqSoVEyhQpJsjfS8XKjt+/7iElkBIAgA8D0wReCh0ls3MfNOdn1WmrxAgnB1711RAnZy7YIKZRzLtT7Rr9JopVIbG7BmwUkOY18ZjyXUwV9oPwtQ8pgZQAAHxEPqfucmGRWyQkTq2KloqXhlyoNWo17yxthViNXr9p3E6HMK1eLLZaHWG/hpk1YSsR7U5sALmJnzdtICWQEgCAT2m3O1+SieyBwEuhTPp05Q8zOw98s1LBwrvsZH8Y/Vwr2S12hMTOVtP9jwdfCInASyG/btpASiAlAACfDrR6VR1xCzO3YNq394arr2Z+Lrv1sgrZsjrj4odNG7+v/kJKICUAAB/OjiQT2QM+KoXspLb6hUVbKfOEYtGRQDYA68bHnTrO06IIf6uH95wSknhMoUVDzvOEhAuLnJ9XfyElkBIAgM9u2nBhkUsmTgIrI4sqCU+P3bmDnvNkhsmIWxWH46MccWGR5h07tJre6tTqb0yQiQuLtqQkyEICKYGUAABW0KoReCkUE+Tvdv8l7CeMZkHMCEUhf0FPj91pgJlXMpI6zlOESxMXFokLizRvfsfKCrBTQpJMnBAXFikmyBsnJJASSAkAwONWTTSSOVzm6q+fMFr/rV+3FgoFOz7HNmHYBdvKZd1VGYkJ8neBl0L169Y3RS7PrZJYCUpzSkiOktmpLFkV1kz6NPBCAimBlAAAPNiqUeTy3jq0aowqHUbrvWai2tnAqyKXXR1g1coISzN96Dx9XlQlMbtJ5JSQpI7zlBZPSUwVLFdJWFprEMLRICWQEgCAD2TEb2u+y3487KHdvr239FC2u85rp+oQjWQOtTLCUOTy3jxBXDR8q8WJQ3pHyezf+Zy6+/sAo6UqyToJCaQEUgIAcJhm8+6rmCrsR7j0YSLuHxlJiwWWWzFtEUS4NNnZ+qld3cxc7131Gmw8phAXFjkxVdg3amW0250v844cml0BdqpCkoifHDChKBUrO1aqJGIqv1ZCAimBlAAAHEJVa9sCL4UiXPrQT22a46Mc8VEpJPBSKJ9Td9vtzpfft3UoGslYlqZc9twX0ena3188pnz/9XnPHqhqbXteNkcykT2YlwdjJijNCSHJpE8pJsjf69etb+xj48IiZ7ZKwoZa/X5gD1ICKQEArCAWnguLXCJ+8ns2oOCLhzVrX2gffKyaI/ASBS05Vkzl6fgoRzFBJj4qhbiwyClyec/sg7laaWzxUSk0T7gWVUmcEpJoJHOoreT8rpJ835QtG0gJpAQA4FK7plppbFUrjS1FLu/9mlfIHjBR4aNSiI9KFBNkSsRPiImLW/IipvIk8FIomcge6GWEfbxmH36rnnlJHecpmTghPvqrAiWmCvv5nLrbbN59feg8fbb6Z7Xo6vJN49Z1IRFT+f14TPmQtGq2SrLOQgIpgZQAADxYBX7oPH12W15Sx/lpm2bWjIGfhSQtFiiZOKF4TCE++ivHRZHLe6pa27YjIHoUubyXiJ8c2F0Bvv/xsPSQ7lEy+7fRtV6zVZLfgW9rKySQEkgJACCg8qIh9GvDJ3swr41RKlZ25j2UV9GGScRPSOD/+/Gram27ft365oSE6GUsGskc2g1Ka9/eL5WfwuZHVLW2bfTxmamSsON6Tn9uICWQEkgJAGBpedFiJtL+KJn9exUCkjrO01EyS4n4xzZMtdLYYoO3biLwUmheYN35WXWmkNw0bpeuAEUjmUOjVprZKkk8pnwP2rVfSAmkBAAAViYkRjMgbBC1VKzsVCuNrVX8K39R20bKFOmh82goJPXr1rKR8QdHyezf82RiXpUkkz4lgZdCRi0fSAmkBFICAAgUafH0r+Oj3N9uyQeb/+DCIifwUsjJGRCn7gwtatsYrQAvOiRo5nPEVrAXCeOsKgmrsChyeW+TvmYhJZASAMCaComYyu872XbRy4cb8x9O0e0+//mrypC3dOF42Q0btl1jZhh1VpUkdfxrw2adQtEgJZASAACEZO6sQ+o4P930EXiJopHMIRuoXXXbZVmSiezBohC7+nXrw4bNMgOtifjJgdnKxqwqye8rwWu9YQMpgZQAADaAbvf5z0RcOTg+yv2dOv7vhsvvase01cK2XVjwGBs4XZdBylKxsiPws0PSWFCaU/MjbFV31jCrmSoJ29DZlIFWSAmkBACwxhs5pWJlRy8cbMOFVTvWfZ3006dPf9SvW98WzZFoV4CfHru2b/hoB1GtiIS+SrKp8yOQEkgJAGDN0mTFVGFf4KXQrAyMTZOzX8f45h8ZZEFpywSiHSWzf8cE+budlWZtlYRVWfDnBymBlAAAAkm10tj6NTORPdjU2YNZg63HR7mFQnH/48F2u0ZM/UrOXbRZY6ZKwvJHvMhqgZRASiAlAADHZYQNoeJB9nGwdd71X22VxE67Ji0WKCbI38VUYX+ZNhgXFjl2LBHtGkgJpAQAEOhqAD4PHxFThX23bvpk0qeUiJ8cxAT5+7JVKe3cj9nLxpASSAkAAICA/EMqn1N33RKSo2T2bycF4te8i7WhWEgJpAQAAEAApCSfU3fNbNrYkZEIlz50evjUysowpARSAgAAICBSUipWdqKRzKGTbZpk4uQgwqUPNzFJFVICKQEAAEjJEkLiRIVEKyNYy4WUQEoAAABS4rmQpMXCdCUXMgIpgZQAAACkxPKWDR+VQssIyfFRjmKC/B0ZL5ASSAkAAEBKPF/7TYsFSiZODlg2CDJeICWQEgAAgJTYTmq1IySsKhIT5O8YXoWUQEoAAABSstQtG4GXQsnEieVZEZYJgqoIpARSAgAAkJKljw1yYZEzEx3/uz1D0UjmUEwV9pEHAimBlAAAAKTEEVS1tr3o2q+YylM8plA0kjlMJrIHqlrbRlIqpARSAgAAwPUNm0z6lI6SWRJ4KRTh0oeKXN6DiEBKICUAAAAcl5J2u/NF4KVQPKZ81w6qxmMKRbj0ocBLoXxO3cUaL6QEUgIAAMA1KWHXcwVeopggUzSSORR4KaTI5b36devbQ+fpMx7YkBJICQAAANekpN3ufFHk8h7blFHV2nazefcVLRlICaQEAACAp1LSbN59xaYMgJQAAAAAAEBKAAAAAAApAQAAAACAlAAAAAAAUgIAAAAAACkBAAAAAKQEAAAAAABSAgAAAABICQAAAAAApAQAAAAAkBIAAAAAAEgJAAAAACAlAAAAAACQEgAAAACsG///AFWVSthDLxuQAAAAAElFTkSuQmCC",
                        get rotateAdd(){
                            return Math.PI/2
                        },
                        dif:[-10,10]
                    },
                    fox1:{
                        src:"data:image/png;base64,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",
                        rotateAdd:-1.5707963267948966,
                        dif:[-10,6]
                    },
                    wolf1:{
                        src:"data:image/png;base64,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",
                        rotateAdd:Math.PI,
                        dif:[-10,17]
                    }
                }
                custom = {
                    cat:{
                        0: {
                            50:faces.cat1,
                            22:faces.cat1,
                            12:faces.cat1,
                            6:faces.cat2,
                        },
                        1:{
                            11:tails.cat1
                        }
                    },
                    fox:{
                        0: {
                            50:faces.fox1,
                            22:faces.fox1,
                            12:faces.fox1,
                            6:faces.fox1,
                        },
                        1:{
                            11:tails.fox1
                        }
                    },
                    wolf:{
                        0: {
                            50:faces.wolf1,
                            22:faces.wolf1,
                            12:faces.wolf1,
                            6:faces.wolf1,
                        },
                        1:{
                            11:tails.wolf1
                        }
                    }
                };
                let modes=Object.keys(custom)
                mode=modes[0]
                const tailRotateAdd={}
                const skinRotateAdd = {}; // store per ID
                let currentMode=mode
                function clearObj(obj) {
                    Object.keys(obj).forEach(k => delete obj[k]);
                }

                function renderSkin(index, ctxt, parentSkin, owner) {
                    let e = index
                    if (currentMode !== mode) {
                        // wipe all skins so we’ll reload fresh ones
                        clearObj(skinSprites);
                        clearObj(skinRotateAdd);
                        clearObj(skinPointers);
                        clearObj(accessSprites);
                        clearObj(accessPointers);

                        currentMode = mode;
                    }
                    tmpSkin = skinSprites[index];
                    if (!tmpSkin) {
                        let tmpImage = new Image();
                        let src="https://moomoo.io/img/hats/hat_" + index + ".png"
                        tmpImage.onload = function() {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        console.log(custom[mode],mode)
                        if(custom[mode]){
                            const customData = custom[mode][0][e];
                            if (customData) {
                                src = customData.src;
                                skinRotateAdd[e] = customData.rotateAdd || 0;
                            } else {
                                skinRotateAdd[e] = 0;
                            }
                        }
                        tmpImage.src = src;
                        skinSprites[index] = tmpImage;
                        tmpSkin = tmpImage;
                    }
                    let tmpObj = parentSkin||skinPointers[index];
                    if (!tmpObj) {
                        for (let i = 0; i < hats.length; ++i) {
                            if (hats[i].id == index) {
                                tmpObj = hats[i];
                                break;
                            }
                        }
                        skinPointers[index] = tmpObj;
                    }

                    if (tmpSkin.isLoaded){
                        const rotateOffset = skinRotateAdd[e] || 0;
                        //console.log(index,rotateOffset)
                        if(custom[mode][0][e]&&custom[mode][0][e].dif)ctxt.translate(...custom[mode][0][e].dif);
                        ctxt.rotate(rotateOffset);
                        ctxt.drawImage(tmpSkin, -tmpObj.scale/2, -tmpObj.scale/2, tmpObj.scale, tmpObj.scale)
                    }
                    if (!parentSkin && tmpObj.topSprite) {
                        ctxt.save();
                        ctxt.rotate(owner.skinRot+Math.PI);
                        renderSkin(index + "_top", ctxt, tmpObj, owner);
                        ctxt.restore();
                    }
                }

                // RENDER TAIL:
                let accessSprites = {};
                let accessPointers = {};
                function renderTail(index, ctxt, owner) {
                    // 1) load image (custom or default)
                    let img = accessSprites[index];
                    if (!img) {
                        img = new Image();
                        img.onload = function() {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        const customData = custom[mode][1][index];
                        if (customData) {
                            img.src = customData.src;
                            tailRotateAdd[index] = customData.rotateAdd || 0;
                        } else {
                            img.src = `https://moomoo.io/img/accessories/access_${index}.png`;
                            tailRotateAdd[index] = 0;
                        }
                        accessSprites[index] = img;
                    }

                    // 2) find the accessory metadata
                    let obj = accessPointers[index];
                    if (!obj) {
                        obj = accessories.find(a => a.id === index);
                        accessPointers[index] = obj;
                    }

                    // 3) draw if loaded
                    if (img.isLoaded) {
                        ctxt.save();
                        // position offset
                        const customData = custom[mode][1][index];
                        const baseX    = -(20 + (obj.xOff || 0));      // <- same as original: -20 - xOff
                        const baseY    = 0;

                        const dx = customData&&customData.dif?customData.dif[0]: 0;          // if dif exists, use it, else 0
                        const dy = customData&&customData.dif?customData.dif[1]: 0;          // if dif exists, use it, else 0

                        ctxt.translate(baseX + dx, baseY + dy);

                        let total=[(20 - (obj.xOff || 0))+(custom[mode][1][index]?custom[mode][1][index].dif[0]:0),custom[mode][1][index]?custom[mode][1][index].dif[1]:0]
                        ctxt.translate(...total);

                        // apply custom static rotation
                        const staticRot = custom[mode][1][index]?custom[mode][1][index].rotateAdd : 0;
                        if (staticRot) {
                            // debug log if you wanna verify it
                            //console.log("tail staticRot:", staticRot);
                            ctxt.rotate(staticRot);
                        }

                        // apply dynamic spin if defined
                        if (obj.spin) {
                            ctxt.rotate(owner.skinRot);
                        }

                        // finally draw
                        ctxt.drawImage(
                            img,
                            -obj.scale / 2,
                            -obj.scale / 2,
                            obj.scale,
                            obj.scale
                        );
                        ctxt.restore();
                    }
                }

                function renderTail2(index, ctxt, owner) {
                    tmpSkin = accessSprites[index];
                    if (!tmpSkin) {
                        let tmpImage = new Image();
                        tmpImage.onload = function() {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        tmpImage.src = "https://moomoo.io/img/accessories/access_" + index + ".png";
                        accessSprites[index] = tmpImage;
                        tmpSkin = tmpImage;
                    }
                    let tmpObj = accessPointers[index];
                    if (!tmpObj) {
                        for (let i = 0; i < accessories.length; ++i) {
                            if (accessories[i].id == index) {
                                tmpObj = accessories[i];
                                break;
                            }
                        }
                        accessPointers[index] = tmpObj;
                    }
                    if (tmpSkin.isLoaded) {
                        ctxt.save();
                        ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
                        if (tmpObj.spin)
                            ctxt.rotate(owner.skinRot);
                        ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
                        ctxt.restore();
                    }
                }

                // RENDER TOOL:
                let toolSprites = {};
                function renderTool(obj, variant, x, y, ctxt) {
                    let tmpSrc = obj.src + (variant||"");
                    let tmpSprite = toolSprites[tmpSrc];
                    if (!tmpSprite) {
                        tmpSprite = new Image();
                        tmpSprite.onload = function() {
                            this.isLoaded = true;
                        }
                        tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
                        toolSprites[tmpSrc] = tmpSprite;
                    }
                    if (tmpSprite.isLoaded)
                        ctxt.drawImage(tmpSprite, x + obj.xOff - (obj.length / 2), y + obj.yOff - (obj.width / 2), obj.length, obj.width);
                }

                // RENDER PROJECTILES:
                function renderProjectiles(layer, xOffset, yOffset) {
                    for(let i = 0; i < projectiles.length; i++) {
                        tmpObj = projectiles[i];
                        if (tmpObj.active && tmpObj.layer == layer && tmpObj.inWindow) {
                            tmpObj.update(delta);
                            if (tmpObj.active && isOnScreen(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.scale)) {
                                mainContext.save();
                                mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                mainContext.rotate(tmpObj.dir);
                                renderProjectile(0, 0, tmpObj, mainContext, 1);
                                mainContext.restore();
                            }
                        }
                    };
                }

                // RENDER PROJECTILE:
                let projectileSprites = {};
                function renderProjectile(x, y, obj, ctxt, debug) {
                    if (obj.src) {
                        let tmpSrc = items.projectiles[obj.indx].src;
                        let tmpSprite = projectileSprites[tmpSrc];
                        if (!tmpSprite) {
                            tmpSprite = new Image();
                            tmpSprite.onload = function() {
                                this.isLoaded = true;
                            }
                            tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
                            projectileSprites[tmpSrc] = tmpSprite;
                        }
                        if (tmpSprite.isLoaded)
                            ctxt.drawImage(tmpSprite, x - (obj.scale / 2), y - (obj.scale / 2), obj.scale, obj.scale);
                    } else if (obj.indx == 1) {
                        ctxt.fillStyle = "#939393";
                        renderCircle(x, y, obj.scale, ctxt);
                    }
                }

                // RENDER AI:
                let aiSprites = {};
                function renderAI(obj, ctxt) {
                    let tmpIndx = obj.index;
                    let tmpSprite = aiSprites[tmpIndx];
                    if (!tmpSprite) {
                        let tmpImg = new Image();
                        tmpImg.onload = function() {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        tmpImg.src = "https://moomoo.io/img/animals/" + obj.src + ".png";
                        tmpSprite = tmpImg;
                        aiSprites[tmpIndx] = tmpSprite;
                    }
                    if (tmpSprite.isLoaded) {
                        let tmpScale = obj.scale * 1.2 * (obj.spriteMlt || 1);
                        ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, tmpScale * 2, tmpScale * 2);
                    }
                }

                // RENDER WATER BODIES:
                function renderWaterBodies(xOffset, yOffset, ctxt, padding) {

                    // MIDDLE RIVER:
                    let tmpW = config.riverWidth + padding;
                    let tmpY = (config.mapScale / 2) - yOffset - (tmpW / 2);
                    if (tmpY < maxScreenHeight && tmpY + tmpW > 0) {
                        ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
                    }
                }
                /*   function crate() {
                var d = document.createElement('div');
                d.style.position = 'fixed';
                d.style.top = '35%';
                d.style.left = '0.5%';
                d.style.background = 'rgba(0,0,0,0.3)';
                d.style.zIndex = '999999';
                d.style.boxShadow = '2px 2px 4px 2px rgba(0,0,0,0.3)';
                d.style.width = '298px';
                d.style.height = '220px';
                d.style.overflow = 'hidden';
                d.style.borderWidth = '4px';
                d.style.backdropFilter = 'blur(2px)';

                var k = document.createElement('canvas');
                d.appendChild(k);

                var key = document.createElement('div');
                key.style.marginTop = '10px';
                key.style.textAlign = 'center';
                key.style.fontSize = '12px';
                key.style.color = '#fff';
                key.innerHTML = `
        <div><span style="display: inline-block; width: 12px; height: 12px; background-color: #0091ff;"></span> <strong>Packets</strong>: <span id="packetsStat">0</span></div>
        <div><span style="display: inline-block; width: 12px; height: 12px; background-color: #ff5500;"></span> <strong>Ping</strong>: <span id="pingStat">0</span></div>
        <div><span style="display: inline-block; width: 12px; height: 12px; background-color: #00ff55;"></span> <strong>FPS</strong>: <span id="fpsStat">0</span></div>
    `;
                d.appendChild(key);

                document.body.appendChild(d);

                var ctx = k.getContext('2d');

                var show = {
                    labels: [],
                    datasets: [
                        {
                            label: 'Packets',
                            data: [],
                            fill: false,
                            borderColor: '#0091ff',
                            pointRadius: 0,
                            borderWidth: 2,
                            tension: 0.4
                        },
                        {
                            label: 'Ping',
                            data: [],
                            fill: false,
                            borderColor: '#ff5500',
                            pointRadius: 0,
                            borderWidth: 2,
                            tension: 0.4
                        },
                        {
                            label: 'FPS',
                            data: [],
                            fill: false,
                            borderColor: '#00ff55',
                            pointRadius: 0,
                            borderWidth: 2,
                            tension: 0.4
                        }
                    ]
                };

                var config = {
                    type: 'line',
                    data: show,
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false },
                            title: { display: false }
                        },
                        elements: {
                            line: {
                                borderWidth: 2,
                                tension: 0.4,
                                borderDash: []
                            }
                        },
                        scales: {
                            x: {
                                display: false,
                                grid: { display: false }
                            },
                            y: {
                                display: true,
                                grid: {
                                    display: true,
                                    color: 'rgba(255, 255, 255, 0.1)',
                                    lineWidth: 1
                                },
                                ticks: {
                                    beginAtZero: false,
                                    color: '#fff',
                                    callback: function(value) {
                                        return value.toFixed(0);
                                    }
                                }
                            }
                        },
                        animation: { duration: 0 }
                    }
                };

                var f = new Chart(ctx, config);

                var lastUpdateTime = 0;
                const updateInterval = 16;

                function smoothUpdateData(newPacket, newPing, newFps) {
                    let smoothedPacket = newPacket;
                    let smoothedPing = newPing;
                    let smoothedFps = newFps;

                    if (show.datasets[0].data.length > 0) {
                        let lastPacket = show.datasets[0].data[show.datasets[0].data.length - 1];
                        let lastPing = show.datasets[1].data[show.datasets[1].data.length - 1];
                        let lastFps = show.datasets[2].data[show.datasets[2].data.length - 1];

                        smoothedPacket = lastPacket + (newPacket - lastPacket) * 0.2;
                        smoothedPing = lastPing + (newPing - lastPing) * 0.2;
                        smoothedFps = lastFps + (newFps - lastFps) * 0.2;
                    }

                    return { smoothedPacket, smoothedPing, smoothedFps };
                }

                function updateChart() {
                    var currentTime = Date.now();

                    if (currentTime - lastUpdateTime >= updateInterval) {
                        let { smoothedPacket, smoothedPing, smoothedFps } = smoothUpdateData(
                            secPacket, unsafeWindow.pingTime || 0, UTILS.round(fpsTimer.ltime, 10)
                        );

                        show.datasets[0].data.push(smoothedPacket);
                        show.datasets[1].data.push(smoothedPing);
                        show.datasets[2].data.push(smoothedFps);

                        if (show.datasets[0].data.length >= 60) {
                            show.datasets[0].data.shift();
                            show.datasets[1].data.shift();
                            show.datasets[2].data.shift();
                            show.labels.shift();
                        }

                        show.labels.push('');
                        document.getElementById('packetsStat').innerText = secPacket;
                        document.getElementById('pingStat').innerText = unsafeWindow.pingTime || 0;
                        document.getElementById('fpsStat').innerText = UTILS.round(fpsTimer.ltime, 10);

                        f.update();
                        lastUpdateTime = currentTime;
                    }
                }

                function smoothUpdate() {
                    updateChart();
                    requestAnimationFrame(smoothUpdate);
                }

                smoothUpdate();
            }

            function trashi(url, callback) {
                var script = document.createElement("script");
                script.type = "text/javascript";

                if (script.readyState) {
                    script.onreadystatechange = function () {
                        if (script.readyState === "loaded" || script.readyState === "complete") {
                            script.onreadystatechange = null;
                            callback();
                        }
                    };
                } else {
                    script.onload = function () {
                        callback();
                    };
                }

                script.src = url;
                document.getElementsByTagName("head")[0].appendChild(script);
            }

            trashi("https://cdn.jsdelivr.net/npm/chart.js", function () {
                crate();
            });*/

                //GRAPH
                // RENDER GAME OBJECTS:
                let gameObjectSprites = {};
                function getResSprite(obj) {
                    let biomeID = (obj.y>=config.mapScale-config.snowBiomeTop)?2:((obj.y<=config.snowBiomeTop)?1:0);
                    let tmpIndex = (obj.type + "_" + obj.scale + "_" + biomeID);
                    let tmpSprite = gameObjectSprites[tmpIndex];
                    if (!tmpSprite) {
                        let blurScale = 15;
                        let tmpCanvas = document.createElement("canvas");
                        tmpCanvas.width = tmpCanvas.height = (obj.scale * 2.1) + outlineWidth;
                        let tmpContext = tmpCanvas.getContext('2d');
                        tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                        tmpContext.rotate(UTILS.randFloat(0, Math.PI));
                        tmpContext.strokeStyle = outlineColor;
                        tmpContext.lineWidth = outlineWidth;
                        if (isNight) {
                            tmpContext.shadowBlur = blurScale;
                            tmpContext.shadowColor = `rgba(0, 0, 0, ${obj.alpha})`;
                        }
                        if (obj.type == 0) {
                            let tmpScale;
                            let tmpCount = UTILS.randInt(5, 7);
                            tmpContext.globalAlpha = isNight ? 0.6 : 0.8;
                            for (let i = 0; i < 2; ++i) {
                                tmpScale = tmpObj.scale * (!i?1:0.5);
                                renderStar(tmpContext, tmpCount, tmpScale, tmpScale * 0.7);
                                tmpContext.fillStyle = !biomeID?(!i?"#9ebf57":"#b4db62"):(!i?"#e3f1f4":"#fff");
                                tmpContext.fill();
                                if (!i) {
                                    tmpContext.stroke();
                                    tmpContext.shadowBlur = null;
                                    tmpContext.shadowColor = null;
                                    tmpContext.globalAlpha = 1;
                                }
                            }
                        } else if (obj.type == 1) {
                            if (biomeID == 2) {
                                tmpContext.fillStyle = "#606060";
                                renderStar(tmpContext, 6, obj.scale * 0.3, obj.scale * 0.71);
                                tmpContext.fill();
                                tmpContext.stroke();

                                //tmpContext.shadowBlur = null;
                                //tmpContext.shadowColor = null;

                                tmpContext.fillStyle = "#89a54c";
                                renderCircle(0, 0, obj.scale * 0.55, tmpContext);
                                tmpContext.fillStyle = "#a5c65b";
                                renderCircle(0, 0, obj.scale * 0.3, tmpContext, true);
                            } else {
                                renderBlob(tmpContext, 6, tmpObj.scale, tmpObj.scale * 0.7);
                                tmpContext.fillStyle = biomeID?"#e3f1f4":"#89a54c";
                                tmpContext.fill();
                                tmpContext.stroke();

                                //tmpContext.shadowBlur = null;
                                //tmpContext.shadowColor = null;

                                tmpContext.fillStyle = biomeID?"#6a64af":"#c15555";
                                let tmpRange;
                                let berries = 4;
                                let rotVal = (Math.PI * 2) / berries;
                                for (let i = 0; i < berries; ++i) {
                                    tmpRange = UTILS.randInt(tmpObj.scale/3.5, tmpObj.scale/2.3);
                                    renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                                 UTILS.randInt(10, 12), tmpContext);
                                }
                            }
                        } else if (obj.type == 2 || obj.type == 3) {
                            tmpContext.fillStyle = (obj.type==2)?(biomeID==2?"#938d77":"#939393"):"#e0c655";
                            renderStar(tmpContext, 3, obj.scale, obj.scale);
                            tmpContext.fill();
                            tmpContext.stroke();

                            tmpContext.shadowBlur = null;
                            tmpContext.shadowColor = null;

                            tmpContext.fillStyle = (obj.type==2)?(biomeID==2?"#b2ab90":"#bcbcbc"):"#ebdca3";
                            renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                            tmpContext.fill();
                        }
                        tmpSprite = tmpCanvas;
                        gameObjectSprites[tmpIndex] = tmpSprite;
                    }
                    return tmpSprite;
                }

                // GET ITEM SPRITE:
                let itemSprites = [];
                function getItemSprite(obj, asIcon) {
                    let tmpSprite = itemSprites[obj.id];
                    if (!tmpSprite || asIcon) {
                        let blurScale = !asIcon && isNight ? 15 : 0;
                        let tmpCanvas = document.createElement("canvas");
                        let reScale = ((!asIcon && obj.name == "windmill") ? items.list[4].scale : obj.scale);
                        tmpCanvas.width = tmpCanvas.height = (reScale * 2.5) + outlineWidth + (items.list[obj.id].spritePadding || 0) + blurScale;
                        if (config.useWebGl) {
                            let gl = tmpCanvas.getContext("webgl");
                            gl.clearColor(0, 0, 0, 0);
                            gl.clear(gl.COLOR_BUFFER_BIT);

                            let buffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

                            function render(vs, fs, vertice, type) {

                                let vShader = gl.createShader(gl.VERTEX_SHADER);
                                gl.shaderSource(vShader, vs);
                                gl.compileShader(vShader);
                                gl.getShaderParameter(vShader, gl.COMPILE_STATUS);

                                let fShader = gl.createShader(gl.FRAGMENT_SHADER);
                                gl.shaderSource(fShader, fs);
                                gl.compileShader(fShader);
                                gl.getShaderParameter(fShader, gl.COMPILE_STATUS);

                                let program = gl.createProgram();
                                gl.attachShader(program, vShader);
                                gl.attachShader(program, fShader);
                                gl.linkProgram(program);
                                gl.getProgramParameter(program, gl.LINK_STATUS);
                                gl.useProgram(program);

                                let vertex = gl.getAttribLocation(program, "vertex");
                                gl.enableVertexAttribArray(vertex);
                                gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, 0, 0);

                                let vertices = vertice.length / 2;
                                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertice), gl.DYNAMIC_DRAW);
                                gl.drawArrays(type, 0, vertices);
                            }

                            function hexToRgb(hex) {
                                return hex.slice(1).match(/.{1,2}/g).map(g => parseInt(g, 16));
                            }

                            function getRgb(r, g, b) {
                                return [r / 255, g / 255, b / 255].join(", ");
                            }

                            let max = 100;
                            for (let i = 0; i < max; i++) {
                                let radian = (Math.PI * (i / (max / 2)));
                                render(`
                            precision mediump float;
                            attribute vec2 vertex;
                            void main(void) {
                                gl_Position = vec4(vertex, 0, 1);
                            }
                            `,`
                            precision mediump float;
                            void main(void) {
                                gl_FragColor = vec4(${getRgb(...hexToRgb("#fff"))}, 1);
                            }
                            `, [
                                    0 + (Math.cos(radian) * 0.5), 0 + (Math.sin(radian) * 0.5),
                                    0, 0,
                                ], gl.LINE_LOOP);
                            }
                        } else {
                            let tmpContext = tmpCanvas.getContext("2d");
                            tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                            tmpContext.rotate(asIcon ? 0 : (Math.PI / 2));
                            tmpContext.strokeStyle = outlineColor;
                            tmpContext.lineWidth = outlineWidth * (asIcon ? (tmpCanvas.width / 81) : 1);
                            if (isNight && !asIcon) {
                                tmpContext.shadowBlur = blurScale;
                                tmpContext.shadowColor = `rgba(0, 0, 0, ${Math.min(obj.name == "pit trap" ? 0.6 : 0.3, obj.alpha)})`;
                            }
                            if (obj.name == "apple") {
                                tmpContext.fillStyle = "#c15555";
                                renderCircle(0, 0, obj.scale, tmpContext);
                                tmpContext.fillStyle = "#89a54c";
                                let leafDir = -(Math.PI / 2);
                                renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir),
                                           25, leafDir + Math.PI / 2, tmpContext);
                            } else if (obj.name == "cookie") {
                                tmpContext.fillStyle = "#cca861";
                                renderCircle(0, 0, obj.scale, tmpContext);
                                tmpContext.fillStyle = "#937c4b";
                                let chips = 4;
                                let rotVal = (Math.PI * 2) / chips;
                                let tmpRange;
                                for (let i = 0; i < chips; ++i) {
                                    tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                                    renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                                 UTILS.randInt(4, 5), tmpContext, true);
                                }
                            } else if (obj.name == "cheese") {
                                tmpContext.fillStyle = "#f4f3ac";
                                renderCircle(0, 0, obj.scale, tmpContext);
                                tmpContext.fillStyle = "#c3c28b";
                                let chips = 4;
                                let rotVal = (Math.PI * 2) / chips;
                                let tmpRange;
                                for (let i = 0; i < chips; ++i) {
                                    tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                                    renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                                 UTILS.randInt(4, 5), tmpContext, true);
                                }
                            } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                                tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                                    "#a5974c" : "#939393";
                                let sides = (obj.name == "castle wall") ? 4 : 3;
                                renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                                    "#c9b758" : "#bcbcbc";
                                renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                                tmpContext.fill();
                            } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                                       obj.name == "spinning spikes") {
                                tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                                let tmpScale = (obj.scale * 0.6);
                                renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = "#a5974c";
                                renderCircle(0, 0, tmpScale, tmpContext);
                                tmpContext.fillStyle = "#c9b758";
                                renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                            } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                                tmpContext.fillStyle = "#a5974c";
                                renderCircle(0, 0, reScale, tmpContext);
                                tmpContext.fillStyle = "#c9b758";
                                renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
                                tmpContext.fillStyle = "#a5974c";
                                renderCircle(0, 0, reScale * 0.5, tmpContext);
                            } else if (obj.name == "mine") {
                                tmpContext.fillStyle = "#939393";
                                renderStar(tmpContext, 3, obj.scale, obj.scale);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = "#bcbcbc";
                                renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                                tmpContext.fill();
                            } else if (obj.name == "sapling") {
                                for (let i = 0; i < 2; ++i) {
                                    let tmpScale = obj.scale * (!i ? 1 : 0.5);
                                    renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                                    tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                                    tmpContext.fill();
                                    if (!i) tmpContext.stroke();
                                }
                            } else if (obj.name == "pit trap") {
                                tmpContext.fillStyle = "#a5974c";
                                renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = outlineColor;
                                renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                                tmpContext.fill();
                            } else if (obj.name == "boost pad") {
                                tmpContext.fillStyle = "#7e7f82";
                                renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = "#dbd97d";
                                renderTriangle(obj.scale * 1, tmpContext);
                            } else if (obj.name == "turret") {
                                tmpContext.fillStyle = "#a5974c";
                                renderCircle(0, 0, obj.scale, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = "#939393";
                                let tmpLen = 50;
                                renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                                renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                            } else if (obj.name == "platform") {
                                tmpContext.fillStyle = "#cebd5f";
                                let tmpCount = 4;
                                let tmpS = obj.scale * 2;
                                let tmpW = tmpS / tmpCount;
                                let tmpX = -(obj.scale / 2);
                                for (let i = 0; i < tmpCount; ++i) {
                                    renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                                    tmpContext.fill();
                                    tmpContext.stroke();
                                    tmpX += tmpS / tmpCount;
                                }
                            } else if (obj.name == "healing pad") {
                                tmpContext.fillStyle = "#7e7f82";
                                renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = "#db6e6e";
                                renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                            } else if (obj.name == "spawn pad") {
                                tmpContext.fillStyle = "#7e7f82";
                                renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = "#71aad6";
                                renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                            } else if (obj.name == "blocker") {
                                tmpContext.fillStyle = "#7e7f82";
                                renderCircle(0, 0, obj.scale, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.rotate(Math.PI / 4);
                                tmpContext.fillStyle = "#db6e6e";
                                renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                            } else if (obj.name == "teleporter") {
                                tmpContext.fillStyle = "#7e7f82";
                                renderCircle(0, 0, obj.scale, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.rotate(Math.PI / 4);
                                tmpContext.fillStyle = "#d76edb";
                                renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                            }
                        }
                        tmpSprite = tmpCanvas;
                        if (!asIcon)
                            itemSprites[obj.id] = tmpSprite;
                    }
                    return tmpSprite;
                }

                function getItemSprite2(obj, tmpX, tmpY) {
                    let tmpContext = mainContext;
                    let reScale = (obj.name == "windmill" ? items.list[4].scale : obj.scale);
                    tmpContext.save();
                    tmpContext.translate(tmpX, tmpY);
                    tmpContext.rotate(obj.dir);
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.lineWidth = outlineWidth;
                    if (obj.name == "apple") {
                        tmpContext.fillStyle = "#c15555";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#89a54c";
                        let leafDir = -(Math.PI / 2);
                        renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir),
                                   25, leafDir + Math.PI / 2, tmpContext);
                    } else if (obj.name == "cookie") {
                        tmpContext.fillStyle = "#cca861";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#937c4b";
                        let chips = 4;
                        let rotVal = (Math.PI * 2) / chips;
                        let tmpRange;
                        for (let i = 0; i < chips; ++i) {
                            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                         UTILS.randInt(4, 5), tmpContext, true);
                        }
                    } else if (obj.name == "cheese") {
                        tmpContext.fillStyle = "#f4f3ac";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#c3c28b";
                        let chips = 4;
                        let rotVal = (Math.PI * 2) / chips;
                        let tmpRange;
                        for (let i = 0; i < chips; ++i) {
                            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                         UTILS.randInt(4, 5), tmpContext, true);
                        }
                    } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                        tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                            "#a5974c" : "#939393";
                        let sides = (obj.name == "castle wall") ? 4 : 3;
                        renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                            "#c9b758" : "#bcbcbc";
                        renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                               obj.name == "spinning spikes") {
                        tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                        let tmpScale = (obj.scale * 0.6);
                        renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, tmpScale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                    } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, reScale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, reScale * 0.5, tmpContext);
                    } else if (obj.name == "mine") {
                        tmpContext.fillStyle = "#939393";
                        renderStar(tmpContext, 3, obj.scale, obj.scale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#bcbcbc";
                        renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "sapling") {
                        for (let i = 0; i < 2; ++i) {
                            let tmpScale = obj.scale * (!i ? 1 : 0.5);
                            renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                            tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                            tmpContext.fill();
                            if (!i) tmpContext.stroke();
                        }
                    } else if (obj.name == "pit trap") {
                        tmpContext.fillStyle = "#a5974c";
                        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = outlineColor;
                        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "boost pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#dbd97d";
                        renderTriangle(obj.scale * 1, tmpContext);
                    } else if (obj.name == "turret") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#939393";
                        let tmpLen = 50;
                        renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                    } else if (obj.name == "platform") {
                        tmpContext.fillStyle = "#cebd5f";
                        let tmpCount = 4;
                        let tmpS = obj.scale * 2;
                        let tmpW = tmpS / tmpCount;
                        let tmpX = -(obj.scale / 2);
                        for (let i = 0; i < tmpCount; ++i) {
                            renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpX += tmpS / tmpCount;
                        }
                    } else if (obj.name == "healing pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "spawn pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#71aad6";
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    } else if (obj.name == "blocker") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "teleporter") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#d76edb";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                    }
                    tmpContext.restore();
                }

                let objSprites = [];
                function getObjSprite(obj) {
                    let tmpSprite = objSprites[obj.id];
                    if (!tmpSprite) {
                        let blurScale = isNight ? 15 : 0;
                        let tmpCanvas = document.createElement("canvas");
                        tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0) + blurScale;
                        let tmpContext = tmpCanvas.getContext("2d");
                        tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                        tmpContext.rotate(Math.PI / 2);
                        tmpContext.strokeStyle = outlineColor;
                        tmpContext.lineWidth = outlineWidth;
                        if (isNight) {
                            tmpContext.shadowBlur = blurScale;
                            tmpContext.shadowColor = `rgba(0, 0, 0, ${Math.min(0.3, obj.alpha)})`;
                        }
                        if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                            tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
                            let tmpScale = obj.scale * 0.6;
                            renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#a5974c";
                            renderCircle(0, 0, tmpScale, tmpContext);
                            tmpContext.fillStyle = "#cc5151";
                            renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                        } else if (obj.name == "pit trap") {
                            tmpContext.fillStyle = "#a5974c";
                            renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#cc5151";
                            renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                            tmpContext.fill();
                        }
                        tmpSprite = tmpCanvas;
                        objSprites[obj.id] = tmpSprite;
                    }
                    return tmpSprite;
                }

                // GET MARK SPRITE:
                function getMarkSprite(obj, tmpContext, tmpX, tmpY, xOffset, yOffset) {
                    let center = {
                        x: screenWidth / 2,
                        y: screenHeight / 2,
                    };
                    tmpContext.lineWidth = outlineWidth;
                    mainContext.globalAlpha = 0.275;
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.save();
                    tmpContext.translate(tmpX, tmpY);
                    tmpContext.rotate(obj.dir || getAttackDir());
                    if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                        tmpContext.fillStyle = (obj.name == "poison spikes")?"#7b935d":"#939393";
                        var tmpScale = (obj.scale * 0.6);
                        renderStar(tmpContext, (obj.name == "spikes")?5:6, obj.scale, tmpScale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, tmpScale, tmpContext);
                        if (player && obj.owner && player.sid != obj.owner.sid && !tmpObj.findAllianceBySid(obj.owner.sid)) {
                            tmpContext.fillStyle = "#a34040";
                        } else {
                            tmpContext.fillStyle = "#c9b758";
                        }
                        renderCircle(0, 0, tmpScale/2, tmpContext, true);
                    } else if (obj.name == "turret") {
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#939393";
                        let tmpLen = 50;
                        renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                    } else if (obj.name == "teleporter") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#d76edb";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                    } else if (obj.name == "platform") {
                        tmpContext.fillStyle = "#cebd5f";
                        let tmpCount = 4;
                        let tmpS = obj.scale * 2;
                        let tmpW = tmpS / tmpCount;
                        let tmpX = -(obj.scale / 2);
                        for (let i = 0; i < tmpCount; ++i) {
                            renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpX += tmpS / tmpCount;
                        }
                    } else if (obj.name == "healing pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "spawn pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#71aad6";
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    } else if (obj.name == "blocker") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderRectCircle(0, 0, obj.scale * 1.5, 29, 4, tmpContext);
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext);

                    } else if (obj.name == "pit trap") {
                        tmpContext.fillStyle = "#a5974c";
                        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        if (player && obj.owner && player.sid != obj.owner.sid && !tmpObj.findAllianceBySid(obj.owner.sid)) {
                            tmpContext.fillStyle = "#a34040";
                        } else {
                            tmpContext.fillStyle = outlineColor;
                        }
                        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    }
                    tmpContext.restore();
                }
                //renderCircle(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.getScale(0.6, true), mainContext, false, true);

                // OBJECT ON SCREEN:
                function isOnScreen(x, y, s) {
                    return (x + s >= 0 && x - s <= maxScreenWidth && y + s >= 0 && (y,
                                                                                    s,
                                                                                    maxScreenHeight));
                }

                // RENDER GAME OBJECTS:
                showLayer={
                    0:1,1:1,2:1,3:1,4:1,5:1,6:1
                }
                /* layers
            0:stones
            1:mills
            2:berry/catus
            3:trees

            */
                function renderGameObjects(layer, xOffset, yOffset) {
                    let tmpSprite;
                    let tmpX;
                    let tmpY;
                    gameObjects.forEach((tmp) => {
                        tmpObj = tmp;
                        if(!(tmp.layer in showLayer)){
                            showLayer[tmp.layer]=true
                            console.warn('Layer not found')
                        }
                        if(!showLayer[tmp.layer])return;
                        if (tmpObj.alive) {
                            tmpX = tmpObj.x + tmpObj.xWiggle - xOffset;
                            tmpY = tmpObj.y + tmpObj.yWiggle - yOffset;
                            if (layer == 0) {
                                tmpObj.update(delta);
                            }
                            mainContext.globalAlpha = tmpObj.alpha;
                            if (tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0))) {
                                if (tmpObj.isItem) {
                                    if ((tmpObj.dmg || tmpObj.trap) && !tmpObj.isTeamObject(player)) {
                                        tmpSprite = getObjSprite(tmpObj);
                                    } else {
                                        tmpSprite = getItemSprite(tmpObj);
                                    }

                                    mainContext.save();
                                    mainContext.translate(tmpX, tmpY);
                                    mainContext.rotate(tmpObj.dir);
                                    if (!tmpObj.active) {
                                        mainContext.scale(tmpObj.visScale / tmpObj.scale, tmpObj.visScale / tmpObj.scale);
                                    }
                                    mainContext.drawImage(tmpSprite, -(tmpSprite.width / 2), -(tmpSprite.height / 2));

                                    if (tmpObj.blocker) {
                                        mainContext.strokeStyle = "#db6e6e";
                                        mainContext.globalAlpha = 0.3;
                                        mainContext.lineWidth = 6;
                                        renderCircle(0, 0, tmpObj.blocker, mainContext, false, true);
                                    }
                                    mainContext.restore();
                                } else {
                                    tmpSprite = getResSprite(tmpObj);
                                    mainContext.drawImage(tmpSprite, tmpX - (tmpSprite.width / 2), tmpY - (tmpSprite.height / 2));
                                }
                            }
                            if (layer == 3 && !useWasd) {
                                if (tmpObj.health < tmpObj.maxHealth) {
                                    const endAngle = (tmpObj.health / tmpObj.maxHealth) * 360 * (Math.PI / 180);
                                    const radius = 14;
                                    const scale = 22;
                                    mainContext.save();
                                    mainContext.lineWidth = 9;
                                    mainContext.lineCap = 'round';
                                    mainContext.translate(tmpX, tmpY);
                                    mainContext.beginPath();
                                    mainContext.arc(0, 0, scale, 0, endAngle);
                                    mainContext.stroke();
                                    mainContext.restore();
                                    mainContext.save();
                                    mainContext.strokeStyle = tmpObj.isTeamObject(player) ? "#8ecc51" : "#cc5151";
                                    mainContext.lineCap = 'round';
                                    mainContext.translate(tmpX, tmpY);
                                    mainContext.beginPath();
                                    mainContext.arc(0, 0, scale, 0, endAngle);
                                    mainContext.stroke();
                                    mainContext.restore();
                                }
                            }
                        }
                    });

                    // PLACE VISIBLE:
                    if (layer == 0) {
                        if (placeVisible.length) {
                            placeVisible.forEach((places) => {
                                tmpX = places.x - xOffset;
                                tmpY = places.y - yOffset;
                                markObject(places, tmpX, tmpY);
                            });
                        }
                    }
                }
                function markObject(tmpObj, tmpX, tmpY) {
                    getMarkSprite(tmpObj, mainContext, tmpX, tmpY);
                }

                // RENDER MINIMAP:
                class MapPing {
                    constructor(color, scale) {
                        this.init = function (x, y) {
                            this.scale = 0;
                            this.x = x;
                            this.y = y;
                            this.active = true;
                        };
                        this.update = function (ctxt, delta) {
                            if (this.active) {
                                this.scale += 0.05 * delta;
                                if (this.scale >= scale) {
                                    this.active = false;
                                } else {
                                    ctxt.globalAlpha = (1 - Math.max(0, this.scale / scale));
                                    ctxt.beginPath();
                                    ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale)
                                             * mapDisplay.width, this.scale, 0, 2 * Math.PI);
                                    ctxt.stroke();
                                }
                            }
                        };
                        this.color = color;
                    }
                }
                function pingMap(x, y) {
                    tmpPing = mapPings.find(pings => !pings.active);
                    if (!tmpPing) {
                        tmpPing = new MapPing("#fff", config.mapPingScale);
                        mapPings.push(tmpPing);
                    }
                    tmpPing.init(x, y);
                }
                function updateMapMarker() {
                    mapMarker.x = player.x;
                    mapMarker.y = player.y;
                }
                function renderMinimap(delta) {
                    if (player && player.alive) {
                        mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height);

                        // RENDER PINGS:
                        mapContext.lineWidth = 4;
                        for (let i = 0; i < mapPings.length; ++i) {
                            tmpPing = mapPings[i];
                            mapContext.strokeStyle = tmpPing.color;
                            tmpPing.update(mapContext, delta);
                        }

                        // RENDER BREAK TRACKS:
                        mapContext.globalAlpha = 1;
                        mapContext.fillStyle = "#ff0000";
                        if (breakTrackers.length) {
                            mapContext.fillStyle = "#abcdef";
                            mapContext.font = "34px Hammersmith One";
                            mapContext.textBaseline = "middle";
                            mapContext.textAlign = "center";
                            for (let i = 0; i < breakTrackers.length;) {
                                mapContext.fillText("!", (breakTrackers[i].x/config.mapScale)*mapDisplay.width,
                                                    (breakTrackers[i].y/config.mapScale)*mapDisplay.height);
                                i += 2;
                            }
                        }

                        // RENDER PLAYERS:
                        mapContext.globalAlpha = 1;
                        mapContext.fillStyle = "#fff";
                        renderCircle((player.x/config.mapScale)*mapDisplay.width,
                                     (player.y/config.mapScale)*mapDisplay.height, 7, mapContext, true);
                        mapContext.fillStyle = "rgba(255,255,255,0.35)";
                        if (player.team && minimapData) {
                            for (let i = 0; i < minimapData.length;) {
                                renderCircle((minimapData[i]/config.mapScale)*mapDisplay.width,
                                             (minimapData[i+1]/config.mapScale)*mapDisplay.height, 7, mapContext, true);
                                i+=2;
                            }
                        }

                        // RENDER BOTS:
                        if (bots.length) {
                            bots.forEach((tmp) => {
                                if (tmp.inGame) {
                                    mapContext.globalAlpha = 1;
                                    mapContext.strokeStyle = "#cc5151";
                                    renderCircle((tmp.x2 / config.mapScale) * mapDisplay.width,
                                                 (tmp.y2 / config.mapScale) * mapDisplay.height, 7, mapContext, false, true);
                                }
                            });
                        }

                        // DEATH LOCATION:
                        if (lastDeath) {
                            mapContext.fillStyle = "#fc5553";
                            mapContext.font = "34px Hammersmith One";
                            mapContext.textBaseline = "middle";
                            mapContext.textAlign = "center";
                            mapContext.fillText("x", (lastDeath.x/config.mapScale)*mapDisplay.width,
                                                (lastDeath.y/config.mapScale)*mapDisplay.height);
                        }

                        // MAP MARKER:
                        if (mapMarker) {
                            mapContext.fillStyle = "#fff";
                            mapContext.font = "34px Hammersmith One";
                            mapContext.textBaseline = "middle";
                            mapContext.textAlign = "center";
                            mapContext.fillText("x", (mapMarker.x/config.mapScale)*mapDisplay.width,
                                                (mapMarker.y/config.mapScale)*mapDisplay.height);
                        }
                    }
                }

                // ICONS:
                let crossHairs = ['https://icons.veryicon.com/png/o/leisure/maps-and-travel/crosshair-5.png',"https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/f04b32b4-58c3-4e24-a642-67320f0a66bb/de2hbo4-0fc82d60-9bcd-432f-b789-e5ed0a4e6c87.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcL2YwNGIzMmI0LTU4YzMtNGUyNC1hNjQyLTY3MzIwZjBhNjZiYlwvZGUyaGJvNC0wZmM4MmQ2MC05YmNkLTQzMmYtYjc4OS1lNWVkMGE0ZTZjODcucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.EMv0SSsbwnUN4hDQFf42wi9Rv8p_RzhRv8oowDRJEOg", "https://cdn.discordapp.com/attachments/1001384433078779927/1149285168780165170/100px-Crosshairs_Red.png"];
                let crossHairSprites = {};
                let iconSprites = {};
                let icons = ["crown", "skull"];
                function loadIcons() {
                    for (let i = 0; i < icons.length; ++i) {
                        let tmpSprite = new Image();
                        tmpSprite.onload = function() {
                            this.isLoaded = true;
                        };
                        tmpSprite.src = "./../img/icons/" + icons[i] + ".png";
                        iconSprites[icons[i]] = tmpSprite;
                    }
                    for (let i = 0; i < crossHairs.length; ++i) {
                        let tmpSprite = new Image();
                        tmpSprite.onload = function () {
                            this.isLoaded = true;
                            console.log(crossHairs[i].split('/').pop(),'Loaded')
                        };
                        tmpSprite.src = crossHairs[i];
                        crossHairSprites[i] = tmpSprite;
                    }
                }
                loadIcons();

                // UPDATE GAME:
                var defaultRange_=1200
                defaultRange={
                    get range(){return defaultRange_},
                    set range(e){return defaultRange_=e},
                    reset(){defaultRange_=1200}
                }
                // highlightConnectedTraps
                chainBumpDist =0;
                standOff=-10

                _things.autoPushChain={near:null,traps:null}
                function highlightConnectedTraps(ctx, xOffset = 0, yOffset = 0) {
                    _things.autoPushChain={near:null,traps:null}
                    const near    = _things.enemy.enemy;
                    if(!near)return "no enemy";
                    const allObjs = _things.liztobj;
                    const bump    = chainBumpDist;
                    const extra   = 0;
                    _things.pushPos = null;

                    // 1) find the trap under the enemy
                    const startTrap = allObjs
                    .filter(o =>
                            o.trap &&
                            o.active &&
                            o.isTeamObject(player) &&
                            // raw collision: distance <= o.radius + near.radius
                            UTILS.getDistance(o.x, o.y, near.x, near.y) <=
                            (o.getScale ? o.getScale(0.6, o.isItem) : o.scale) +
                            near.scale
                           )
                    .sort((a, b) =>
                          UTILS.getDistance(a.x, a.y, near.x, near.y) -
                          UTILS.getDistance(b.x, b.y, near.x, near.y)
                         )[0];

                    if (!startTrap) return;

                    // 2) BFS for trap chain ending in a spike
                    const queue = [[ startTrap ]];
                    const seen  = new Set([ startTrap.sid ]);
                    let path, finalSpike;

                    while (queue.length) {
                        const branch = queue.shift();
                        const last   = branch[branch.length - 1];

                        // does this last trap touch a spike?
                        const spike = allObjs.find(o =>
                                                   o.dmg &&
                                                   o.active &&
                                                   o.isTeamObject(player) &&
                                                   UTILS.getDistance(o.x, o.y, last.x, last.y) <=
                                                   last.getScale(0.6, last.isItem) + o.scale + player.scale * 0.9
                                                  );
                        if (spike) {
                            path       = branch;
                            finalSpike = spike;
                            break;
                        }

                        // otherwise enqueue neighbors
                        for (let nbr of allObjs) {
                            if (
                                !nbr.trap ||
                                !nbr.active ||
                                !nbr.isTeamObject(player) ||
                                seen.has(nbr.sid)
                            ) continue;

                            const dist = UTILS.getDistance(
                                last.x, last.y,
                                nbr.x,  nbr.y
                            );
                            const lastRad = last.getScale(0.6, last.isItem);
                            const nbrRad  = nbr.getScale(0.6, nbr.isItem);
                            if (dist <= lastRad + nbrRad + player.scale + bump) {
                                seen.add(nbr.sid);
                                queue.push(branch.concat(nbr));
                            }
                        }
                    }
                    _things.autoPushChain.traps=[]
                    if (!path) return;

                    // 3) draw trap→trap lines and circles
                    ctx.save();
                    ctx.lineWidth   = 3;
                    ctx.strokeStyle = "rgba(255,100,0,0.9)";
                    _things.autoPushChain.traps=path
                    _things.autoPushChain.near=near
                    for (let i = 0; i < path.length - 1; i++) {
                        const A = path[i], B = path[i+1];
                        ctx.beginPath();
                        ctx.moveTo(A.x - xOffset, A.y - yOffset);
                        ctx.lineTo(B.x - xOffset, B.y - yOffset);
                        ctx.stroke();
                    }
                    ctx.restore();
                    ctx.save();
                    ctx.lineWidth   = 2;
                    ctx.strokeStyle = "rgba(255,100,0,0.6)";
                    for (let trap of path) {
                        const cx = trap.x - xOffset;
                        const cy = trap.y - yOffset;
                        const r  = trap.getScale(0.6, trap.isItem) + extra;
                        ctx.beginPath();
                        ctx.arc(cx, cy, r, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    ctx.restore();

                    // 4) highlight the final spike
                    if (finalSpike) {
                        ctx.save();
                        ctx.lineWidth   = 4;
                        ctx.strokeStyle = "rgba(0,200,255,0.9)";
                        const sx = finalSpike.x - xOffset;
                        const sy = finalSpike.y - yOffset;
                        const sr = finalSpike.scale + extra;
                        ctx.beginPath();
                        ctx.arc(sx, sy, sr, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                    }

                    let target = null;
                    if (path && path.length > 0) {
                        const A = path[0];
                        const nextObj = path[1] || finalSpike;
                        if (nextObj) {
                            // get direction using their game‐object fields
                            const dir = UTILS.getDirection(A, nextObj);
                            // ensure we got a number
                            if (typeof dir === "number" && !isNaN(dir)) {
                                // trap radius from the helper (falls back to scale)
                                const trapRad = A.getScale
                                ? A.getScale(0.6, A.isItem)
                                : (A.scale || 0);
                                const radius = trapRad + (player.scale || 0);

                                // use A.x2/y2 since UTILS.getDirection relies on those
                                const px = A.x2 + Math.cos(dir) * radius;
                                const py = A.y2 + Math.sin(dir) * radius;

                                // final sanity check
                                if (!isNaN(px) && !isNaN(py)) {
                                    target = { x: px, y: py };
                                }
                            }
                        }
                    }
                    _things.pushPos = target;

                    // 6) draw the green circle only if we have a valid pushPos
                    if (target) {
                        ctx.save();
                        ctx.lineWidth   = 3;
                        ctx.strokeStyle = "rgba(0,255,0,0.8)";
                        ctx.beginPath();
                        ctx.arc(
                            target.x - xOffset,
                            target.y - yOffset,
                            player.scale || 20,
                            0,
                            Math.PI * 2
                        );
                        ctx.stroke();
                        ctx.restore();
                    }
                    if (!target) return;
                    return true
                }
                arcThreshold = 140;  // adjust however “close” you need
                /**
              * Given P0 (player), PC (trap center), P1 (stand spot),
              * compute the quadratic Bezier point at parameter t.
            */
                function quadraticPoint(P0, PC, P1, t) {
                    const u = 1 - t;
                    return {
                        x: u*u * P0.x + 2*u*t * PC.x + t*t * P1.x,
                        y: u*u * P0.y + 2*u*t * PC.y + t*t * P1.y
                    };
                }
                my.autoPush2=false;
                minmax=[-10,-4].reverse()
                //MAX_BACKOFF = player.scale * 2; // or e.g. 40
                function drawPushGuideWithArc(ctx, xOffset = 0, yOffset = 0) {
                    my.autoPush2 = false;

                    // 1️⃣ Enemy & chain visuals
                    const near = _things.enemy.enemy;
                    if (!near) return;
                    highlightConnectedTraps(ctx, xOffset, yOffset);
                    if (my.autoPush||!configs.autoPush) return;
                    // 2️⃣ Chain & final spike
                    const chain      = _things.autoPushChain.traps || [];
                    const finalSpike = _things.autoPushChain.spike;
                    if (chain.length === 0 && !finalSpike) return;

                    // 3️⃣ Which trap‐step
                    _things.autoPushChain.step = _things.autoPushChain.step || 0;
                    let idx = _things.autoPushChain.step;
                    const targetObj = idx < chain.length ? chain[idx] : finalSpike;
                    if (!targetObj) return;

                    // 4️⃣ Compute A→B or A→spike direction
                    const nextObj = (idx+1 < chain.length) ? chain[idx+1] : finalSpike;
                    const pushDirTrap = nextObj
                    ? UTILS.getDirection(targetObj.x, targetObj.y, nextObj.x, nextObj.y)
                    : UTILS.getDirection(targetObj.x, targetObj.y, near.x, near.y);

                    // 5️⃣ Compute raw “behind” point (enemy edge)
                    const rawBehindX = near.x + Math.cos(pushDirTrap) * near.scale;
                    const rawBehindY = near.y + Math.sin(pushDirTrap) * near.scale;

                    // 6️⃣ Angle misalignment & normalized pct [0…1]
                    const approachDir0 = UTILS.getDirection(
                        player.x2, player.y2,
                        rawBehindX, rawBehindY
                    );
                    if (isNaN(approachDir0)) return;
                    const angleDiff = UTILS.getAngleDist(approachDir0, pushDirTrap);
                    const pct       = Math.min(angleDiff / (Math.PI/2), 1);

                    // 7️⃣ Map pct → standOff via minmax
                    const [minOff, maxOff] = minmax;
                    const standOff = minmax[1] + (1 - pct) * (minmax[0] - minmax[1]);

                    // 8️⃣ Final stand‐spot on enemy circle
                    const standDist = near.scale + standOff;
                    const standX    = near.x + Math.cos(pushDirTrap) * standDist;
                    const standY    = near.y + Math.sin(pushDirTrap) * standDist;

                    // 9️⃣ Arrival check & advance step
                    const dx   = standX - player.x2;
                    const dy   = standY - player.y2;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 5) {
                        _things.autoPushChain.step = idx + 1;
                        if (_things.autoPushChain.step > chain.length) {
                            _things.autoPushChain.moveDir = null;
                            isMovingAuto=0
                            _things.packet("9", null, 1);
                            lastDir=null
                            return; // ready to fire spike
                        }
                    }

                    // 🔟 Compute actual approachDir → stand‐spot
                    const approachDir = UTILS.getDirection(
                        player.x2, player.y2,
                        standX,    standY
                    );
                    if (isNaN(approachDir)) return;
                    const pushDistance = 250;

                    let FindSpike=chain[1]
                    if(FindSpike){
                        my.autoPush2 = true;
                        const pushAngle = UTILS.getDirect(near, FindSpike, 2, 0);
                        const pushDist = UTILS.getDist(near, FindSpike, 2, 0);

                        const pos = {
                            x: chain[0].x + pushDistance * Math.cos(pushAngle),
                            y: FindSpike.y + pushDistance * Math.sin(pushAngle),
                            x2: FindSpike.x + ((pushDist + player.scale * 1.5) * Math.cos(pushAngle)),
                            y2: FindSpike.y + ((pushDist + player.scale * 1.5) * Math.sin(pushAngle))
                        };
                        const pos3 = {
                            x2: FindSpike.x + ((pushDist + player.scale * 1.5) * Math.cos(pushAngle)),
                            y2: FindSpike.y + ((pushDist + player.scale * 1.5) * Math.sin(pushAngle))
                        };
                        const pos2 = {
                            x: pos3.x2 + Math.cos(30),
                            y: pos3.y2 + Math.sin(30)
                        };
                        const pos4 = {
                            x2: FindSpike.x + ((pushDist + player.scale * 1) * Math.cos(pushAngle)),
                            y2: FindSpike.y + ((pushDist + player.scale * 1) * Math.sin(pushAngle))
                        };
                        const pos5 = {
                            x: pos4.x2 + Math.cos(30),
                            y: pos4.y2 + Math.sin(30)
                        };

                        //(near.health != 100 && near.dist2 <= 150)
                        if (UTILS.getDist(near, FindSpike, 2, 0) <= 60) {
                            pathFind.active = false;
                            isMovingAuto=0;
                            _things.packet("9", undefined, 1);
                        }
                        else {
                            if (near.dist2 <= 100) {
                                isMovingAuto=1
                                pathFind.active = false;
                                let dir=UTILS.getDirect(pos, player, 2, 2)
                                lastMoveDir=dir
                                _things.autoPushChain.moveDir_ = dir;
                                _things.packet("9", dir, 1);
                                retrappable = true;
                            } else {
                                //pathFind.active = true;
                                isMovingAuto=1
                                lastMoveDir=approachDir + Math.PI
                                _things.packet("9", approachDir + Math.PI, 1);
                                _things.autoPushChain.moveDir_ = approachDir+Math.PI;
                                //Pathfinder(pos5, 0, 0);
                                retrappable = true;
                            }
                        }
                    }

                    // 10) draw the guide line + circle
                    const sx  = player.x2 - xOffset, sy  = player.y2 - yOffset;
                    const tx  = standX    - xOffset, ty  = standY    - yOffset;

                    ctx.save();
                    ctx.strokeStyle = "rgba(0,255,0,0.8)";
                    ctx.lineWidth   = 2;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(tx, ty);
                    ctx.stroke();
                    ctx.restore();

                    ctx.save();
                    ctx.strokeStyle = "rgba(0,255,0,0.8)";
                    ctx.lineWidth   = 3;
                    ctx.beginPath();
                    ctx.arc(tx, ty, player.scale, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();

                    // 11) set movement dir and packet
                    _things.autoPushChain.moveDir = approachDir;
                    return;
                    if (!isNaN(approachDir)&&false) {
                        my.autoPush2 = true;
                        retrappable  = true;
                        // your weapon‐swap logic here...
                        let w=_things.player.weapons
                        let haFast=[1,6,7,8].includes(w[0])
                        let hasHam=w.includes(10)
                        if(canChangeW&&false){
                            canChangeW=false;
                            setTimeout(()=>{canChangeW=true},2000)
                            if(haFast&&hasHam){
                                //buyEquip(0,1)
                                selectWeapon(player.weapons[1])
                            }else selectWeapon(player.weapons[0])
                        }
                        // … your weapon logic here …
                        _things.packet("9", approachDir + Math.PI, 1);
                    }
                }
                function drawPushGuideWithArcw(ctx, xOffset = 0, yOffset = 0) {
                    my.autoPush2 = false;
                    if (my.autoPush || !configs.autoPush) return;

                    // 1️⃣ Enemy check & visuals
                    const near = _things.enemy.enemy;
                    if (!near) return;
                    highlightConnectedTraps(ctx, xOffset, yOffset);

                    // 2️⃣ Chain/spike
                    const chain      = _things.autoPushChain.traps || [];
                    const finalSpike = _things.autoPushChain.spike;
                    if (chain.length === 0 && !finalSpike) return;

                    // 3️⃣ Step index
                    if (typeof _things.autoPushChain.step !== "number") {
                        _things.autoPushChain.step = 0;
                    }
                    let idx       = _things.autoPushChain.step;
                    const target  = chain[idx] || finalSpike;
                    if (!target) return;

                    // 4️⃣ Push dir
                    const next  = chain[idx + 1] || finalSpike;
                    const pushDirTrap = UTILS.getDirection(
                        target.x, target.y,
                        next ? next.x : near.x,
                        next ? next.y : near.y
                    );

                    // 5️⃣ Collision-point on circle edge
                    const hitDist = near.scale; // adjust if you want extra spacing
                    const collX   = near.x + Math.cos(pushDirTrap) * hitDist;
                    const collY   = near.y + Math.sin(pushDirTrap) * hitDist;

                    // 6️⃣ Approach alignment
                    const approach0 = UTILS.getDirection(player.x2, player.y2, collX, collY);
                    if (isNaN(approach0)) return;
                    const angleDiff = UTILS.getAngleDist(approach0, pushDirTrap);

                    // 7️⃣ Decide arc vs straight
                    const STRAIGHT_ANGLE_THRESH = Math.PI * 0.5; // ~18°, tweakable
                    let aimX, aimY;

                    if (Math.abs(angleDiff) < STRAIGHT_ANGLE_THRESH) {
                        // 🎯 dead-on: aim direct at collision point
                        aimX = collX;
                        aimY = collY;

                        // draw straight line
                        ctx.save();
                        ctx.strokeStyle = "rgba(255,0,0,0.8)";
                        ctx.lineWidth   = 2;
                        ctx.beginPath();
                        ctx.moveTo(player.x2 - xOffset, player.y2 - yOffset);
                        ctx.lineTo(aimX      - xOffset, aimY      - yOffset);
                        ctx.stroke();
                        ctx.restore();

                    } else {
                        // 🔄 off-angle: arc into spot (standOff logic still applies)
                        // compute standOff like before
                        const pct      = Math.min(angleDiff / (Math.PI/2), 1);
                        const [minOff, maxOff] = minmax;
                        const standOff = maxOff + (1 - pct) * (minOff - maxOff);
                        const standX   = near.x + Math.cos(pushDirTrap) * (near.scale + standOff);
                        const standY   = near.y + Math.sin(pushDirTrap) * (near.scale + standOff);

                        aimX = standX;
                        aimY = standY;

                        // draw a nice curve
                        const sx = player.x2 - xOffset, sy = player.y2 - yOffset;
                        const tx = standX    - xOffset, ty = standY    - yOffset;
                        ctx.save();
                        ctx.strokeStyle = "rgba(0,255,255,0.8)";
                        ctx.lineWidth   = 2;
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.quadraticCurveTo(
                            (sx + tx) / 2,
                            (sy + ty) / 2 - 30,  // bump control-point up for smoother arc
                            tx, ty
                        );
                        ctx.stroke();
                        ctx.restore();
                    }

                    // 8️⃣ Advance step if we arrived
                    const dx   = aimX - player.x2;
                    const dy   = aimY - player.y2;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 5) {
                        _things.autoPushChain.step = idx + 1;
                        if (_things.autoPushChain.step > chain.length) {
                            _things.autoPushChain.moveDir = null;
                            _things.packet("9", undefined, 1);
                            return;
                        }
                    }

                    // 9️⃣ Set move dir + packet
                    const finalDir = UTILS.getDirection(player.x2, player.y2, aimX, aimY);
                    if (!isNaN(finalDir)) {
                        my.autoPush2 = true;
                        retrappable  = true;
                        _things.autoPushChain.moveDir = finalDir;

                        // throttle push packets so it’s not sus-spam
                        if (!my.lastPushTime || Date.now() - my.lastPushTime > 300) {
                            my.lastPushTime = Date.now();
                            _things.packet("9", finalDir + Math.PI, 1);
                        }
                    }
                }


                let canChangeW=true


                function drawPushGuideWithArcWorkingOld(ctx, xOffset = 0, yOffset = 0) {
                    // 1) Build the chain & spike info
                    highlightConnectedTraps(ctx, xOffset, yOffset);
                    if(!configs.autoPush)return;
                    const chain = _things.autoPushChain.traps;
                    const spike = _things.autoPushChain.spike;
                    const near = _things.autoPushChain.near;

                    if (!Array.isArray(chain) || chain.length === 0) return;

                    const targetX = near.x2;
                    const targetY = near.y2;

                    const A = chain[0];
                    const B = chain[1] || spike;
                    if (!B) return;

                    // 2) trap-to-trap push angle (for visuals)
                    const pushDirTrap = UTILS.getDirection(A.x, A.y, B.x, B.y);
                    if (isNaN(pushDirTrap)) return;

                    // 3) radii
                    const trapRad     = A.getScale ? A.getScale(0.6, A.isItem) : A.scale;
                    const standRadius = trapRad + player.scale * 0.5;
                    const arcRadius   = Math.min(trapRad * 1.5, 100);

                    // 4) stand spot just outside A
                    const standX = A.x + Math.cos(pushDirTrap) * standRadius;
                    const standY = A.y + Math.sin(pushDirTrap) * standRadius;

                    // 5) movement direction (player → standSpot) **this is what you should move toward**
                    const moveDir = UTILS.getDirection(
                        player.x2, player.y2,
                        standX,    standY
                    );
                    if (isNaN(moveDir)) return;

                    // store the correct movement angle
                    _things.autoPushChain.pushDir = moveDir;
                    lastMoveDir=moveDir
                    _things.pushPos = { x: standX, y: standY };

                    // 6) draw straight vs. arc
                    //    if your approach angle differs from trap-push by > 90°, draw an arc
                    const diff = UTILS.getAngleDist(moveDir, pushDirTrap);
                    const useArc = diff > Math.PI/2;

                    // convert coords
                    const cx  = A.x - xOffset,  cy  = A.y - yOffset;
                    const px  = standX - xOffset, py = standY - yOffset;
                    const plx = player.x2 - xOffset, ply = player.y2 - yOffset;

                    ctx.save();
                    ctx.strokeStyle = "rgba(0,255,0,0.8)";
                    ctx.lineWidth   = 2;

                    if (useArc) {
                        // arc from your current approach into the trap-push angle
                        const startAng = moveDir;
                        const endAng   = pushDirTrap;
                        const anticw   = ((endAng - startAng + 2*Math.PI) % (2*Math.PI)) > Math.PI;
                        ctx.beginPath();
                        ctx.arc(cx, cy, arcRadius, startAng, endAng, anticw);
                        ctx.stroke();

                        // short line from arc endpoint to standSpot
                        const arcEndX = cx + Math.cos(endAng) * arcRadius;
                        const arcEndY = cy + Math.sin(endAng) * arcRadius;
                        ctx.beginPath();
                        ctx.moveTo(arcEndX, arcEndY);
                        ctx.lineTo(px, py);
                        ctx.stroke();
                    } else {
                        // direct line from player to standSpot
                        ctx.beginPath();
                        ctx.moveTo(plx, ply);
                        ctx.lineTo(px, py);
                        ctx.stroke();
                    }
                    ctx.restore();

                    // 7) circle the standSpot
                    ctx.save();
                    ctx.strokeStyle = "rgba(0,255,0,0.8)";
                    ctx.lineWidth   = 3;
                    ctx.beginPath();
                    ctx.arc(px, py, player.scale, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                }




                // somewhere at top-level
                let lastSaveTime = performance.now();
                const SAVE_INTERVAL = 1000; // ms between saves
                function updateGame() {
                    if(gameObjects.length && inGame) {
                        gameObjects.forEach((tmp) => {
                            if(UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) <= defaultRange.range) {
                                if(!liztobj.includes(tmp)) {
                                    liztobj.push(tmp);
                                    tmp.render = true;
                                }
                            } else {
                                if(liztobj.includes(tmp)) {
                                    if(UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) >= 1200) {
                                        tmp.render = false;
                                        const index = liztobj.indexOf(tmp);
                                        if (index > -1) { // only splice array when item is found
                                            liztobj.splice(index, 1); // 2nd parameter means remove one item only
                                        }
                                    }
                                } else if(UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) >= 1200) {
                                    tmp.render = false;
                                    const index = liztobj.indexOf(tmp);
                                    if (index > -1) { // only splice array when item is found
                                        liztobj.splice(index, 1); // 2nd parameter means remove one item only
                                    }
                                } else {
                                    tmp.render = false;
                                    const index = liztobj.indexOf(tmp);
                                    if (index > -1) { // only splice array when item is found
                                        liztobj.splice(index, 1); // 2nd parameter means remove one item only
                                    }
                                }
                            }
                        })
                        // gameObjects = gameObjects.filter(e => UTILS.getDistance(e.x, e.y, player.x, player.y) <= 1000)
                    }
                    if (config.resetRender) {
                        mainContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                        mainContext.beginPath();
                    }

                    if (true) {
                        if (player) {
                            let damping = 0.0325;
                            camX += (player.x - camX) * damping;
                            camY += (player.y - camY) * damping;
                        } else {
                            camX = config.mapScale / 2;
                            camY = config.mapScale / 2;
                        }



                        // INTERPOLATE PLAYERS AND AI:
                        let lastTime = now - (1000 / config.serverUpdateRate);
                        let tmpDiff;
                        for (let i = 0; i < players.length + ais.length; ++i) {
                            tmpObj = players[i] || ais[i - players.length];
                            if (tmpObj && tmpObj.visible) {
                                if (tmpObj.forcePos) {
                                    tmpObj.x = tmpObj.x2;
                                    tmpObj.y = tmpObj.y2;
                                    tmpObj.dir = tmpObj.d2;
                                } else {
                                    let total = tmpObj.t2 - tmpObj.t1;
                                    let fraction = lastTime - tmpObj.t1;
                                    let ratio = (fraction / total);
                                    let rate = 170;
                                    tmpObj.dt += delta;
                                    let tmpRate = Math.min(1.7, tmpObj.dt / rate);
                                    tmpDiff = (tmpObj.x2 - tmpObj.x1);
                                    tmpObj.x = tmpObj.x1 + (tmpDiff * tmpRate);
                                    tmpDiff = (tmpObj.y2 - tmpObj.y1);
                                    tmpObj.y = tmpObj.y1 + (tmpDiff * tmpRate);
                                    if (config.anotherVisual) {
                                        tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                                    } else {
                                        tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                                    }
                                }
                            }
                        }

                        // BETTER MOVE CAMERA:
                        /*if (player) {
                        if (false) {
                            camX = player.x;
                            camY = player.y;
                        } else {
                            let tmpDist = UTILS.getDistance(camX, camY, player.x, player.y);
                            let tmpDir = UTILS.getDirection(player.x, player.y, camX, camY);
                            let camSpd = Math.min(tmpDist * 0.01 * delta, tmpDist);
                            if (tmpDist > 0.05) {
                                camX += camSpd * Math.cos(tmpDir);
                                camY += camSpd * Math.sin(tmpDir);
                            } else {
                                camX = player.x;
                                camY = player.y;
                            }
                        }
                    } else {
                        camX = config.mapScale / 2;
                        camY = config.mapScale / 2;
                    }*/

                        // RENDER CORDS:
                        let xOffset = camX - (maxScreenWidth / 2);
                        let yOffset = camY - (maxScreenHeight / 2);
                        if (disableRender) {
                            return;
                        }
                        // RENDER BACKGROUND:
                        if (config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight) {
                            mainContext.fillStyle = "#b6db66";
                            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                        } else if (config.mapScale - config.snowBiomeTop - yOffset <= 0) {
                            mainContext.fillStyle = "#dbc666";
                            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                        } else if (config.snowBiomeTop - yOffset >= maxScreenHeight) {
                            mainContext.fillStyle = "#fff";
                            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                        } else if (config.snowBiomeTop - yOffset >= 0) {
                            mainContext.fillStyle = "#fff";
                            mainContext.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset);
                            mainContext.fillStyle = "#b6db66";
                            mainContext.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth,
                                                 maxScreenHeight - (config.snowBiomeTop - yOffset));
                        } else {
                            mainContext.fillStyle = "#b6db66";
                            mainContext.fillRect(0, 0, maxScreenWidth,
                                                 (config.mapScale - config.snowBiomeTop - yOffset));
                            mainContext.fillStyle = "#dbc666";
                            mainContext.fillRect(0, (config.mapScale - config.snowBiomeTop - yOffset), maxScreenWidth,
                                                 maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset));
                        }

                        // RENDER WATER AREAS:
                        if (!firstSetup) {
                            waterMult += waterPlus * config.waveSpeed * delta;
                            if (waterMult >= config.waveMax) {
                                waterMult = config.waveMax;
                                waterPlus = -1;
                            } else if (waterMult <= 1) {
                                waterMult = waterPlus = 1;
                            }
                            mainContext.globalAlpha = 1;
                            mainContext.fillStyle = "#dbc666";
                            renderWaterBodies(xOffset, yOffset, mainContext, config.riverPadding);
                            mainContext.fillStyle = "#91b2db";
                            renderWaterBodies(xOffset, yOffset, mainContext, (waterMult - 1) * 250);
                        }

                        if (getEl("visualType").value != "ueh1") {

                            // RENDER GRID:
                            mainContext.lineWidth = 4;
                            mainContext.strokeStyle = "#000";
                            mainContext.globalAlpha = 0.06;
                            mainContext.beginPath();
                            for (let x = -camX; x < maxScreenWidth; x += useWasd ? 60 : 120) {
                                if (x > 0) {
                                    mainContext.moveTo(x, 0);
                                    mainContext.lineTo(x, maxScreenHeight);
                                }
                            }
                            for (let y = -camY; y < maxScreenHeight; y += useWasd ? 60 : 120) {
                                if (y > 0) {
                                    mainContext.moveTo(0, y);
                                    mainContext.lineTo(maxScreenWidth, y);
                                }
                            }
                            mainContext.stroke();

                        }
                        if (player) {

                            // DEATH LOCATION:
                            if (lastDeath) {
                                mainContext.globalAlpha = 1;
                                mainContext.fillStyle = "#fc5553";
                                mainContext.font = "100px Hammersmith One";
                                mainContext.textBaseline = "middle";
                                mainContext.textAlign = "center";
                                mainContext.fillText("x", lastDeath.x - xOffset, lastDeath.y - yOffset);
                            }
                        }

                        // RENDER DEAD PLAYERS:
                        mainContext.globalAlpha = 1;
                        mainContext.strokeStyle = outlineColor;
                        renderDeadPlayers(xOffset, yOffset);

                        // RENDER BOTTOM LAYER:
                        mainContext.globalAlpha = 1;
                        mainContext.strokeStyle = outlineColor;
                        renderGameObjects(-1, xOffset, yOffset);

                        // RENDER PROJECTILES:
                        mainContext.globalAlpha = 1;
                        mainContext.lineWidth = outlineWidth;
                        renderProjectiles(0, xOffset, yOffset);

                        // RENDER PLAYERS:
                        instaRingTime += delta / 1000;
                        renderPlayers(xOffset, yOffset, 0);

                        // RENDER AI:
                        mainContext.globalAlpha = 1;
                        for (let i = 0; i < ais.length; ++i) {
                            tmpObj = ais[i];
                            if (tmpObj.active && tmpObj.visible) {
                                tmpObj.animate(delta);
                                mainContext.save();
                                mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                mainContext.rotate(tmpObj.dir + tmpObj.dirPlus - (Math.PI / 2));
                                renderAI(tmpObj, mainContext);
                                mainContext.restore();
                            }
                        }

                        // RENDER GAME OBJECTS (LAYERED):
                        renderGameObjects(0, xOffset, yOffset);
                        renderProjectiles(1, xOffset, yOffset);
                        renderGameObjects(1, xOffset, yOffset);
                        renderPlayers(xOffset, yOffset, 1);
                        renderGameObjects(2, xOffset, yOffset);
                        renderGameObjects(3, xOffset, yOffset);

                        // MAP BOUNDARIES:
                        mainContext.fillStyle = "#000";
                        mainContext.globalAlpha = 0.09;
                        if (xOffset <= 0) {
                            mainContext.fillRect(0, 0, -xOffset, maxScreenHeight);
                        } if (config.mapScale - xOffset <= maxScreenWidth) {
                            let tmpY = Math.max(0, -yOffset);
                            mainContext.fillRect(config.mapScale - xOffset, tmpY, maxScreenWidth - (config.mapScale - xOffset), maxScreenHeight - tmpY);
                        } if (yOffset <= 0) {
                            mainContext.fillRect(-xOffset, 0, maxScreenWidth + xOffset, -yOffset);
                        } if (config.mapScale - yOffset <= maxScreenHeight) {
                            let tmpX = Math.max(0, -xOffset);
                            let tmpMin = 0;
                            if (config.mapScale - xOffset <= maxScreenWidth)
                                tmpMin = maxScreenWidth - (config.mapScale - xOffset);
                            mainContext.fillRect(tmpX, config.mapScale - yOffset,
                                                 (maxScreenWidth - tmpX) - tmpMin, maxScreenHeight - (config.mapScale - yOffset));
                        }
                        if (tracker.draw4.active) {//for players
                            mainContext.globalAlpha = 1;
                            let obj = {
                                x: tracker.draw4.x - xOffset,
                                y: tracker.draw4.y - yOffset,
                                scale: tracker.draw4.scale,
                            };
                            mainContext.strokeStyle = "#00FFFF";
                            mainContext.beginPath();
                            mainContext.arc(near.x2, near.y2, near.scale, 0, 2 * Math.PI);
                            mainContext.stroke();
                        }

                        if (tracker.draw3.active) {//fill
                            mainContext.globalAlpha = 0.35;
                            let obj = {
                                x: tracker.draw3.x - xOffset,
                                y: tracker.draw3.y - yOffset,
                                scale: tracker.draw3.scale,
                            };
                            mainContext.strokeStyle = "#FF0000";
                            mainContext.fillStyle = "#FF0000";
                            mainContext.beginPath();
                            mainContext.arc(obj.x, obj.y, obj.scale, 0, 2 * Math.PI);
                            mainContext.fill();
                        }
                        if (tracker.draw2.active) {//outline
                            mainContext.globalAlpha = 1;
                            let obj = {
                                x: tracker.draw2.x - xOffset,
                                y: tracker.draw2.y - yOffset,
                                scale: tracker.draw2.scale,
                            };
                            mainContext.strokeStyle = "#ffff00";
                            mainContext.beginPath();
                            mainContext.arc(obj.x, obj.y, obj.scale, 0, 2 * Math.PI);
                            mainContext.stroke();
                        }
                        if (tracker.draw1.active) {
                            mainContext.globalAlpha = 1;
                            let obj = {
                                x: tracker.draw1.x - xOffset,
                                y: tracker.draw1.y - yOffset,
                                scale: 5
                            };
                            mainContext.fillStyle = "#00FFFF";
                            mainContext.beginPath();
                            mainContext.arc(obj.x, obj.y, obj.scale, 0, 2 * Math.PI);
                            mainContext.fill();
                        }


                        // RENDER DAY/NIGHT TIME:
                        mainContext.globalAlpha = 1;
                        mainContext.fillStyle = "rgba(0, 0, 70, 0.35)";
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);

                        // RENDER PLAYER AND AI UI:
                        mainContext.strokeStyle = darkOutlineColor;
                        mainContext.globalAlpha = 1;
                        for (let i = 0; i < players.length + ais.length; ++i) {
                            tmpObj = players[i] || ais[i - players.length];
                            if (tmpObj.visible) {
                                mainContext.strokeStyle = darkOutlineColor;

                                // NAME AND HEALTH:
                                if (tmpObj.skinIndex != 10 || (tmpObj==player) || (tmpObj.team && tmpObj.team==player.team)) {
                                    let tmpText = (tmpObj.team&&showTeams?"["+(tmpObj.team&&isBadText(tmpObj.team)?"noname":tmpObj.team)+"] ":"")+((isBadText(tmpObj.name)?"Badunknown":tmpObj.name)||"")+(tmpObj.isPlayer?" {"+tmpObj.sid+"}":"");
                                    if (configs.names) {
                                        mainContext.font = (tmpObj.nameScale||30) + "px Hammersmith One";
                                        mainContext.fillStyle = "#fff";
                                        mainContext.textBaseline = "middle";
                                        mainContext.textAlign = "center";
                                        mainContext.lineWidth = (tmpObj.nameScale?11:8);
                                        mainContext.lineJoin = "round";
                                        mainContext.strokeText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset - tmpObj.scale) - config.nameY);
                                        mainContext.fillText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset - tmpObj.scale) - config.nameY);
                                        if (tmpObj.isLeader && iconSprites["crown"].isLoaded) {
                                            let tmpS = config.crownIconScale;
                                            let tmpX = tmpObj.x - xOffset - (tmpS/2) - (mainContext.measureText(tmpText).width / 2) - config.crownPad;
                                            mainContext.drawImage(iconSprites["crown"], tmpX, (tmpObj.y - yOffset - tmpObj.scale)
                                                                  - config.nameY - (tmpS/2) - 5, tmpS, tmpS);
                                        } if (tmpObj.iconIndex == 1 && iconSprites["skull"].isLoaded) {
                                            let tmpS = config.crownIconScale;
                                            let tmpX = tmpObj.x - xOffset - (tmpS/2) + (mainContext.measureText(tmpText).width / 2) + config.crownPad;
                                            mainContext.drawImage(iconSprites["skull"], tmpX, (tmpObj.y - yOffset - tmpObj.scale)
                                                                  - config.nameY - (tmpS/2) - 5, tmpS, tmpS);
                                        } if (tmpObj.isPlayer && instaC.wait && near == tmpObj && (tmpObj.backupNobull ? crossHairSprites[1].isLoaded : crossHairSprites[0].isLoaded) && enemy.length && !useWasd) {
                                            let tmpS = tmpObj.scale * 2.2;
                                            mainContext.drawImage((tmpObj.backupNobull ? crossHairSprites[1] : crossHairSprites[0]), tmpObj.x - xOffset - tmpS / 2, tmpObj.y - yOffset - tmpS / 2, tmpS, tmpS);
                                        }
                                    } if (tmpObj.health > 0) {

                                        // HEALTH HOLDER:
                                        mainContext.fillStyle = darkOutlineColor;
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                                                              (tmpObj.y - yOffset + tmpObj.scale) + config.nameY, (config.healthBarWidth * 2) +
                                                              (config.healthBarPad * 2), 17, 8);
                                        mainContext.fill();

                                        // HEALTH BAR:
                                        mainContext.fillStyle = (tmpObj==player||(tmpObj.team&&tmpObj.team==player.team))?"#8ecc51":"#cc5151";
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                                              (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + config.healthBarPad,
                                                              ((config.healthBarWidth * 2) * (tmpObj.health / tmpObj.maxHealth)), 17 - config.healthBarPad * 2, 7);
                                        mainContext.fill();

                                        if (tmpObj.isPlayer) {

                                            /*        mainContext.globalAlpha = 1;

                                        if (getEl("visualType").value == "ueh1") {
                                            let reloads = {
                                                primary: (tmpObj.primaryIndex == undefined ? 1 : ((items.weapons[tmpObj.primaryIndex].speed - tmpObj.reloads[tmpObj.primaryIndex]) / items.weapons[tmpObj.primaryIndex].speed)),
                                                secondary: (tmpObj.secondaryIndex == undefined ? 1 : ((items.weapons[tmpObj.secondaryIndex].speed - tmpObj.reloads[tmpObj.secondaryIndex]) / items.weapons[tmpObj.secondaryIndex].speed)),
                                                turret: (2500 - tmpObj.reloads[53]) / 2500
                                            };

                                            // SECONDARY RELOAD HOLDER:
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarPad,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 13, config.healthBarWidth +
                                                                  (config.healthBarPad * 2), 17, 8);
                                            mainContext.fill();

                                            // SECONDARY RELOAD BAR:
                                            mainContext.fillStyle = "#90ee90";
                                            mainContext.roundRect(tmpObj.x - xOffset,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 13 + config.healthBarPad,
                                                                  (config.healthBarWidth * reloads.secondary), 17 - config.healthBarPad * 2, 7);
                                            mainContext.fill();

                                            // PRIMARY RELOAD HOLDER:
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 13, config.healthBarWidth +
                                                                  (config.healthBarPad * 2), 17, 8);
                                            mainContext.fill();

                                            // PRIMARY RELOAD BAR:
                                            mainContext.fillStyle = "#90ee90";
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 13 + config.healthBarPad,
                                                                  (config.healthBarWidth * reloads.primary), 17 - config.healthBarPad * 2, 7);
                                            mainContext.fill();
                                        } else {
                                            mainContext.fillStyle = "#99ff99";
                                            if (tmpObj.primaryIndex == undefined ? false : (tmpObj.reloads[tmpObj.primaryIndex] > 0)) {
                                                // PRIMARY RELOAD BAR:
                                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                                                      (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + config.healthBarPad,
                                                                      (config.healthBarWidth * (tmpObj.reloads[tmpObj.primaryIndex] / items.weapons[tmpObj.primaryIndex].speed)), 17 - config.healthBarPad * 2, 7);
                                                mainContext.fill();
                                            }
                                            if (tmpObj.secondaryIndex == undefined ? false : (tmpObj.reloads[tmpObj.secondaryIndex] > 0)) {
                                                // SECONDARY RELOAD BAR:
                                                mainContext.roundRect(tmpObj.x - xOffset + (config.healthBarWidth * ((items.weapons[tmpObj.secondaryIndex].speed - tmpObj.reloads[tmpObj.secondaryIndex]) / items.weapons[tmpObj.secondaryIndex].speed)),
                                                                      (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + config.healthBarPad,
                                                                      (config.healthBarWidth * (tmpObj.reloads[tmpObj.secondaryIndex] / items.weapons[tmpObj.secondaryIndex].speed)), 17 - config.healthBarPad * 2, 7);
                                                mainContext.fill();
                                            }

                                        }
*/
                                            if (tmpObj == player) {

                                                /*
                                            // TURRET RELOAD HOLDER:
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + 13, (config.healthBarWidth * 2) +
                                                                  (config.healthBarPad * 2), 17, 8);
                                            mainContext.fill();

                                            // TURRET RELOAD BAR:
                                            mainContext.fillStyle = "#cc5151";
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + 13 + config.healthBarPad,
                                                                  ((config.healthBarWidth * 2) * tmpObj.reloads.turret), 17 - config.healthBarPad * 2, 7);
                                            mainContext.fill();

*/
                                                // RENDER DIR:
                                                /* if (tmpObj.dir != undefined) {
                                                mainContext.fillStyle = "#fff";
                                                mainContext.globalAlpha = 0.75;
                                                renderCircle(tmpObj.x + (Math.cos(tmpObj.dir) * items.weapons[player.weapons[0]].range) - xOffset, tmpObj.y + (Math.sin(tmpObj.dir) * items.weapons[player.weapons[0]].range) - yOffset, 5, mainContext, true, false);
                                            }
*/
                                            }

                                            // UNDER TEXT:
                                            /* mainContext.globalAlpha = 1;
                                        mainContext.font = "20px Hammersmith One";
                                        mainContext.fillStyle = "#fff";
                                        mainContext.strokeStyle = darkOutlineColor;
                                        mainContext.textBaseline = "middle";
                                        mainContext.textAlign = "center";
                                        mainContext.lineWidth = 8;
                                        mainContext.lineJoin = "round";
                                        let text = [];
                                        if (tmpObj == player) {
                                            if (getEl("visualType").value == "ueh1") {
                                                text = [tmpObj.oldSkinIndex, tmpObj.skinIndex];
                                                mainContext.strokeText("[" + text.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                                mainContext.fillText("[" + text.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            }
                                        } else {
                                            text = [tmpObj.primaryIndex, (tmpObj.secondaryIndex || 0), UTILS.fixTo(tmpObj.damageThreat, 2)];
                                            mainContext.strokeText("[" + text.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            mainContext.fillText("[" + text.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                        }*/

                                            // SHAME COUNT:
                                            if (configs.names) {
                                                mainContext.globalAlpha = 1;
                                                mainContext.font = "30px Hammersmith One";
                                                mainContext.fillStyle = "#fff";
                                                mainContext.strokeStyle = darkOutlineColor;
                                                mainContext.textBaseline = "middle";
                                                mainContext.textAlign = "center";
                                                mainContext.lineWidth = 8;
                                                mainContext.lineJoin = "round";
                                                let tmpS = config.crownIconScale;
                                                let tmpX = tmpObj.x - xOffset - tmpS / 2 + mainContext.measureText(tmpText).width / 2 + config.crownPad + (tmpObj.iconIndex == 1 ? 30 * 2.75 : 30);
                                                mainContext.strokeText(tmpObj.skinIndex == 45 && tmpObj.shameTimer > 0 ? tmpObj.shameTimer : tmpObj.shameCount, tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                                mainContext.fillText(tmpObj.skinIndex == 45 && tmpObj.shameTimer > 0 ? tmpObj.shameTimer : tmpObj.shameCount, tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                            }
                                            if (configs.autoOneFrame && autoOneFrameToggled) {
                                                let ping = unsafeWindow.pingTime;
                                                let range = (ping > 140) ? 230 : (ping > 110) ? 210 : (ping > 85) ? 190 : 170;
                                                mainContext.save();
                                                mainContext.globalAlpha = 0.1;
                                                mainContext.strokeStyle = 'black';
                                                mainContext.lineWidth = 2;
                                                mainContext.translate(player.x - xOffset, player.y - yOffset);
                                                mainContext.beginPath();
                                                mainContext.arc(0, 0, range, 0, Math.PI * 2);
                                                mainContext.stroke();
                                                mainContext.restore();

                                            }

                                            // PLAYER TRACER:
                                            if (!tmpObj.isTeam(player)) {
                                                let playerDistance = UTILS.getDistance(player.x, player.y, tmpObj.x, tmpObj.y);
                                                let alpha = Math.min(1, (playerDistance * 100) / (config.maxScreenHeight / 2) / (screenHeight / 2));

                                                let minDist = playerDistance / 2;
                                                let maxDist = playerDistance + 100;
                                                let dist = Math.max(minDist, maxDist - (playerDistance * (maxDist - minDist) / config.maxScreenHeight));

                                                let angle = UTILS.getDirect(tmpObj, player, 0, 0);
                                                let tmpX = dist * Math.cos(angle);
                                                let tmpY = dist * Math.sin(angle);

                                                mainContext.save();
                                                mainContext.translate((player.x - xOffset) + tmpX, (player.y - yOffset) + tmpY);
                                                let tmpDir = tmpObj.dir || 0;
                                                mainContext.rotate(tmpDir + tmpObj.dirPlus);
                                                mainContext.globalAlpha = alpha * 0.5;
                                                renderPlayer(tmpObj, mainContext);
                                                mainContext.restore();
                                            }


                                            if (getEl("predictType").value == "pre2") {
                                                mainContext.lineWidth = 3;
                                                mainContext.strokeStyle = "#cc5151";
                                                mainContext.globalAlpha = 1;
                                                mainContext.beginPath();
                                                let render = {
                                                    x: tmpObj.x2 - xOffset,
                                                    y: tmpObj.y2 - yOffset
                                                };
                                                mainContext.moveTo(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                                mainContext.lineTo(render.x, render.y);
                                                mainContext.stroke();
                                            } else if (getEl("predictType").value == "pre3") {
                                                mainContext.lineWidth = 3;
                                                mainContext.strokeStyle = "#cc5151";
                                                mainContext.globalAlpha = 1;
                                                mainContext.beginPath();
                                                let render = {
                                                    x: tmpObj.x3 - xOffset,
                                                    y: tmpObj.y3 - yOffset
                                                };
                                                mainContext.moveTo(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                                mainContext.lineTo(render.x, render.y);
                                                mainContext.stroke();
                                            }
                                            else if (getEl("predictType").value == "pre4") {
                                                mainContext.lineWidth = 3;
                                                mainContext.strokeStyle = "#cc5151";
                                                mainContext.globalAlpha = 1;
                                                mainContext.beginPath();
                                                let render = {
                                                    x: tmpObj.x4 - xOffset,
                                                    y: tmpObj.y4 - yOffset
                                                };
                                                mainContext.moveTo(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                                mainContext.lineTo(render.x, render.y);
                                                mainContext.stroke();
                                            }
                                            else if (getEl("predictType").value == "pre5") {
                                                mainContext.lineWidth = 3;
                                                mainContext.strokeStyle = "#cc5151";
                                                mainContext.globalAlpha = 1;
                                                mainContext.beginPath();
                                                let render = {
                                                    x: tmpObj.x5 - xOffset,
                                                    y: tmpObj.y5 - yOffset
                                                };
                                                mainContext.moveTo(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                                mainContext.lineTo(render.x, render.y);
                                                mainContext.stroke();
                                            }

                                        }
                                    }
                                }
                            }
                        }

                        if (player) {
                            mainContext.globalAlpha = 1;
                            if (my.autoPush) {
                                mainContext.lineWidth = 4.5;
                                mainContext.strokeStyle = "#fff";
                                mainContext.beginPath();
                                //  mainContext.moveTo(player.x - xOffset, player.y - yOffset);
                                mainContext.lineTo(my.pushLine.x2 - xOffset, my.pushLine.y2 - yOffset);
                                mainContext.lineTo(my.pushLine.x - xOffset, my.pushLine.y - yOffset);
                                mainContext.stroke();
                            }
                            if (false&&my.autoPush && my.pushLine && my.pushLine !== Infinity) {
                                const {
                                    start:  { x2: sx2,  y2: sy2 },
                                    entry:  { x2: exi2, y2: eyi2 },
                                    center: { x2: cx2,  y2: cy2 },
                                    exit:   { x2: ex2,  y2: ey2 },
                                    radius,
                                    entryAng,
                                    exitAng,
                                    ccw
                                } = my.pushLine;

                                // apply camera pan offset
                                const sx  = sx2  - xOffset, sy  = sy2  - yOffset;
                                const exi = exi2 - xOffset, eyi = eyi2 - yOffset;
                                const cx  = cx2  - xOffset, cy  = cy2  - yOffset;
                                const ex  = ex2  - xOffset, ey  = ey2  - yOffset;

                                // 1) straight from player → entryPt
                                mainContext.beginPath();
                                mainContext.moveTo(sx, sy);
                                mainContext.lineTo(exi, eyi);
                                mainContext.lineWidth   = 4.5;
                                mainContext.strokeStyle = "#fcba03";
                                mainContext.stroke();

                                // 2) arc around the enemy
                                mainContext.beginPath();
                                mainContext.arc(cx, cy, radius, entryAng, exitAng, ccw);
                                mainContext.lineWidth   = 4.5;
                                mainContext.strokeStyle = "#fff";
                                mainContext.stroke();

                                // 3) straight from circle‐exit → final exit
                                // compute the actual end of the arc on the circle:
                                const arcEndX = cx + radius * Math.cos(exitAng);
                                const arcEndY = cy + radius * Math.sin(exitAng);
                                mainContext.beginPath();
                                mainContext.moveTo(arcEndX, arcEndY);
                                mainContext.lineTo(ex, ey);
                                mainContext.lineWidth   = 4.5;
                                mainContext.strokeStyle = "#a539d4";
                                mainContext.stroke();
                            }




                            const ctx = mainContext;
                            const xo  = xOffset || 0;
                            const yo  = yOffset || 0;
                            try{_things.pushPos=null;drawPushGuideWithArc(ctx,xo,yo)}catch(err){console.warn(err)}
                            if(_things.pushPos){
                                ctx.beginPath();
                                ctx.strokeStyle = "#00ff00";
                                ctx.lineWidth   = 2;
                                ctx.moveTo(player.x2 - xo, player.y2 - yo);
                                ctx.lineTo(_things.pushPos.x - xo, _things.pushPos.y - yo);
                            }
                            // 1️⃣ Enemy circle
                            if (_things.enemy.enemy) {
                                const en  = _things.enemy.enemy;
                                const wep = weapons.find(w => w.id === (en.primaryIndex || 5))||{};
                                const enR = (wep.range || 0) + en.scale + 25;
                                const ex  = en.x - xo;
                                const ey  = en.y - yo;

                                ctx.beginPath();
                                ctx.strokeStyle = "#00ff00";
                                ctx.lineWidth   = 2;
                                ctx.arc(ex, ey, enR, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            // 2️⃣ Spike circle
                            if (_things.enemyKBI) {
                                const sp = _things.enemyKBI;
                                const sx = sp.x - xo;
                                const sy = sp.y - yo;

                                ctx.beginPath();
                                ctx.strokeStyle = "#a539d4";
                                ctx.lineWidth   = 4;
                                ctx.arc(sx, sy, sp.scale, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                            bestEsc=null;
                            // 3️⃣ Player circle + pie arc + dodge “Y”

                            if (_things.enemy.enemy && _things.enemyKBI) {
                                const sp = _things.enemyKBI;
                                const en = _things.enemy.enemy;
                                const pl = player;

                                // canvas coords
                                const sx = sp.x - xo, sy = sp.y - yo;
                                const ex = en.x - xo, ey = en.y - yo;
                                const px = pl.x2 - xo, py = pl.y2 - yo;
                                // compute minimal player-circle radius to overlap both
                                const wep   = weapons.find(w => w.id === (en.primaryIndex || 5))||{};
                                const enR   = (wep.range || 0) + en.scale + 25;
                                const spR   = sp.scale;
                                const dEnPl = UTILS.getDist(en, pl, 0, 0);
                                const dSpPl = UTILS.getDist(sp, pl, 0, 0);
                                const plR   = Math.max(dEnPl - enR, dSpPl - spR, 0) + 5;

                                // — draw player circle
                                ctx.beginPath();
                                ctx.strokeStyle = "#ffff00";
                                ctx.lineWidth   = 2;
                                ctx.arc(px, py, plR, 0, Math.PI * 2);
                                ctx.stroke();

                                // — compute angles to enemy & spike
                                const angEn = Math.atan2(ey - py, ex - px);
                                const angSp = Math.atan2(sy - py, sx - px);

                                // — draw radii lines
                                ctx.beginPath();
                                ctx.moveTo(px, py);
                                ctx.lineTo(ex, ey);
                                ctx.moveTo(px, py);
                                ctx.lineTo(sx, sy);
                                ctx.strokeStyle = "#ffffff";
                                ctx.lineWidth   = 1;
                                ctx.stroke();

                                // — draw the “pie” arc
                                ctx.beginPath();
                                ctx.strokeStyle = "rgba(255,255,255,0.7)";
                                ctx.lineWidth   = 3;
                                ctx.arc(px, py, plR - 10, angEn, angSp, false);
                                ctx.stroke();

                                // — now draw dodge “Y” and highlight best spoke
                                const baseAngle = Math.atan2(py - sy, px - sx);
                                const spread    = Math.PI / 4;               // ±45°
                                const offsets   = [0, +spread, -spread];
                                const diveDist  = plR + 20;                  // length of each spoke

                                // pick best path (farthest from enemy)
                                let bestIdx = 0, bestDist = -Infinity;
                                offsets.forEach((off, i) => {
                                    const ang  = baseAngle + off;
                                    const cx   = px + Math.cos(ang) * diveDist;
                                    const cy   = py + Math.sin(ang) * diveDist;
                                    const dist = Math.hypot(cx - ex, cy - ey);
                                    if (dist > bestDist) {
                                        bestDist = dist;
                                        bestIdx  = i;
                                    }
                                });

                                // draw all three spokes
                                offsets.forEach((off, i) => {
                                    const ang  = baseAngle + off;
                                    const ex2  = px + Math.cos(ang) * diveDist;
                                    const ey2  = py + Math.sin(ang) * diveDist;

                                    ctx.beginPath();
                                    ctx.moveTo(px, py);
                                    ctx.lineTo(ex2, ey2);

                                    if (i === bestIdx) {
                                        ctx.setLineDash([]);
                                        ctx.strokeStyle = "#00ff00";   // best = green solid
                                        bestEsc=getDirection({x:px,y:py},{x:ex2,y:ey2});
                                    } else {
                                        ctx.setLineDash([5,5]);
                                        ctx.strokeStyle = "rgba(255,255,255,0.8)"; // others = dashed white
                                    }
                                    ctx.lineWidth = 2;
                                    ctx.stroke();
                                });
                                ctx.setLineDash([]); // reset dashing
                            }
                            !function(){
                                let willDieP = null;
                                let willDie = false;
                                const min = 2, max = 5;
                                let Index;

                                // Try every offset combo
                                outer: for (let i = min; i <= max; i++) {
                                    for (let j = min; j <= max; j++) {
                                        let result = knockBackPredictEnemyToPlayer(String(i), String(j));
                                        if (result) {
                                            willDieP = result; // { x, y }
                                            Index = [i, j].join(':');
                                            willDie = true;
                                            break outer; // Stop at first possible lethal prediction
                                        }
                                    }
                                }

                                // Fallback/default (empty string case)
                                try {
                                    let result = knockBackPredictEnemyToPlayer('', '');
                                    if (result) {
                                        willDieP = result;
                                        willDie = true;
                                        Index = 'None';
                                    }
                                } catch {}

                                if (willDie && _things.enemy.enemy) {
                                    _things.moveNOW = null;
                                    //addMenuChText('[NOW]', 'you will DIE', 'red');

                                    // Draw DANGER warning at player location
                                    ctx.fillText(`DANGER! - ${Index}`, player.x - (xOffset || 0), player.y - (yOffset || 0) + 30);

                                    // Draw marker at predicted collision location!
                                    if (willDieP && willDieP.x !== undefined && willDieP.y !== undefined) {
                                        ctx.save();
                                        ctx.beginPath();
                                        ctx.arc(willDieP.x - (xOffset || 0), willDieP.y - (yOffset || 0), 24, 0, 2 * Math.PI); // Big warning circle
                                        ctx.strokeStyle = "#ff004c";
                                        ctx.lineWidth = 4;
                                        ctx.stroke();

                                        ctx.font = "bold 16px Arial";
                                        ctx.fillStyle = "#ff004c";
                                        ctx.fillText("💀", willDieP.x - (xOffset || 0) - 12, willDieP.y - (yOffset || 0) + 6); // Emoji or text marker
                                        ctx.restore();
                                    }

                                    // Optional: auto-escape logic
                                    if (bestEsc) _things.moveNOW = bestEsc;
                                }
                                else _things.moveNOW=null
                            }
                            let willDieData = null;
                            let willDie = false;
                            const min = 2, max = 5;
                            let Index;

                            // Try every combo
                            outer: for (let i = min; i <= max; i++) {
                                for (let j = min; j <= max; j++) {
                                    let result = knockBackPredictEnemyToPlayer(String(i), String(j));
                                    if (result && result.willDie) {
                                        willDieData = result;
                                        Index = [i, j].join(':');
                                        willDie = true;
                                        break outer;
                                    }
                                }
                            }

                            // Fallback default check
                            try {
                                let result = knockBackPredictEnemyToPlayer('', '');
                                if (result && result.willDie) {
                                    willDieData = result;
                                    willDie = true;
                                    Index = 'None';
                                }
                            } catch { }

                            if (willDie && willDieData) {
                                _things.moveNOW = null;
                                ctx.fillText(`DANGER! - ${Index}`, player.x - (xOffset || 0), player.y - (yOffset || 0) + 30);

                                // Draw DANGER circle for every hit position
                                ctx.save();
                                ctx.beginPath();
                                ctx.arc(willDieData.hitPos.x - (xOffset || 0), willDieData.hitPos.y - (yOffset || 0), 24, 0, 2 * Math.PI);
                                ctx.strokeStyle = "#ff004c";
                                ctx.lineWidth = 4;
                                ctx.stroke();

                                // Draw the spike/trap
                                if (willDieData.lethalObj) {
                                    ctx.beginPath();
                                    ctx.arc(willDieData.lethalObj.x - (xOffset || 0), willDieData.lethalObj.y - (yOffset || 0), willDieData.lethalObj.scale || 18, 0, 2 * Math.PI);
                                    ctx.strokeStyle = "#ff0000";
                                    ctx.setLineDash([6, 4]);
                                    ctx.stroke();
                                    ctx.setLineDash([]);
                                }

                                // Draw all knockback points
                                let indc = willDieData.KBIndc;
                                for (let key of ['x0', 'y0', 'x1', 'y1', 'instax', 'instay', 'turretx', 'turrety']) {
                                    if (indc[key] !== undefined && !isNaN(indc[key])) {
                                        ctx.beginPath();
                                        ctx.arc(indc[key] - (xOffset || 0), indc[key.replace('x', 'y')] - (yOffset || 0), 24, 0, 2 * Math.PI);
                                        ctx.strokeStyle = "#f00";
                                        ctx.stroke();
                                    }
                                }

                                ctx.restore();
                                ctx.font = "bold 16px Arial";
                                ctx.fillStyle = "#ff004c";
                                ctx.fillText("💀", willDieData.hitPos.x - (xOffset || 0) - 12, willDieData.hitPos.y - (yOffset || 0) + 6);

                                if (bestEsc) _things.moveNOW = bestEsc;
                            }
                            _things.trap // {x,y,getScale()}
                            _things.pos1 // {x,y,scale}
                            if (_things.trap&&false) {
                                const trap = _things.trap;
                                const en   = _things.enemy.enemy;
                                const px0  = player.x2, py0 = player.y2;

                                // ── 1) draw trap circle with correct radius
                                const trapR = trap.scale;                     // ← use trap.scale not getScale()
                                const tx    = trap.x - xo;
                                const ty    = trap.y - yo;
                                ctx.beginPath();
                                ctx.strokeStyle = "#ff00ff";
                                ctx.lineWidth   = 2;
                                ctx.arc(tx, ty, trapR, 0, Math.PI*2);
                                ctx.stroke();

                                if (en) {
                                    // ── 2) find the boundary point on the trap nearest the enemy
                                    const toEnAng  = Math.atan2(en.y - trap.y, en.x - trap.x);
                                    const boundX   = trap.x + Math.cos(toEnAng) * trapR;
                                    const boundY   = trap.y + Math.sin(toEnAng) * trapR;

                                    // ── 3) behind that boundary point
                                    const behindAng = toEnAng + Math.PI;
                                    const buffer    = 5; // extra gap if you want (no cap)
                                    const posX      = boundX + Math.cos(behindAng) * (player.scale + buffer);
                                    const posY      = boundY + Math.sin(behindAng) * (player.scale + buffer);

                                    // save for pathing
                                    _things.pos1 = { x: posX, y: posY, scale: player.scale };

                                    // draw your “safe-spot” circle
                                    const px = posX - xo, py = posY - yo;
                                    ctx.beginPath();
                                    ctx.strokeStyle = "#00ffff";
                                    ctx.lineWidth   = 2;
                                    ctx.arc(px, py, player.scale, 0, Math.PI*2);
                                    ctx.stroke();
                                }
                            }
                            const path = _things.path||{};
                            if (path.length) {
                                ctx.beginPath();
                                ctx.lineWidth   = player.scale;               // path width = player.scale
                                ctx.strokeStyle = "rgba(0,255,0,0.7)";
                                ctx.moveTo(player.x2 - xo, player.y2 - yo);

                                if (path.length === 1) {
                                    const p = path[0];
                                    ctx.lineTo(p.x - xo, p.y - yo);
                                } else {
                                    // curve around enemy
                                    const [ctrl, tgt] = path;
                                    ctx.quadraticCurveTo(
                                        ctrl.x - xo, ctrl.y - yo,
                                        tgt.x  - xo, tgt.y  - yo
                                    );
                                }
                                ctx.stroke();
                            }

                            // ── 2) Frame‐by‐frame render loop (only draws if pathVisual exists):
                            const v = _things.pathVisual;
                            if (v) {
                                const en=_things.enemy.enemy
                                ctx.beginPath();
                                ctx.lineWidth   = 2;              // scale*2 wide
                                ctx.strokeStyle = "rgba(0,255,0,0.7)";

                                // P₀→P₁
                                ctx.moveTo(v.p0.x - xo, v.p0.y - yo);
                                ctx.lineTo(v.p1.x - xo, v.p1.y - yo);

                                // arc around enemy center
                                ctx.arc(
                                    en.x - xo, en.y - yo,
                                    v.arcR,
                                    v.a0,
                                    v.a2,
                                    false
                                );

                                // P₂ line
                                ctx.lineTo(v.p2.x - xo, v.p2.y - yo);
                                ctx.stroke();
                            }

                            if (pathFind.active && pathFind.array && (pathFind.chaseNear ? enemy.length : true)) {
                                mainContext.lineWidth = 4.5;
                                mainContext.strokeStyle = "cyan";
                                mainContext.beginPath();
                                pathFind.array.forEach((path, i) => {
                                    let pathXY = {
                                        x: (pathFind.scale / pathFind.grid) * path.x,
                                        y: (pathFind.scale / pathFind.grid) * path.y
                                    };
                                    let render = {
                                        x: ((player.x2 - (pathFind.scale / 2)) + pathXY.x) - xOffset,
                                        y: ((player.y2 - (pathFind.scale / 2)) + pathXY.y) - yOffset
                                    };
                                    if (i == 0) {
                                        mainContext.moveTo(render.x, render.y);
                                    } else {
                                        mainContext.lineTo(render.x, render.y);
                                    }
                                });
                                mainContext.stroke();
                            }
                            // FUNNY:
                            if (petals.length && getEl("funni").checked) {

                                player.spinDir += 2.5 / 60;
                                let maxRad = 0;
                                if (clicks.left) {
                                    maxRad = 100;
                                } else if (clicks.right) {
                                    maxRad = 15;
                                } else {
                                    maxRad = 40;
                                }
                                maxRad += player.scale;

                                petals.forEach((petal, i) => {
                                    if (petal.active) {
                                        let petalRad = (Math.PI * (i / (petals.length / 2)));
                                        let pl = {
                                            x: player.x + (maxRad * Math.cos(player.spinDir + petalRad)),
                                            y: player.y + (maxRad * Math.sin(player.spinDir + petalRad))
                                        };
                                        let angle = UTILS.getDirect(pl, petal, 0, 0);
                                        let dist = UTILS.getDist(pl, petal, 0, 0);
                                        petal.x += (dist / 7) * Math.cos(angle);
                                        petal.y += (dist / 7) * Math.sin(angle);

                                        players.filter((tmp) => tmp.visible && tmp != player).forEach((tmp) => {
                                            let angle = UTILS.getDirect(petal, tmp, 0, 0);
                                            let dist = UTILS.getDist(petal, tmp, 0, 0);
                                            let sc = petal.scale + tmp.scale;
                                            if (dist <= sc) {
                                                let tD = dist - sc;
                                                let diff = -tD;
                                                petal.x += diff * Math.cos(angle);
                                                petal.y += diff * Math.sin(angle);
                                                petal.health -= 10;
                                                petal.damaged += 125;
                                                if (petal.health <= 0) {
                                                    petal.active = false;
                                                }
                                            }
                                        });

                                    } else {
                                        petal.time += delta;

                                        if (petal.alive) {
                                            petal.alpha -= delta / 200;
                                            petal.visScale += delta / (petal.scale * 2);
                                            if (petal.alpha <= 0) {
                                                petal.alpha = 0;
                                                petal.alive = false;
                                            }
                                        }

                                        if (petal.time >= petal.timer) {
                                            petal.time = 0;
                                            petal.active = true;
                                            petal.alive = true;
                                            petal.x = player.x;
                                            petal.y = player.y;
                                            petal.health = petal.maxHealth;
                                            petal.damaged = 0;
                                            petal.alpha = 1;
                                            petal.visScale = petal.scale;
                                        }
                                    }

                                    if (petal.alive) {

                                        let cD = function(r, g, b, dmg) {
                                            return "rgb(" + `${Math.min(255, r + Math.floor(dmg))}, ${Math.max(0, g - Math.floor(dmg))}, ${Math.max(0, b - Math.floor(dmg))}` + ")";
                                        }

                                        mainContext.globalAlpha = petal.alpha;
                                        mainContext.lineWidth = 3;
                                        mainContext.fillStyle = cD(255, 255, 255, petal.damaged);
                                        mainContext.strokeStyle = cD(200, 200, 200, petal.damaged);
                                        mainContext.beginPath();
                                        mainContext.arc(petal.x - xOffset, petal.y - yOffset, petal.visScale, 0, Math.PI * 2);
                                        mainContext.fill();
                                        mainContext.stroke();

                                        petal.damaged = Math.max(0, petal.damaged - (delta / 2));

                                    }

                                });
                            }

                        }

                        mainContext.globalAlpha = 1;

                        // RENDER ANIM TEXTS:
                        textManager.update(delta, mainContext, xOffset, yOffset);
                        let emojis = {
                            joy: "😂",
                            sob: "😭",
                            sus: "🤨",
                            skull: "💀",
                            kiss: "😘",
                            omg: "😲",
                            "500IQ": "🤯",
                            pls: "🥺",
                            horny: "🥵",
                            cold: "🥶",
                            cry: "😢",
                            sorry: "😓",
                            yummy: "😋",
                            angry: "😡",
                            skull: "💀",
                            dizzy: "🥴",
                            party: "🥳",
                            ez: "😎",
                            wink: "😉",
                            flushed: "😳",
                            thumbsup: "👍",
                        };
                        for (let i = 0; i < players.length; ++i) {
                            let player = players[i];
                            if (
                                player.visible &&
                                player.chatMessages &&
                                player.chatMessages.length > 0
                            ) {
                                let tmpX = player.x - xOffset;
                                let baseY = player.y - player.scale - yOffset - 90;
                                let yOffsetIncrement = 50;
                                for (let j = 0; j < player.chatMessages.length; j++) {
                                    let chatObj = player.chatMessages[j];
                                    let chatMessage = chatObj.message;
                                    let tmpY =
                                        baseY - (player.chatMessages.length - 1 - j) * yOffsetIncrement;
                                    if (Date.now() - chatObj.time > 5000) {
                                        player.chatMessages.splice(j, 1);
                                        j--;
                                        continue;
                                    }
                                    mainContext.font = "32px Hammersmith One";
                                    let tmpSize = mainContext.measureText(chatMessage);
                                    mainContext.textBaseline = "middle";
                                    mainContext.textAlign = "center";
                                    let tmpH = 47;
                                    let tmpW = tmpSize.width + 17;
                                    mainContext.fillStyle = "rgba(0,0,0,0.2)";
                                    mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                                    mainContext.fill();
                                    mainContext.fillStyle = "#e3e3e3";
                                    for (let e in emojis) {
                                        chatMessage = chatMessage.replaceAll(":" + e + ":", emojis[e]);
                                    }

                                    mainContext.fillText(chatMessage, tmpX, tmpY);
                                }
                            }
                        }
                        let allChats = [];
                        if (allChats.length) {
                            allChats
                                .filter((ch) => ch.active && ch.owner.isPlayer)
                                .forEach((ch) => {
                                if (!ch.alive) {
                                    if (ch.alpha <= 1) {
                                        ch.alpha += delta / 250;
                                        if (ch.alpha >= 1) {
                                            ch.alpha = 1;
                                            ch.alive = true;
                                        }
                                    }
                                } else {
                                    ch.alpha -= delta / 5000;
                                    if (ch.alpha <= 0) {
                                        ch.alpha = 0;
                                        ch.active = false;
                                    }
                                }
                                if (ch.active) {
                                    mainContext.font = "20px Ubuntu";
                                    let tmpSize = mainContext.measureText(ch.chat);
                                    mainContext.textBaseline = "middle";
                                    mainContext.textAlign = "center";
                                    let tmpX = ch.owner.x - xOffset;
                                    let tmpY = ch.owner.y - ch.owner.scale - yOffset - 90;
                                    let tmpH = 40;
                                    let tmpW = tmpSize.width + 15;
                                    mainContext.globalAlpha = ch.alpha;
                                    mainContext.fillStyle = ch.owner.isTeam(player)
                                        ? "#8ecc51"
                                    : "#cc5151";
                                    mainContext.strokeStyle = "rgb(25, 25, 25)";
                                    mainContext.strokeText(ch.owner.name, tmpX, tmpY - 45);
                                    mainContext.fillText(ch.owner.name, tmpX, tmpY - 45);
                                    mainContext.lineWidth = 5;
                                    mainContext.fillStyle = "#ccc";
                                    mainContext.strokeStyle = "rgb(25, 25, 25)";
                                    mainContext.roundRect(
                                        tmpX - tmpW / 2,
                                        tmpY - tmpH / 2,
                                        tmpW,
                                        tmpH,
                                        6
                                    );
                                    mainContext.stroke();
                                    mainContext.fill();
                                    mainContext.fillStyle = "#fff";
                                    mainContext.strokeStyle = "#000";
                                    mainContext.strokeText(ch.chat, tmpX, tmpY);
                                    mainContext.fillText(ch.chat, tmpX, tmpY);
                                    ch.y -= delta / 100;
                                }
                            });
                        }
                        mainContext.globalAlpha = 1;
                    }

                    // RENDER MINIMAP:
                    renderMinimap(delta);
                }

                // UPDATE & ANIMATE:
                unsafeWindow.requestAnimFrame = function() {
                    return null;
                }
                unsafeWindow.rAF = (function() {
                    return unsafeWindow.requestAnimationFrame ||
                        unsafeWindow.webkitRequestAnimationFrame ||
                        unsafeWindow.mozRequestAnimationFrame ||
                        function(callback) {
                        unsafeWindow.setTimeout(callback, 1000 / 60);
                    };
                })();
                disableRender = 0;

                startRenderLoop = function () {
                    if (!window.disableRender) {
                        rAF(doUpdate); // restart the loop manually
                        console.log("[RenderToggle] Render loop resumed ✅");
                    } else {
                        console.log("[RenderToggle] Cannot start loop while disabled ❌");
                    }
                };
                let viewSid = GM_getValue('viewSid', null);
                GM_addValueChangeListener('viewSid', (_, __, newVal) => {
                    viewSid = newVal;
                });
                const botViewEl = document.createElement('img');
                botViewEl.id = 'botView';
                Object.assign(botViewEl.style, {
                    position: 'fixed',
                    bottom: '10px',
                    right: '10px',
                    width: '200px',
                    height: '150px',
                    zIndex: '9999',
                    border: '2px solid #008f68',
                    background: '#000'
                });
                document.body.appendChild(botViewEl);
                function doUpdate() {
                    getEl("packetStatus").innerHTML = secPacket;
                    //if(disableRender){rAF(doUpdate);return};
                    now = performance.now();
                    delta = now - lastUpdate;
                    lastUpdate = now;

                    let timer = performance.now();
                    let diff = timer - fpsTimer.last;
                    if (diff >= 1000) {

                        fpsTimer.ltime = fpsTimer.time * (1000 / diff);

                        fpsTimer.last = timer;
                        fpsTimer.time = 0;
                    }
                    fpsTimer.time++;

                    //let fakePing = Math.floor(Math.random() * 26) + 100;
                    getEl("pingFps").innerHTML = `${unsafeWindow.pingTime}ms | Fps: ${UTILS.round(fpsTimer.ltime, 10)}`;
                    try {
                        updateGame();

                        // save a snapshot every SAVE_INTERVAL ms
                        const nowFrame = performance.now();
                        if (nowFrame - lastSaveTime >= SAVE_INTERVAL&&autoGo&&GM_getValue('viewSid', null)==player.sid) {
                            const dataURL = mainContext.canvas.toDataURL("image/png");
                            GM_setValue(`${player.sid}-v`, dataURL);
                            lastSaveTime = nowFrame;
                        }


                        // ———> NEW: if we’re in main mode, fetch & show the chosen bot’s image
                        if (!autoGo) {
                            const sid = GM_getValue('viewSid', null);
                            if (sid !== null) {
                                const key = `${sid}-v`;
                                const imgData = GM_getValue(key, null);
                                if (imgData) {
                                    botViewEl.src = imgData;
                                    botViewEl.style.display = 'block';
                                } else {
                                    botViewEl.removeAttribute('src');
                                }
                            } else {
                                botViewEl.removeAttribute('src');
                            }
                        }

                    } catch (e) {
                        console.warn("Render error:", e);
                    }
                    rAF(doUpdate);
                }
                prepareMenuBackground();
                doUpdate();

                function toggleUseless(boolean) {
                    getEl("instaType").disabled = boolean;
                    getEl("antiBullType").disabled = boolean;
                    getEl("predictType").disabled = boolean;
                    getEl("visualType").disabled = boolean;
                }
                toggleUseless(useWasd);

                let changeDays = {};
                unsafeWindow.debug = function() {
                    resetMenuChText();
                    my.waitHit = 0;
                    my.autoAim = false;
                    instaC.isTrue = false;
                    traps.inTrap = false;
                    itemSprites = [];
                    objSprites = [];
                    gameObjectSprites = [];
                };
                unsafeWindow.toggleNight = function() {
                    clearTimeout(changeDays);
                    if (nightMode.style.animationName == "night1") {
                        nightMode.style.animationName = "night2";
                        nightMode.style.opacity = 0;
                        changeDays = setTimeout(() => {
                            nightMode.style.display = "none";
                        }, 1000 * parseFloat(nightMode.style.animationDuration));
                    } else {
                        nightMode.style.animationName = "night1";
                        nightMode.style.opacity = 0.35;
                        nightMode.style.display = "block";
                    }
                    isNight = !isNight;
                    itemSprites = [];
                    objSprites = [];
                    gameObjectSprites = [];
                };
                unsafeWindow.wasdMode = function() {
                    useWasd = !useWasd;
                    toggleUseless(useWasd);
                };
                unsafeWindow.startGrind = function() {
                    if (getEl("weaponGrind").checked) {
                        for (let i = 0; i < Math.PI*2; i+= Math.PI/2) {
                            checkPlace(8, i);
                        }
                    }
                };
                // Define an array of server socket names
                var serversockets = [
                    "hulking-zippy-paneer",
                    "defiant-wealthy-acoustic",
                    "mixolydian-power-gravity",
                    "cake-familiar-cathedral",
                    "nasal-obtainable-ox",
                    "ablaze-fuchsia-handsaw",
                    "best-rust-forsythia",
                    "mud-slow-forest",
                    "tar-shocking-dresser",
                    "tortoiseshell-helpful-sting",
                    "walnut-hammerhead-grape"
                ];
                // REMOVED!!! so they cant abuse :)
                let projects = [...serversockets];
                let botIDS = 0;
                unsafeWindow.connectFillBots = function() {
                    botSkts = [];
                    botIDS = 0;
                    for (let i = 0; i < projects.length; i++) {
                        let test = new WebSocket(`wss://${projects[i]}.glitch.me`);
                        test.binaryType = "arraybuffer";

                        test.onopen = function() {
                            test.ssend = function(type) {
                                let data = Array.prototype.slice.call(arguments, 1);
                                let binary = unsafeWindow.msgpack.encode([type, data]);
                                test.send(binary);
                            };
                            for (let i = 0; i < 4; i++) {
                                getToken__(i.toString()).then(function (token) {
                                    test.ssend("bots", WS.url.split("&")[0] + "&token=" + encodeURIComponent(token), botIDS);
                                    botSkts.push([test]);
                                    botIDS++;
                                });
                            }
                        };
                        test.onmessage = function(message) {
                            let data = new Uint8Array(message.data);
                            let parsed = unsafeWindow.msgpack.decode(data);
                            let type = parsed[0];
                            data = parsed[1];
                        };
                    }
                };
                unsafeWindow.destroyFillBots = function() {
                    botSkts.forEach((socket) => {
                        socket[0].close();
                    });
                    botSkts = [];
                };
                unsafeWindow.tryConnectBots = function() {
                    for (let i = 0; i < (bots.length < 3 ? 3 : 4); i++) {
                        getToken__(i).then(function (token) {
                            // CONNECT SOCKET:
                            botSpawn(token);
                        });
                    }
                };
                unsafeWindow.destroyBots = function() {
                    bots.forEach((botyyyyy)=>{
                        botyyyyy.closeSocket = true;
                    });
                    bots = [];
                };
                unsafeWindow.resBuild = function() {
                    if (gameObjects.length) {
                        gameObjects.forEach((tmp) => {
                            tmp.breakObj = false;
                        });
                        breakObjects = [];
                    }
                };
                unsafeWindow.toggleBotsCircle = function() {
                    player.circle = !player.circle;
                };
                unsafeWindow.toggleVisual = function() {
                    config.anotherVisual = !config.anotherVisual;
                    gameObjects.forEach((tmp) => {
                        if (tmp.active) {
                            tmp.dir = tmp.lastDir;
                        }
                    });
                };
                unsafeWindow.prepareUI = function(tmpObj) {
                    resize();
                    // ACTION BAR:
                    UTILS.removeAllChildren(actionBar);
                    for (let i = 0; i < (items.weapons.length + items.list.length); ++i) {
                        (function(i) {
                            UTILS.generateElement({
                                id: "actionBarItem" + i,
                                class: "actionBarItem",
                                style: "display:none",
                                onmouseout: function() {
                                    showItemInfo();
                                },
                                parent: actionBar
                            });
                        })(i);
                    }
                    for (let i = 0; i < (items.list.length + items.weapons.length); ++i) {
                        (function(i) {
                            let tmpCanvas = document.createElement("canvas");
                            tmpCanvas.width = tmpCanvas.height = 66;
                            let tmpContext = tmpCanvas.getContext("2d");
                            tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                            tmpContext.imageSmoothingEnabled = false;
                            tmpContext.webkitImageSmoothingEnabled = false;
                            tmpContext.mozImageSmoothingEnabled = false;
                            if (items.weapons[i]) {
                                tmpContext.rotate((Math.PI/4)+Math.PI);
                                let tmpSprite = new Image();
                                toolSprites[items.weapons[i].src] = tmpSprite;
                                tmpSprite.onload = function() {
                                    this.isLoaded = true;
                                    let tmpPad = 1 / (this.height / this.width);
                                    let tmpMlt = (items.weapons[i].iPad || 1);
                                    tmpContext.drawImage(this, -(tmpCanvas.width*tmpMlt*config.iconPad*tmpPad)/2, -(tmpCanvas.height*tmpMlt*config.iconPad)/2,
                                                         tmpCanvas.width*tmpMlt*tmpPad*config.iconPad, tmpCanvas.height*tmpMlt*config.iconPad);
                                    tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                                    tmpContext.globalCompositeOperation = "source-atop";
                                    tmpContext.fillRect(-tmpCanvas.width / 2, -tmpCanvas.height / 2, tmpCanvas.width, tmpCanvas.height);
                                    getEl('actionBarItem' + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                                };
                                tmpSprite.src = "./../img/weapons/" + items.weapons[i].src + ".png";
                                let tmpUnit = getEl('actionBarItem' + i);
                                tmpUnit.onmouseover = UTILS.checkTrusted(function() {
                                    showItemInfo(items.weapons[i], true);
                                });
                                tmpUnit.onclick = UTILS.checkTrusted(function() {
                                    selectWeapon(tmpObj.weapons[items.weapons[i].type]);
                                });
                                UTILS.hookTouchEvents(tmpUnit);
                            } else {
                                let tmpSprite = getItemSprite(items.list[i-items.weapons.length], true);
                                let tmpScale = Math.min(tmpCanvas.width - config.iconPadding, tmpSprite.width);
                                tmpContext.globalAlpha = 1;
                                tmpContext.drawImage(tmpSprite, -tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                                tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                                tmpContext.globalCompositeOperation = "source-atop";
                                tmpContext.fillRect(-tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                                getEl('actionBarItem' + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                                let tmpUnit = getEl('actionBarItem' + i);
                                tmpUnit.onmouseover = UTILS.checkTrusted(function() {
                                    showItemInfo(items.list[i - items.weapons.length]);
                                });
                                tmpUnit.onclick = UTILS.checkTrusted(function() {
                                    selectToBuild(tmpObj.items[tmpObj.getItemType(i - items.weapons.length)]);
                                });
                                UTILS.hookTouchEvents(tmpUnit);
                            }
                        })(i);
                    }
                };

                unsafeWindow.profineTest = function(data) {
                    if (data) {
                        // SET INITIAL NAME:
                        let noname = "unknown";

                        // VALIDATE NAME:
                        let name = data + "";
                        name = name.slice(0, config.maxNameLength);
                        name = name.replace(/[^w:\(\)\/? -]+/gmi, " ");  // USE SPACE SO WE CAN CHECK PROFANITY
                        name = name.replace(/[^\x00-\x7F]/g, " ");
                        name = name.trim();

                        let langFilter = {
                            "list": [
                                "ahole",
                                "anus",
                                "ash0le",
                                "ash0les",
                                "asholes",
                                "ass",
                                "Ass Monkey",
                                "Assface",
                                "assh0le",
                                "assh0lez",
                                "asshole",
                                "assholes",
                                "assholz",
                                "asswipe",
                                "azzhole",
                                "bassterds",
                                "bastard",
                                "bastards",
                                "bastardz",
                                "basterds",
                                "basterdz",
                                "Biatch",
                                "bitch",
                                "bitches",
                                "Blow Job",
                                "boffing",
                                "butthole",
                                "buttwipe",
                                "c0ck",
                                "c0cks",
                                "c0k",
                                "Carpet Muncher",
                                "cawk",
                                "cawks",
                                "Clit",
                                "cnts",
                                "cntz",
                                "cock",
                                "cockhead",
                                "cock-head",
                                "cocks",
                                "CockSucker",
                                "cock-sucker",
                                "crap",
                                "cum",
                                "cunt",
                                "cunts",
                                "cuntz",
                                "dick",
                                "dild0",
                                "dild0s",
                                "dildo",
                                "dildos",
                                "dilld0",
                                "dilld0s",
                                "dominatricks",
                                "dominatrics",
                                "dominatrix",
                                "dyke",
                                "enema",
                                "f u c k",
                                "f u c k e r",
                                "fag",
                                "fag1t",
                                "faget",
                                "fagg1t",
                                "faggit",
                                "faggot",
                                "fagg0t",
                                "fagit",
                                "fags",
                                "fagz",
                                "faig",
                                "faigs",
                                "fart",
                                "flipping the bird",
                                "fuck",
                                "fucker",
                                "fuckin",
                                "fucking",
                                "fucks",
                                "Fudge Packer",
                                "fuk",
                                "Fukah",
                                "Fuken",
                                "fuker",
                                "Fukin",
                                "Fukk",
                                "Fukkah",
                                "Fukken",
                                "Fukker",
                                "Fukkin",
                                "g00k",
                                "God-damned",
                                "h00r",
                                "h0ar",
                                "h0re",
                                "hells",
                                "hoar",
                                "hoor",
                                "hoore",
                                "jackoff",
                                "jap",
                                "japs",
                                "jerk-off",
                                "jisim",
                                "jiss",
                                "jizm",
                                "jizz",
                                "knob",
                                "knobs",
                                "knobz",
                                "kunt",
                                "kunts",
                                "kuntz",
                                "Lezzian",
                                "Lipshits",
                                "Lipshitz",
                                "masochist",
                                "masokist",
                                "massterbait",
                                "masstrbait",
                                "masstrbate",
                                "masterbaiter",
                                "masterbate",
                                "masterbates",
                                "Motha Fucker",
                                "Motha Fuker",
                                "Motha Fukkah",
                                "Motha Fukker",
                                "Mother Fucker",
                                "Mother Fukah",
                                "Mother Fuker",
                                "Mother Fukkah",
                                "Mother Fukker",
                                "mother-fucker",
                                "Mutha Fucker",
                                "Mutha Fukah",
                                "Mutha Fuker",
                                "Mutha Fukkah",
                                "Mutha Fukker",
                                "n1gr",
                                "nastt",
                                "nigger;",
                                "nigur;",
                                "niiger;",
                                "niigr;",
                                "orafis",
                                "orgasim;",
                                "orgasm",
                                "orgasum",
                                "oriface",
                                "orifice",
                                "orifiss",
                                "packi",
                                "packie",
                                "packy",
                                "paki",
                                "pakie",
                                "paky",
                                "pecker",
                                "peeenus",
                                "peeenusss",
                                "peenus",
                                "peinus",
                                "pen1s",
                                "penas",
                                "penis",
                                "penis-breath",
                                "penus",
                                "penuus",
                                "Phuc",
                                "Phuck",
                                "Phuk",
                                "Phuker",
                                "Phukker",
                                "polac",
                                "polack",
                                "polak",
                                "Poonani",
                                "pr1c",
                                "pr1ck",
                                "pr1k",
                                "pusse",
                                "pussee",
                                "pussy",
                                "puuke",
                                "puuker",
                                "queer",
                                "queers",
                                "queerz",
                                "qweers",
                                "qweerz",
                                "qweir",
                                "recktum",
                                "rectum",
                                "retard",
                                "sadist",
                                "scank",
                                "schlong",
                                "screwing",
                                "semen",
                                "sex",
                                "sexy",
                                "Sh!t",
                                "sh1t",
                                "sh1ter",
                                "sh1ts",
                                "sh1tter",
                                "sh1tz",
                                "shit",
                                "shits",
                                "shitter",
                                "Shitty",
                                "Shity",
                                "shitz",
                                "Shyt",
                                "Shyte",
                                "Shytty",
                                "Shyty",
                                "skanck",
                                "skank",
                                "skankee",
                                "skankey",
                                "skanks",
                                "Skanky",
                                "slag",
                                "slut",
                                "sluts",
                                "Slutty",
                                "slutz",
                                "son-of-a-bitch",
                                "tit",
                                "turd",
                                "va1jina",
                                "vag1na",
                                "vagiina",
                                "vagina",
                                "vaj1na",
                                "vajina",
                                "vullva",
                                "vulva",
                                "w0p",
                                "wh00r",
                                "wh0re",
                                "whore",
                                "xrated",
                                "xxx",
                                "b!+ch",
                                "bitch",
                                "blowjob",
                                "clit",
                                "arschloch",
                                "fuck",
                                "shit",
                                "ass",
                                "asshole",
                                "b!tch",
                                "b17ch",
                                "b1tch",
                                "bastard",
                                "bi+ch",
                                "boiolas",
                                "buceta",
                                "c0ck",
                                "cawk",
                                "chink",
                                "cipa",
                                "clits",
                                "cock",
                                "cum",
                                "cunt",
                                "dildo",
                                "dirsa",
                                "ejakulate",
                                "fatass",
                                "fcuk",
                                "fuk",
                                "fux0r",
                                "hoer",
                                "hore",
                                "jism",
                                "kawk",
                                "l3itch",
                                "l3i+ch",
                                "lesbian",
                                "masturbate",
                                "masterbat*",
                                "masterbat3",
                                "motherfucker",
                                "s.o.b.",
                                "mofo",
                                "nazi",
                                "nigga",
                                "nigger",
                                "nutsack",
                                "phuck",
                                "pimpis",
                                "pusse",
                                "pussy",
                                "scrotum",
                                "sh!t",
                                "shemale",
                                "shi+",
                                "sh!+",
                                "slut",
                                "smut",
                                "teets",
                                "tits",
                                "boobs",
                                "b00bs",
                                "teez",
                                "testical",
                                "testicle",
                                "titt",
                                "w00se",
                                "jackoff",
                                "wank",
                                "whoar",
                                "whore",
                                "*damn",
                                "*dyke",
                                "*fuck*",
                                "*shit*",
                                "@$$",
                                "amcik",
                                "andskota",
                                "arse*",
                                "assrammer",
                                "ayir",
                                "bi7ch",
                                "bitch*",
                                "bollock*",
                                "breasts",
                                "butt-pirate",
                                "cabron",
                                "cazzo",
                                "chraa",
                                "chuj",
                                "Cock*",
                                "cunt*",
                                "d4mn",
                                "daygo",
                                "dego",
                                "dick*",
                                "dike*",
                                "dupa",
                                "dziwka",
                                "ejackulate",
                                "Ekrem*",
                                "Ekto",
                                "enculer",
                                "faen",
                                "fag*",
                                "fanculo",
                                "fanny",
                                "feces",
                                "feg",
                                "Felcher",
                                "ficken",
                                "fitt*",
                                "Flikker",
                                "foreskin",
                                "Fotze",
                                "Fu(*",
                                "fuk*",
                                "futkretzn",
                                "gook",
                                "guiena",
                                "h0r",
                                "h4x0r",
                                "hell",
                                "helvete",
                                "hoer*",
                                "honkey",
                                "Huevon",
                                "hui",
                                "injun",
                                "jizz",
                                "kanker*",
                                "kike",
                                "klootzak",
                                "kraut",
                                "knulle",
                                "kuk",
                                "kuksuger",
                                "Kurac",
                                "kurwa",
                                "kusi*",
                                "kyrpa*",
                                "lesbo",
                                "mamhoon",
                                "masturbat*",
                                "merd*",
                                "mibun",
                                "monkleigh",
                                "mouliewop",
                                "muie",
                                "mulkku",
                                "muschi",
                                "nazis",
                                "nepesaurio",
                                "nigger*",
                                "orospu",
                                "paska*",
                                "perse",
                                "picka",
                                "pierdol*",
                                "pillu*",
                                "pimmel",
                                "piss*",
                                "pizda",
                                "poontsee",
                                "poop",
                                "porn",
                                "p0rn",
                                "pr0n",
                                "preteen",
                                "pula",
                                "pule",
                                "puta",
                                "puto",
                                "qahbeh",
                                "queef*",
                                "rautenberg",
                                "schaffer",
                                "scheiss*",
                                "schlampe",
                                "schmuck",
                                "screw",
                                "sh!t*",
                                "sharmuta",
                                "sharmute",
                                "shipal",
                                "shiz",
                                "skribz",
                                "skurwysyn",
                                "sphencter",
                                "spic",
                                "spierdalaj",
                                "splooge",
                                "suka",
                                "b00b*",
                                "testicle*",
                                "titt*",
                                "twat",
                                "vittu",
                                "wank*",
                                "wetback*",
                                "wichser",
                                "wop*",
                                "yed",
                                "zabourah",
                                "4r5e",
                                "5h1t",
                                "5hit",
                                "a55",
                                "anal",
                                "anus",
                                "ar5e",
                                "arrse",
                                "arse",
                                "ass",
                                "ass-fucker",
                                "asses",
                                "assfucker",
                                "assfukka",
                                "asshole",
                                "assholes",
                                "asswhole",
                                "a_s_s",
                                "b!tch",
                                "b00bs",
                                "b17ch",
                                "b1tch",
                                "ballbag",
                                "balls",
                                "ballsack",
                                "bastard",
                                "beastial",
                                "beastiality",
                                "bellend",
                                "bestial",
                                "bestiality",
                                "bi+ch",
                                "biatch",
                                "bitch",
                                "bitcher",
                                "bitchers",
                                "bitches",
                                "bitchin",
                                "bitching",
                                "bloody",
                                "blow job",
                                "blowjob",
                                "blowjobs",
                                "boiolas",
                                "bollock",
                                "bollok",
                                "boner",
                                "boob",
                                "boobs",
                                "booobs",
                                "boooobs",
                                "booooobs",
                                "booooooobs",
                                "breasts",
                                "buceta",
                                "bugger",
                                "bum",
                                "bunny fucker",
                                "butt",
                                "butthole",
                                "buttmuch",
                                "buttplug",
                                "c0ck",
                                "c0cksucker",
                                "carpet muncher",
                                "cawk",
                                "chink",
                                "cipa",
                                "cl1t",
                                "clit",
                                "clitoris",
                                "clits",
                                "cnut",
                                "cock",
                                "cock-sucker",
                                "cockface",
                                "cockhead",
                                "cockmunch",
                                "cockmuncher",
                                "cocks",
                                "cocksuck",
                                "cocksucked",
                                "cocksucker",
                                "cocksucking",
                                "cocksucks",
                                "cocksuka",
                                "cocksukka",
                                "cok",
                                "cokmuncher",
                                "coksucka",
                                "coon",
                                "cox",
                                "crap",
                                "cum",
                                "cummer",
                                "cumming",
                                "cums",
                                "cumshot",
                                "cunilingus",
                                "cunillingus",
                                "cunnilingus",
                                "cunt",
                                "cuntlick",
                                "cuntlicker",
                                "cuntlicking",
                                "cunts",
                                "cyalis",
                                "cyberfuc",
                                "cyberfuck",
                                "cyberfucked",
                                "cyberfucker",
                                "cyberfuckers",
                                "cyberfucking",
                                "d1ck",
                                "damn",
                                "dick",
                                "dickhead",
                                "dildo",
                                "dildos",
                                "dink",
                                "dinks",
                                "dirsa",
                                "dlck",
                                "dog-fucker",
                                "doggin",
                                "dogging",
                                "donkeyribber",
                                "doosh",
                                "duche",
                                "dyke",
                                "ejaculate",
                                "ejaculated",
                                "ejaculates",
                                "ejaculating",
                                "ejaculatings",
                                "ejaculation",
                                "ejakulate",
                                "f u c k",
                                "f u c k e r",
                                "f4nny",
                                "fag",
                                "fagging",
                                "faggitt",
                                "faggot",
                                "faggs",
                                "fagot",
                                "fagots",
                                "fags",
                                "fanny",
                                "fannyflaps",
                                "fannyfucker",
                                "fanyy",
                                "fatass",
                                "fcuk",
                                "fcuker",
                                "fcuking",
                                "feck",
                                "fecker",
                                "felching",
                                "fellate",
                                "fellatio",
                                "fingerfuck",
                                "fingerfucked",
                                "fingerfucker",
                                "fingerfuckers",
                                "fingerfucking",
                                "fingerfucks",
                                "fistfuck",
                                "fistfucked",
                                "fistfucker",
                                "fistfuckers",
                                "fistfucking",
                                "fistfuckings",
                                "fistfucks",
                                "flange",
                                "fook",
                                "fooker",
                                "fuck",
                                "fucka",
                                "fucked",
                                "fucker",
                                "fuckers",
                                "fuckhead",
                                "fuckheads",
                                "fuckin",
                                "fucking",
                                "fuckings",
                                "fuckingshitmotherfucker",
                                "fuckme",
                                "fucks",
                                "fuckwhit",
                                "fuckwit",
                                "fudge packer",
                                "fudgepacker",
                                "fuk",
                                "fuker",
                                "fukker",
                                "fukkin",
                                "fuks",
                                "fukwhit",
                                "fukwit",
                                "fux",
                                "fux0r",
                                "f_u_c_k",
                                "gangbang",
                                "gangbanged",
                                "gangbangs",
                                "gaylord",
                                "gaysex",
                                "goatse",
                                "God",
                                "god-dam",
                                "god-damned",
                                "goddamn",
                                "goddamned",
                                "hardcoresex",
                                "hell",
                                "heshe",
                                "hoar",
                                "hoare",
                                "hoer",
                                "homo",
                                "hore",
                                "horniest",
                                "horny",
                                "hotsex",
                                "jack-off",
                                "jackoff",
                                "jap",
                                "jerk-off",
                                "jism",
                                "jiz",
                                "jizm",
                                "jizz",
                                "kawk",
                                "knob",
                                "knobead",
                                "knobed",
                                "knobend",
                                "knobhead",
                                "knobjocky",
                                "knobjokey",
                                "kock",
                                "kondum",
                                "kondums",
                                "kum",
                                "kummer",
                                "kumming",
                                "kums",
                                "kunilingus",
                                "l3i+ch",
                                "l3itch",
                                "labia",
                                "lust",
                                "lusting",
                                "m0f0",
                                "m0fo",
                                "m45terbate",
                                "ma5terb8",
                                "ma5terbate",
                                "masochist",
                                "master-bate",
                                "masterb8",
                                "masterbat*",
                                "masterbat3",
                                "masterbate",
                                "masterbation",
                                "masterbations",
                                "masturbate",
                                "mo-fo",
                                "mof0",
                                "mofo",
                                "mothafuck",
                                "mothafucka",
                                "mothafuckas",
                                "mothafuckaz",
                                "mothafucked",
                                "mothafucker",
                                "mothafuckers",
                                "mothafuckin",
                                "mothafucking",
                                "mothafuckings",
                                "mothafucks",
                                "mother fucker",
                                "motherfuck",
                                "motherfucked",
                                "motherfucker",
                                "motherfuckers",
                                "motherfuckin",
                                "motherfucking",
                                "motherfuckings",
                                "motherfuckka",
                                "motherfucks",
                                "muff",
                                "mutha",
                                "muthafecker",
                                "muthafuckker",
                                "muther",
                                "mutherfucker",
                                "n1gga",
                                "n1gger",
                                "nazi",
                                "nigg3r",
                                "nigg4h",
                                "nigga",
                                "niggah",
                                "niggas",
                                "niggaz",
                                "nigger",
                                "niggers",
                                "nob",
                                "nob jokey",
                                "nobhead",
                                "nobjocky",
                                "nobjokey",
                                "numbnuts",
                                "nutsack",
                                "orgasim",
                                "orgasims",
                                "orgasm",
                                "orgasms",
                                "p0rn",
                                "pawn",
                                "pecker",
                                "penis",
                                "penisfucker",
                                "phonesex",
                                "phuck",
                                "phuk",
                                "phuked",
                                "phuking",
                                "phukked",
                                "phukking",
                                "phuks",
                                "phuq",
                                "pigfucker",
                                "pimpis",
                                "piss",
                                "pissed",
                                "pisser",
                                "pissers",
                                "pisses",
                                "pissflaps",
                                "pissin",
                                "pissing",
                                "pissoff",
                                "poop",
                                "porn",
                                "porno",
                                "pornography",
                                "pornos",
                                "prick",
                                "pricks",
                                "pron",
                                "pube",
                                "pusse",
                                "pussi",
                                "pussies",
                                "pussy",
                                "pussys",
                                "rectum",
                                "retard",
                                "rimjaw",
                                "rimming",
                                "s hit",
                                "s.o.b.",
                                "sadist",
                                "schlong",
                                "screwing",
                                "scroat",
                                "scrote",
                                "scrotum",
                                "semen",
                                "sex",
                                "sh!+",
                                "sh!t",
                                "sh1t",
                                "shag",
                                "shagger",
                                "shaggin",
                                "shagging",
                                "shemale",
                                "shi+",
                                "shit",
                                "shitdick",
                                "shite",
                                "shited",
                                "shitey",
                                "shitfuck",
                                "shitfull",
                                "shithead",
                                "shiting",
                                "shitings",
                                "shits",
                                "shitted",
                                "shitter",
                                "shitters",
                                "shitting",
                                "shittings",
                                "shitty",
                                "skank",
                                "slut",
                                "sluts",
                                "smegma",
                                "smut",
                                "snatch",
                                "son-of-a-bitch",
                                "spac",
                                "spunk",
                                "s_h_i_t",
                                "t1tt1e5",
                                "t1tties",
                                "teets",
                                "teez",
                                "testical",
                                "testicle",
                                "tit",
                                "titfuck",
                                "tits",
                                "titt",
                                "tittie5",
                                "tittiefucker",
                                "titties",
                                "tittyfuck",
                                "tittywank",
                                "titwank",
                                "tosser",
                                "turd",
                                "tw4t",
                                "twat",
                                "twathead",
                                "twatty",
                                "twunt",
                                "twunter",
                                "v14gra",
                                "v1gra",
                                "vagina",
                                "viagra",
                                "vulva",
                                "w00se",
                                "wang",
                                "wank",
                                "wanker",
                                "wanky",
                                "whoar",
                                "whore",
                                "willies",
                                "willy",
                                "xrated",
                                "xxx",
                                "jew",
                                "black",
                                "baby",
                                "child",
                                "white",
                                "porn",
                                "pedo",
                                "trump",
                                "clinton",
                                "hitler",
                                "nazi",
                                "gay",
                                "pride",
                                "sex",
                                "pleasure",
                                "touch",
                                "poo",
                                "kids",
                                "rape",
                                "white power",
                                "nigga",
                                "nig nog",
                                "doggy",
                                "rapist",
                                "boner",
                                "nigger",
                                "nigg",
                                "finger",
                                "nogger",
                                "nagger",
                                "nig",
                                "fag",
                                "gai",
                                "pole",
                                "stripper",
                                "penis",
                                "vagina",
                                "pussy",
                                "nazi",
                                "hitler",
                                "stalin",
                                "burn",
                                "chamber",
                                "cock",
                                "peen",
                                "dick",
                                "spick",
                                "nieger",
                                "die",
                                "satan",
                                "n|ig",
                                "nlg",
                                "cunt",
                                "c0ck",
                                "fag",
                                "lick",
                                "condom",
                                "anal",
                                "shit",
                                "phile",
                                "little",
                                "kids",
                                "free KR",
                                "tiny",
                                "sidney",
                                "ass",
                                "kill",
                                ".io",
                                "(dot)",
                                "[dot]",
                                "mini",
                                "whiore",
                                "whore",
                                "faggot",
                                "github",
                                "1337",
                                "666",
                                "satan",
                                "senpa",
                                "discord",
                                "d1scord",
                                "mistik",
                                ".io",
                                "senpa.io",
                                "sidney",
                                "sid",
                                "senpaio",
                                "vries",
                                "asa"
                            ],
                            "exclude": [],
                            "placeHolder": "*",
                            "regex": {},
                            "replaceRegex": {}
                        };

                        let isProfane = false;
                        let convertedName = name.toLowerCase().replace(/\s/g, "").replace(/1/g, "i").replace(/0/g, "o").replace(/5/g, "s");
                        for (let word of langFilter.list) {
                            if (convertedName.indexOf(word) != -1) {
                                isProfane = true;
                                break;
                            }
                        }

                        if (name.length > 0 && !isProfane) {
                            noname = name;
                        }

                        return noname;
                    }
                };
                unsafeWindow.toggleNight();
            },
            webgl_test: () => {
                return;
                let canvas = document.createElement("canvas");
                canvas.id = "WEBGL";
                canvas.width = canvas.height = 300;
                canvas.style = `
            position: relative;
            bottom: 70%;
            left: 70%;
            pointer-events: none;
            `;

                let fat = document.createElement("div");
                fat.id = "faku";
                fat.width = fat.height = 300;
                fat.style = `
            position: relative;
            bottom: 70%;
            left: 70%;
            pointer-events: none;
            font-size: 20px;
            `;
                fat.innerHTML = "Webgl Test Rendering";

                let gl = canvas.getContext("webgl");
                if (!gl) {
                    alert("urbad");
                    return;
                }

                document.body.append(canvas);
                document.body.append(fat);
                log(gl);

                gl.clearColor(0, 0, 0, 0.2);
                gl.clear(gl.COLOR_BUFFER_BIT);

                let buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

                function render(vs, fs, vertice, type) {

                    let vShader = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vShader, vs);
                    gl.compileShader(vShader);
                    gl.getShaderParameter(vShader, gl.COMPILE_STATUS);

                    let fShader = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fShader, fs);
                    gl.compileShader(fShader);
                    gl.getShaderParameter(fShader, gl.COMPILE_STATUS);

                    let program = gl.createProgram();
                    gl.attachShader(program, vShader);
                    gl.attachShader(program, fShader);
                    gl.linkProgram(program);
                    gl.getProgramParameter(program, gl.LINK_STATUS);
                    gl.useProgram(program);

                    let vertex = gl.getAttribLocation(program, "vertex");
                    gl.enableVertexAttribArray(vertex);
                    gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, 0, 0);

                    let vertices = vertice.length / 2;
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertice), gl.DYNAMIC_DRAW);
                    gl.drawArrays(type, 0, vertices);
                }

                function hexToRgb(hex) {
                    return hex.slice(1).match(/.{1,2}/g).map(g => parseInt(g, 16));
                }

                function getRgb(r, g, b) {
                    return [r / 255, g / 255, b / 255].join(", ");
                }

                let max = 50;
                for (let i = 0; i < max; i++) {
                    let radian = (Math.PI * (i / (max / 2)));
                    render(`
                precision mediump float;
                attribute vec2 vertex;
                void main(void) {
                    gl_Position = vec4(vertex, 0, 1);
                }
                `,`
                precision mediump float;
                void main(void) {
                    gl_FragColor = vec4(${getRgb(...hexToRgb("#cc5151"))}, 1);
                }
                `, [
                        // moveto, lineto
                        0 + (Math.cos(radian) * 0.5), 0 + (Math.sin(radian) * 0.5),
                        0, 0,
                    ], gl.LINE_LOOP);
                }
            }
        };
        if (codes) {
            getToken()
                .then(({ token, In }) => {
                console.log({ token, In });
                $('#menuContainer').slideToggle(5000)
                return fetch(`${dn}/servers?v=1.26`)
                    .then(res => res.json())
                    .catch(err => {
                    console.error('Failed to parse servers JSON', err);
                    throw err;  // re-throw so the next catch runs if needed
                })
                    .then(servers => servers.find(e => e.region === region && e.name === name))
                    .catch(err => {
                    console.error('Failed to find matching server entry', err);
                    throw err;
                })
                    .then(server_ => {
                    console.log('Matched server:', server_, 'token:', token, 'In:', In);
                    for (let code in codes) {
                        let func = codes[code];
                        typeof func === "function" && func(server_, token, In);
                    }
                    //codes.main(server_, token, In);
                })
                    .catch(err => {
                    console.error('Error inside codes.main()', err);
                });

            })
                .catch(err => {
                console.error('Error in getToken() or initial setup', err);
            });
        }
    }(1);
}